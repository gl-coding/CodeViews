# 第5节

#### 第763题	**划分字母区间	中等	**
***
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。<br>示例 1:<br>输入: S = "ababcbacadefegdehijhklij"<br>输出: [9,7,8]<br>解释:<br>划分结果为 "ababcbaca", "defegde", "hijhklij"。<br>每个字母最多出现在一个片段中。<br>像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。<br>注意:<br>S的长度在[1, 500]之间。<br>S只包含小写字母'a'到'z'。
***

```python
todo
```
#### 第826题	**安排工作以达到最大收益	中等	**
***
有一些工作：difficulty[i] 表示第i个工作的难度，profit[i]表示第i个工作的收益。<br>现在我们有一些工人。worker[i]是第i个工人的能力，即该工人只能完成难度小于等于worker[i]的工作。<br>每一个工人都最多只能安排一个工作，但是一个工作可以完成多次。<br>举个例子，如果3个工人都尝试完成一份报酬为1的同样工作，那么总收益为 $3。如果一个工人不能完成任何工作，他的收益为 $0 。<br>我们能得到的最大收益是多少？<br>示例：<br>输入: difficulty = [2,4,6,8,10], profit = [10,20,30,40,50], worker = [4,5,6,7]<br>输出: 100<br>解释: 工人被分配的工作难度是 [4,4,6,6] ，分别获得 [20,20,30,30] 的收益。<br>提示:<br>1 <= difficulty.length = profit.length <= 10000<br>1 <= worker.length <= 10000<br>difficulty[i], profit[i], worker[i]  的范围是 [1, 10^5]
***

```python
todo
```
#### 第828题	**独特字符串	困难	**
***
如果一个字符在字符串 S 中有且仅有出现一次，那么我们称其为独特字符。<br>例如，在字符串 S = "LETTER" 中，"L" 和 "R" 可以被称为独特字符。<br>我们再定义 UNIQ(S) 作为字符串 S 中独特字符的个数。<br>那么，在 S = "LETTER" 中， UNIQ("LETTER") =  2。<br>对于给定字符串 S，计算其所有非空子串的独特字符的个数（即 UNIQ(substring)）之和。<br>如果在 S 的不同位置上出现两个甚至多个相同的子串，那么我们认为这些子串是不同的。<br>考虑到答案可能会非常大，规定返回格式为：结果 mod 10 ^ 9 + 7。<br>示例 1:<br>输入: "ABC"<br>输出: 10<br>解释: 所有可能的子串为："A","B","C","AB","BC" 和 "ABC"。<br>其中，每一个子串都由独特字符构成。<br>所以其长度总和为：1 + 1 + 1 + 2 + 2 + 3 = 10<br>示例 2:<br>输入: "ABA"<br>输出: 8<br>解释: 除了子串 UNIQ('ABA') = 1，其余与示例1相同。<br>说明: 0 <= S.length <= 10000。
***

```python
todo
```
#### 第838题	**推多米诺	中等	**
***
一行中有 N 张多米诺骨牌，我们将每张多米诺骨牌垂直竖立。<br>在开始时，我们同时把一些多米诺骨牌向左或向右推。<br>每过一秒，倒向左边的多米诺骨牌会推动其左侧相邻的多米诺骨牌。<br>同样地，倒向右边的多米诺骨牌也会推动竖立在其右侧的相邻多米诺骨牌。<br>如果同时有多米诺骨牌落在一张垂直竖立的多米诺骨牌的两边，由于受力平衡， 该骨牌仍然保持不变。<br>就这个问题而言，我们会认为正在下降的多米诺骨牌不会对其它正在下降或已经下降的多米诺骨牌施加额外的力。<br>给定表示初始状态的字符串 "S" 。如果第 i 张多米诺骨牌被推向左边，则 S[i] = 'L'；如果第 i 张多米诺骨牌被推向右边，则 S[i] = 'R'；如果第 i 张多米诺骨牌没有被推动，则 S[i] = '.'。<br>返回表示最终状态的字符串。<br>示例 1：<br>输入：".L.R...LR..L.."<br>输出："LL.RR.LLRRLL.."<br>示例 2：<br>输入："RR.L"<br>输出："RR.L"<br>说明：第一张多米诺骨牌没有给第二张施加额外的力。<br>提示：<br>0 <= N <= 10^5<br>表示多米诺骨牌状态的字符串只含有 'L'，'R'; 以及 '.';
***

```python
todo
```
#### 第844题	**比较含退格的字符串	简单	**
***
给定 S 和 T 两个字符串，当它们分别被输入到空白的文本编辑器后，判断二者是否相等，并返回结果。 # 代表退格字符。<br>示例 1：<br>输入：S = "ab#c", T = "ad#c"<br>输出：true<br>解释：S 和 T 都会变成 “ac”。<br>示例 2：<br>输入：S = "ab##", T = "c#d#"<br>输出：true<br>解释：S 和 T 都会变成 “”。<br>示例 3：<br>输入：S = "a##c", T = "#a#c"<br>输出：true<br>解释：S 和 T 都会变成 “c”。<br>示例 4：<br>输入：S = "a#c", T = "b"<br>输出：false<br>解释：S 会变成 “c”，但 T 仍然是 “b”。<br>提示：<br>1 <= S.length <= 200<br>1 <= T.length <= 200<br>S 和 T 只含有小写字母以及字符 '#'。
***

```python
todo
```
#### 第845题	**数组中的最长山脉	中等	**
***
我们把数组 A 中符合下列属性的任意连续子数组 B 称为 “山脉”：<br>B.length >= 3<br>存在 0 < i < B.length - 1 使得 B[0] < B[1] < ... B[i-1] < B[i] > B[i+1] > ... > B[B.length - 1]<br>（注意：B 可以是 A 的任意子数组，包括整个数组 A。）<br>给出一个整数数组 A，返回最长 “山脉” 的长度。<br>如果不含有 “山脉” 则返回 0。<br>示例 1：<br>输入：[2,1,4,7,3,2,5]<br>输出：5<br>解释：最长的 “山脉” 是 [1,4,7,3,2]，长度为 5。<br>示例 2：<br>输入：[2,2,2]<br>输出：0<br>解释：不含 “山脉”。<br>提示：<br>0 <= A.length <= 10000<br>0 <= A[i] <= 10000
***

```python
todo
```
#### 第881题	**救生艇	中等	**
***
第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。<br>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。<br>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。<br>示例 1：<br>输入：people = [1,2], limit = 3<br>输出：1<br>解释：1 艘船载 (1, 2)<br>示例 2：<br>输入：people = [3,2,2,1], limit = 3<br>输出：3<br>解释：3 艘船分别载 (1, 2), (2) 和 (3)<br>示例 3：<br>输入：people = [3,5,3,4], limit = 5<br>输出：4<br>解释：4 艘船分别载 (3), (3), (4), (5)<br>提示：<br>1 <= people.length <= 50000<br>1 <= people[i] <= limit <= 30000
***

```python
todo
```
#### 第904题	**水果成篮	中等	**
***
在一排树中，第 i 棵树产生 tree[i] 型的水果。<br>你可以从你选择的任何树开始，然后重复执行以下步骤：<br>把这棵树上的水果放进你的篮子里。如果你做不到，就停下来。<br>移动到当前树右侧的下一棵树。如果右边没有树，就停下来。<br>请注意，在选择一颗树后，你没有任何选择：你必须执行步骤 1，然后执行步骤 2，然后返回步骤 1，然后执行步骤 2，依此类推，直至停止。<br>你有两个篮子，每个篮子可以携带任何数量的水果，但你希望每个篮子只携带一种类型的水果。<br>用这个程序你能收集的水果总量是多少？<br>示例 1：<br>输入：[1,2,1]<br>输出：3<br>解释：我们可以收集 [1,2,1]。<br>示例 2：<br>输入：[0,1,2,2]<br>输出：3<br>解释：我们可以收集 [1,2,2].<br>如果我们从第一棵树开始，我们将只能收集到 [0, 1]。<br>示例 3：<br>输入：[1,2,3,2,2]<br>输出：4<br>解释：我们可以收集 [2,3,2,2].<br>如果我们从第一棵树开始，我们将只能收集到 [1, 2]。<br>示例 4：<br>输入：[3,3,3,1,2,1,1,2,3,3,4]<br>输出：5<br>解释：我们可以收集 [1,2,1,1,2].<br>如果我们从第一棵树或第八棵树开始，我们将只能收集到 4 个水果。<br>提示：<br>1 <= tree.length <= 40000<br>0 <= tree[i] < tree.length
***

```python
todo
```
#### 第923题	**三数之和的多种可能	中等	**
***
给定一个整数数组 A，以及一个整数 target 作为目标值，返回满足 i < j < k 且 A[i] + A[j] + A[k] == target 的元组 i, j, k 的数量。<br>由于结果会非常大，请返回 结果除以 10^9 + 7 的余数。<br>示例 1：<br>输入：A = [1,1,2,2,3,3,4,4,5,5], target = 8<br>输出：20<br>解释：<br>按值枚举（A[i]，A[j]，A[k]）：<br>(1, 2, 5) 出现 8 次；<br>(1, 3, 4) 出现 8 次；<br>(2, 2, 4) 出现 2 次；<br>(2, 3, 3) 出现 2 次。<br>示例 2：<br>输入：A = [1,1,2,2,2,2], target = 5<br>输出：12<br>解释：<br>A[i] = 1，A[j] = A[k] = 2 出现 12 次：<br>我们从 [1,1] 中选择一个 1，有 2 种情况，<br>从 [2,2,2,2] 中选出两个 2，有 6 种情况。<br>提示：<br>3 <= A.length <= 3000<br>0 <= A[i] <= 100<br>0 <= target <= 300
***

```python
todo
```
#### 第925题	**长按键入	简单	**
***
你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。<br>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。<br>示例 1：<br>输入：name = "alex", typed = "aaleex"<br>输出：true<br>解释：'alex' 中的 'a' 和 'e' 被长按。<br>示例 2：<br>输入：name = "saeed", typed = "ssaaedd"<br>输出：false<br>解释：'e' 一定需要被键入两次，但在 typed 的输出中不是这样。<br>示例 3：<br>输入：name = "leelee", typed = "lleeelee"<br>输出：true<br>示例 4：<br>输入：name = "laiden", typed = "laiden"<br>输出：true<br>解释：长按名字中的字符并不是必要的。<br>提示：<br>name.length <= 1000<br>typed.length <= 1000<br>name 和 typed 的字符都是小写字母。
***

```python
todo
```
#### 第930题	**和相同的二元子数组	中等	**
***
在由若干 0 和 1  组成的数组 A 中，有多少个和为 S 的非空子数组。<br>示例：<br>输入：A = [1,0,1,0,1], S = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>提示：<br>A.length <= 30000<br>0 <= S <= A.length<br>A[i] 为 0 或 1
***

```python
todo
```
#### 第977题	**有序数组的平方	简单	**
***
给定一个按非递减顺序排序的整数数组 A，返回每个数字的平方组成的新数组，要求也按非递减顺序排序。<br>示例 1：<br>输入：[-4,-1,0,3,10]<br>输出：[0,1,9,16,100]<br>示例 2：<br>输入：[-7,-3,2,3,11]<br>输出：[4,9,9,49,121]<br>提示：<br>1 <= A.length <= 10000<br>-10000 <= A[i] <= 10000<br>A 已按非递减顺序排序。
***

```python
todo
```
