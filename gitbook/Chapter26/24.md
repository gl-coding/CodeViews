# 第3节

#### 第839题	**相似字符串组	困难	**
***
如果我们交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。<br>例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。<br>总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。<br>我们给出了一个不包含重复的字符串列表 A。列表中的每个字符串都是 A 中其它所有字符串的一个字母异位词。请问 A 中有多少个相似字符串组？<br>示例：<br>输入：["tars","rats","arts","star"]<br>输出：2<br>提示：<br>A.length <= 2000<br>A[i].length <= 1000<br>A.length * A[i].length <= 20000<br>A 中的所有单词都只包含小写字母。<br>A 中的所有单词都具有相同的长度，且是彼此的字母异位词。<br>此问题的判断限制时间已经延长。<br>备注：<br>字母异位词[anagram]，一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。
***

```python
todo
```
#### 第841题	**钥匙和房间	中等	**
***
有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。<br>在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。<br>最初，除 0 号房间外的其余所有房间都被锁住。<br>你可以自由地在房间之间来回走动。<br>如果能进入每个房间返回 true，否则返回 false。<br>示例 1：<br>输入: [[1],[2],[3],[]]<br>输出: true<br>解释:<br>我们从 0 号房间开始，拿到钥匙 1。<br>之后我们去 1 号房间，拿到钥匙 2。<br>然后我们去 2 号房间，拿到钥匙 3。<br>最后我们去了 3 号房间。<br>由于我们能够进入每个房间，我们返回 true。<br>示例 2：<br>输入：[[1,3],[3,0,1],[2],[0]]<br>输出：false<br>解释：我们不能进入 2 号房间。<br>提示：<br>1 <= rooms.length <= 1000<br>0 <= rooms[i].length <= 1000<br>所有房间中的钥匙数量总计不超过 3000。
***

```python
todo
```
#### 第854题	**相似度为 K 的字符串	困难	**
***
如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串 A 和 B 的相似度为 K（K 为非负整数）。<br>给定两个字母异位词 A 和 B ，返回 A 和 B 的相似度 K 的最小值。<br>示例 1：<br>输入：A = "ab", B = "ba"<br>输出：1<br>示例 2：<br>输入：A = "abc", B = "bca"<br>输出：2<br>示例 3：<br>输入：A = "abac", B = "baca"<br>输出：2<br>示例 4：<br>输入：A = "aabc", B = "abca"<br>输出：2<br>提示：<br>1 <= A.length == B.length <= 20<br>A 和 B 只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母。
***

```python
todo
```
#### 第928题	**尽量减少恶意软件的传播 II	困难	**
***
(这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。)<br>在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。<br>一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。<br>假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。<br>我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。<br>示例 1：<br>输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]<br>输入：0<br>示例 2：<br>输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]<br>输出：1<br>示例 3：<br>输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]<br>输出：1<br>提示：<br>1 < graph.length = graph[0].length <= 300<br>0 <= graph[i][j] == graph[j][i] <= 1<br>graph[i][i] = 1<br>1 <= initial.length < graph.length<br>0 <= initial[i] < graph.length
***

```python
todo
```
#### 第959题	**由斜杠划分区域	中等	**
***
在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。<br>（请注意，反斜杠字符是转义的，因此 \ 用 "\\" 表示。）。<br>返回区域的数目。<br>示例 1：<br>输入：<br>[<br>" /",<br>"/ "<br>]<br>输出：2<br>解释：2x2 网格如下：<br>示例 2：<br>输入：<br>[<br>" /",<br>"  "<br>]<br>输出：1<br>解释：2x2 网格如下：<br>示例 3：<br>输入：<br>[<br>"\\/",<br>"/\\"<br>]<br>输出：4<br>解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）<br>2x2 网格如下：<br>示例 4：<br>输入：<br>[<br>"/\\",<br>"\\/"<br>]<br>输出：5<br>解释：（回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。）<br>2x2 网格如下：<br>示例 5：<br>输入：<br>[<br>"//",<br>"/ "<br>]<br>输出：3<br>解释：2x2 网格如下：<br>提示：<br>1 <= grid.length == grid[0].length <= 30<br>grid[i][j] 是 '/'、'\'、或 ' '。
***

```python
todo
```
#### 第990题	**等式方程的可满足性	中等	**
***
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。<br>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。<br>示例 1：<br>输入：["a==b","b!=a"]<br>输出：false<br>解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。<br>示例 2：<br>输出：["b==a","a==b"]<br>输入：true<br>解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。<br>示例 3：<br>输入：["a==b","b==c","a==c"]<br>输出：true<br>示例 4：<br>输入：["a==b","b!=c","c==a"]<br>输出：false<br>示例 5：<br>输入：["c==c","b==d","x!=z"]<br>输出：true<br>提示：<br>1 <= equations.length <= 500<br>equations[i].length == 4<br>equations[i][0] 和 equations[i][3] 是小写字母<br>equations[i][1] 要么是 '='，要么是 '!'<br>equations[i][2] 是 '='
***

```python
todo
```
#### 第996题	**正方形数组的数目	困难	**
***
给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。<br>返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。<br>示例 1：<br>输入：[1,17,8]<br>输出：2<br>解释：<br>[1,8,17] 和 [17,8,1] 都是有效的排列。<br>示例 2：<br>输入：[2,2,2]<br>输出：1<br>提示：<br>1 <= A.length <= 12<br>0 <= A[i] <= 1e9
***

```python
todo
```
#### 第997题	**找到小镇的法官	简单	**
***
在一个小镇里，按从 1 到 N 标记了 N 个人。传言称，这些人中有一个是小镇上的秘密法官。<br>如果小镇的法官真的存在，那么：<br>小镇的法官不相信任何人。<br>每个人（除了小镇法官外）都信任小镇的法官。<br>只有一个人同时满足属性 1 和属性 2 。<br>给定数组 trust，该数组由信任对 trust[i] = [a, b] 组成，表示标记为 a 的人信任标记为 b 的人。<br>如果小镇存在秘密法官并且可以确定他的身份，请返回该法官的标记。否则，返回 -1。<br>示例 1：<br>输入：N = 2, trust = [[1,2]]<br>输出：2<br>示例 2：<br>输入：N = 3, trust = [[1,3],[2,3]]<br>输出：3<br>示例 3：<br>输入：N = 3, trust = [[1,3],[2,3],[3,1]]<br>输出：-1<br>示例 4：<br>输入：N = 3, trust = [[1,2],[2,3]]<br>输出：-1<br>示例 5：<br>输入：N = 4, trust = [[1,3],[1,4],[2,3],[2,4],[4,3]]<br>输出：3<br>提示：<br>1 <= N <= 1000<br>trust.length <= 10000<br>trust[i] 是完全不同的<br>trust[i][0] != trust[i][1]<br>1 <= trust[i][0], trust[i][1] <= N
***

```python
todo
```
#### 第1042题	**不邻接植花	简单	**
***
有 N 个花园，按从 1 到 N 标记。在每个花园中，你打算种下四种花之一。<br>paths[i] = [x, y] 描述了花园 x 到花园 y 的双向路径。<br>另外，没有花园有 3 条以上的路径可以进入或者离开。<br>你需要为每个花园选择一种花，使得通过路径相连的任何两个花园中的花的种类互不相同。<br>以数组形式返回选择的方案作为答案 answer，其中 answer[i] 为在第 (i+1) 个花园中种植的花的种类。花的种类用  1, 2, 3, 4 表示。保证存在答案。<br>示例 1：<br>输入：N = 3, paths = [[1,2],[2,3],[3,1]]<br>输出：[1,2,3]<br>示例 2：<br>输入：N = 4, paths = [[1,2],[3,4]]<br>输出：[1,2,1,2]<br>示例 3：<br>输入：N = 4, paths = [[1,2],[2,3],[3,4],[4,1],[1,3],[2,4]]<br>输出：[1,2,3,4]<br>提示：<br>1 <= N <= 10000<br>0 <= paths.size <= 20000<br>不存在花园有 4 条或者更多路径可以进入或离开。<br>保证存在答案。
***

```python
todo
```
#### 第1043题	**分隔数组以得到最大和	中等	**
***
给出整数数组 A，将该数组分隔为长度最多为 K 的几个（连续）子数组。分隔完成后，每个子数组的中的值都会变为该子数组中的最大值。<br>返回给定数组完成分隔后的最大和。<br>示例：<br>输入：A = [1,15,7,9,2,5,10], K = 3<br>输出：84<br>解释：A 变为 [15,15,15,9,10,10,10]<br>提示：<br>1 <= K <= A.length <= 500<br>0 <= A[i] <= 10^6
***

```python
todo
```
#### 第1129题	**颜色交替的最短路径	中等	**
***
在一个有向图中，节点分别标记为 0, 1, ..., n-1。这个图中的每条边不是红色就是蓝色，且存在自环或平行边。<br>red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。<br>返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的最短路径的长度，且路径上红色边和蓝色边交替出现。如果不存在这样的路径，那么 answer[x] = -1。<br>示例 1：<br>输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []<br>输出：[0,1,-1]<br>示例 2：<br>输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]<br>输出：[0,1,-1]<br>示例 3：<br>输入：n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]<br>输出：[0,-1,-1]<br>示例 4：<br>输入：n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]<br>输出：[0,1,2]<br>示例 5：<br>输入：n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]<br>输出：[0,1,1]<br>提示：<br>1 <= n <= 100<br>red_edges.length <= 400<br>blue_edges.length <= 400<br>red_edges[i].length == blue_edges[i].length == 2<br>0 <= red_edges[i][j], blue_edges[i][j] < n
***

```python
todo
```
#### 第1161题	**最大层内元素和	中等	**
***
给你一个二叉树的根节点 root。设根节点位于二叉树的第 1 层，而根节点的子节点位于第 2 层，依此类推。<br>请你找出层内元素之和 最大 的那几层（可能只有一层）的层号，并返回其中 最小 的那个。<br>示例：<br>输入：[1,7,0,7,-8,null,null]<br>输出：2<br>解释：<br>第 1 层各元素之和为 1，<br>第 2 层各元素之和为 7 + 0 = 7，<br>第 3 层各元素之和为 7 + -8 = -1，<br>所以我们返回第 2 层的层号，它的层内元素之和最大。<br>提示：<br>树中的节点数介于 1 和 10^4 之间<br>-10^5 <= node.val <= 10^5
***

```python
todo
```
