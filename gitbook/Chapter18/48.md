# 第5节

#### 第907题	**子数组的最小值之和	中等	**
***
给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。<br>由于答案可能很大，因此返回答案模 10^9 + 7。<br>示例：<br>输入：[3,1,2,4]<br>输出：17<br>解释：<br>子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。<br>最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。<br>提示：<br>1 <= A <= 30000<br>1 <= A[i] <= 30000
***

```python
todo
```
#### 第921题	**使括号有效的最少添加	中等	**
***
给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。<br>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：<br>它是一个空字符串，或者<br>它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br>它可以被写作 (A)，其中 A 是有效字符串。<br>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。<br>示例 1：<br>输入："())"<br>输出：1<br>示例 2：<br>输入："((("<br>输出：3<br>示例 3：<br>输入："()"<br>输出：0<br>示例 4：<br>输入："()))(("<br>输出：4<br>提示：<br>S.length <= 1000<br>S 只包含 '(' 和 ')' 字符。
***

```python
todo
```
#### 第946题	**验证栈序列	中等	**
***
给定 pushed 和 popped 两个序列，每个序列中的 值都不重复，只有当它们可能是在最初空栈上进行的推入 push 和弹出 pop 操作序列的结果时，返回 true；否则，返回 false 。<br>示例 1：<br>输入：pushed = [1,2,3,4,5], popped = [4,5,3,2,1]<br>输出：true<br>解释：我们可以按以下顺序执行：<br>push(1), push(2), push(3), push(4), pop() -> 4,<br>push(5), pop() -> 5, pop() -> 3, pop() -> 2, pop() -> 1<br>示例 2：<br>输入：pushed = [1,2,3,4,5], popped = [4,3,5,1,2]<br>输出：false<br>解释：1 不能在 2 之前弹出。<br>提示：<br>0 <= pushed.length == popped.length <= 1000<br>0 <= pushed[i], popped[i] < 1000<br>pushed 是 popped 的排列。
***

```python
todo
```
#### 第975题	**奇偶跳	困难	**
***
给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。<br>你可以按以下方式从索引 i 向后跳转到索引 j（其中 i < j）：<br>在进行奇数跳跃时（如，第 1，3，5... 次跳跃），你将会跳到索引 j，使得 A[i] <= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。<br>在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 j，使得 A[i] => A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。<br>（对于某些索引 i，可能无法进行合乎要求的跳跃。）<br>如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。<br>返回好的起始索引的数量。<br>示例 1：<br>输入：[10,13,12,14,15]<br>输出：2<br>解释：<br>从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。<br>从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。<br>从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。<br>从起始索引 i = 4 出发，我们已经到达数组末尾。<br>总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。<br>示例 2：<br>输入：[2,3,1,1,4]<br>输出：3<br>解释：<br>从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：<br><br>在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。<br><br>在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。<br><br>在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。<br><br>我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。<br><br>类似地，我们可以推断：<br>从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。<br>从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。<br>从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。<br>从起始索引 i = 4 出发，我们已经到达数组末尾。<br>总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。<br>示例 3：<br>输入：[5,1,3,4,2]<br>输出：3<br>解释：<br>我们可以从起始索引 1，2，4 出发到达数组末尾。<br>提示：<br>1 <= A.length <= 20000<br>0 <= A[i] < 100000
***

```python
todo
```
#### 第1003题	**检查替换后的词是否有效	中等	**
***
给定有效字符串 "abc"。<br>对于任何有效的字符串 V，我们可以将 V 分成两个部分 X 和 Y，使得 X + Y（X 与 Y 连接）等于 V。（X 或 Y 可以为空。）那么，X + "abc" + Y 也同样是有效的。<br>例如，如果 S = "abc"，则有效字符串的示例是："abc"，"aabcbc"，"abcabc"，"abcabcababcc"。无效字符串的示例是："abccba"，"ab"，"cababc"，"bac"。<br>如果给定字符串 S 有效，则返回 true；否则，返回 false。<br>示例 1：<br>输入："aabcbc"<br>输出：true<br>解释：<br>从有效字符串 "abc" 开始。<br>然后我们可以在 "a" 和 "bc" 之间插入另一个 "abc"，产生 "a" + "abc" + "bc"，即 "aabcbc"。<br>示例 2：<br>输入："abcabcababcc"<br>输出：true<br>解释：<br>"abcabcabc" 是有效的，它可以视作在原串后连续插入 "abc"。<br>然后我们可以在最后一个字母之前插入 "abc"，产生 "abcabcab" + "abc" + "c"，即 "abcabcababcc"。<br>示例 3：<br>输入："abccba"<br>输出：false<br>示例 4：<br>输入："cababc"<br>输出：false<br>提示：<br>1 <= S.length <= 20000<br>S[i] 为 'a'、'b'、或 'c'
***

```python
todo
```
#### 第1019题	**链表中的下一个更大节点	中等	**
***
给出一个以头节点 head 作为第一个节点的链表。链表中的节点分别编号为：node_1, node_2, node_3, ... 。<br>每个节点都可能有下一个更大值（next larger value）：对于 node_i，如果其 next_larger(node_i) 是 node_j.val，那么就有 j > i 且  node_j.val > node_i.val，而 j 是可能的选项中最小的那个。如果不存在这样的 j，那么下一个更大值为 0 。<br>返回整数答案数组 answer，其中 answer[i] = next_larger(node_{i+1}) 。<br>注意：在下面的示例中，诸如 [2,1,5] 这样的输入（不是输出）是链表的序列化表示，其头节点的值为 2，第二个节点值为 1，第三个节点值为 5 。<br>示例 1：<br>输入：[2,1,5]<br>输出：[5,5,0]<br>示例 2：<br>输入：[2,7,4,3,5]<br>输出：[7,0,5,5,0]<br>示例 3：<br>输入：[1,7,5,1,9,2,5,1]<br>输出：[7,9,9,9,0,5,0,0]<br>提示：<br>对于链表中的每个节点，1 <= node.val <= 10^9<br>给定列表的长度在 [0, 10000] 范围内
***

```python
todo
```
#### 第1021题	**删除最外层的括号	简单	**
***
有效括号字符串为空 ("")、"(" + A + ")" 或 A + B，其中 A 和 B 都是有效的括号字符串，+ 代表字符串的连接。例如，""，"()"，"(())()" 和 "(()(()))" 都是有效的括号字符串。<br>如果有效字符串 S 非空，且不存在将其拆分为 S = A+B 的方法，我们称其为原语（primitive），其中 A 和 B 都是非空有效括号字符串。<br>给出一个非空有效字符串 S，考虑将其进行原语化分解，使得：S = P_1 + P_2 + ... + P_k，其中 P_i 是有效括号字符串原语。<br>对 S 进行原语化分解，删除分解中每个原语字符串的最外层括号，返回 S 。<br>示例 1：<br>输入："(()())(())"<br>输出："()()()"<br>解释：<br>输入字符串为 "(()())(())"，原语化分解得到 "(()())" + "(())"，<br>删除每个部分中的最外层括号后得到 "()()" + "()" = "()()()"。<br>示例 2：<br>输入："(()())(())(()(()))"<br>输出："()()()()(())"<br>解释：<br>输入字符串为 "(()())(())(()(()))"，原语化分解得到 "(()())" + "(())" + "(()(()))"，<br>删除每隔部分中的最外层括号后得到 "()()" + "()" + "()(())" = "()()()()(())"。<br>示例 3：<br>输入："()()"<br>输出：""<br>解释：<br>输入字符串为 "()()"，原语化分解得到 "()" + "()"，<br>删除每个部分中的最外层括号后得到 "" + "" = ""。<br>提示：<br>S.length <= 10000<br>S[i] 为 "(" 或 ")"<br>S 是一个有效括号字符串
***

```python
todo
```
#### 第1047题	**删除字符串中的所有相邻重复项	简单	**
***
给出由小写字母组成的字符串 S，重复项删除操作会选择两个相邻且相同的字母，并删除它们。<br>在 S 上反复执行重复项删除操作，直到无法继续删除。<br>在完成所有重复项删除操作后返回最终的字符串。答案保证唯一。<br>示例：<br>输入："abbaca"<br>输出："ca"<br>解释：<br>例如，在 "abbaca" 中，我们可以删除 "bb" 由于两字母相邻且相同，这是此时唯一可以执行删除操作的重复项。之后我们得到字符串 "aaca"，其中又只有 "aa" 可以执行重复项删除操作，所以最后的字符串为 "ca"。<br>提示：<br>1 <= S.length <= 20000<br>S 仅由小写英文字母组成。
***

```python
todo
```
#### 第1124题	**表现良好的最长时间段	中等	**
***
给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数。<br>我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是「劳累的一天」。<br>所谓「表现良好的时间段」，意味在这段时间内，「劳累的天数」是严格 大于「不劳累的天数」。<br>请你返回「表现良好时间段」的最大长度。<br>示例 1：<br>输入：hours = [9,9,6,0,6,6,9]<br>输出：3<br>解释：最长的表现良好时间段是 [9,9,6]。<br>提示：<br>1 <= hours.length <= 10000<br>0 <= hours[i] <= 16
***

```python
todo
```
#### 第1130题	**叶值的最小代价生成树	中等	**
***
给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：<br>每个节点都有 0 个或是 2 个子节点。<br>数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）<br>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。<br>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。<br>示例：<br>输入：arr = [6,2,4]<br>输出：32<br>解释：<br>有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。<br><br>24            24<br>/  \          /  \<br>12   4        6    8<br>/  \               / \<br>6    2             2   4<br>提示：<br>2 <= arr.length <= 40<br>1 <= arr[i] <= 15<br>答案保证是一个 32 位带符号整数，即小于 2^31。
***

```python
todo
```
#### 第1190题	**反转每对括号间的子串	中等	**
***
给出一个字符串 s（仅含有小写英文字母和括号）。<br>请你按照从括号内到外的顺序，逐层反转每对匹配括号中的字符串，并返回最终的结果。<br>注意，您的结果中 不应 包含任何括号。<br>示例 1：<br>输入：s = "(abcd)"<br>输出："dcba"<br>示例 2：<br>输入：s = "(u(love)i)"<br>输出："iloveu"<br>示例 3：<br>输入：s = "(ed(et(oc))el)"<br>输出："leetcode"<br>示例 4：<br>输入：s = "a(bcdefghijkl(mno)p)q"<br>输出："apmnolkjihgfedcbq"<br>提示：<br>0 <= s.length <= 2000<br>s 中只有小写英文字母和括号<br>我们确保所有括号都是成对出现的
***

```python
todo
```
#### 第1209题	**删除字符串中的所有相邻重复项 II	中等	**
***
给你一个字符串 s，「k 倍重复项删除操作」将会从 s 中选择 k 个相邻且相等的字母，并删除它们，使被删去的字符串的左侧和右侧连在一起。<br>你需要对 s 重复进行无限次这样的删除操作，直到无法继续为止。<br>在执行完所有删除操作后，返回最终得到的字符串。<br>本题答案保证唯一。<br>示例 1：<br>输入：s = "abcd", k = 2<br>输出："abcd"<br>解释：没有要删除的内容。<br>示例 2：<br>输入：s = "deeedbbcccbdaa", k = 3<br>输出："aa"<br>解释：<br>先删除 "eee" 和 "ccc"，得到 "ddbbbdaa"<br>再删除 "bbb"，得到 "dddaa"<br>最后删除 "ddd"，得到 "aa"<br>示例 3：<br>输入：s = "pbbcggttciiippooaais", k = 2<br>输出："ps"<br>提示：<br>1 <= s.length <= 10^5<br>2 <= k <= 10^4<br>s 中只含有小写英文字母。
***

```python
todo
```
