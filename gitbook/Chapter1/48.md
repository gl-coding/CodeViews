# 第5节

#### 第936题	**戳印序列	困难	**
***
你想要用小写字母组成一个目标字符串 target。<br>开始的时候，序列由 target.length 个 '?' 记号组成。而你有一个小写字母印章 stamp。<br>在每个回合，你可以将印章放在序列上，并将序列中的每个字母替换为印章上的相应字母。你最多可以进行 10 * target.length  个回合。<br>举个例子，如果初始序列为 "?????"，而你的印章 stamp 是 "abc"，那么在第一回合，你可以得到 "abc??"、"?abc?"、"??abc"。（请注意，印章必须完全包含在序列的边界内才能盖下去。）<br>如果可以印出序列，那么返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成。如果不能印出序列，就返回一个空数组。<br>例如，如果序列是 "ababc"，印章是 "abc"，那么我们就可以返回与操作 "?????" -> "abc??" -> "ababc" 相对应的答案 [0, 2]；<br>另外，如果可以印出序列，那么需要保证可以在 10 * target.length 个回合内完成。任何超过此数字的答案将不被接受。<br>示例 1：<br>输入：stamp = "abc", target = "ababc"<br>输出：[0,2]<br>（[1,0,2] 以及其他一些可能的结果也将作为答案被接受）<br>示例 2：<br>输入：stamp = "abca", target = "aabcaca"<br>输出：[3,0,1]<br>提示：<br>1 <= stamp.length <= target.length <= 1000<br>stamp 和 target 只包含小写字母。
***

```python
todo
```
#### 第944题	**删列造序	简单	**
***
给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。<br>删除 操作的定义是：选出一组要删掉的列，删去 A 中对应列中的所有字符，形式上，第 n 列为 [A[0][n], A[1][n], ..., A[A.length-1][n]]）。<br>比如，有 A = ["abcdef", "uvwxyz"]，<br>要删掉的列为 {0, 2, 3}，删除后 A 为["bef", "vyz"]， A 的列分别为["b","v"], ["e","y"], ["f","z"]。<br>你需要选出一组要删掉的列 D，对 A 执行删除操作，使 A 中剩余的每一列都是 非降序 排列的，然后请你返回 D.length 的最小可能值。<br>示例 1：<br>输入：["cba", "daf", "ghi"]<br>输出：1<br>解释：<br>当选择 D = {1}，删除后 A 的列为：["c","d","g"] 和 ["a","f","i"]，均为非降序排列。<br>若选择 D = {}，那么 A 的列 ["b","a","h"] 就不是非降序排列了。<br>示例 2：<br>输入：["a", "b"]<br>输出：0<br>解释：D = {}<br>示例 3：<br>输入：["zyx", "wvu", "tsr"]<br>输出：3<br>解释：D = {0, 1, 2}<br>提示：<br>1 <= A.length <= 100<br>1 <= A[i].length <= 1000
***

```python
todo
```
#### 第948题	**令牌放置	中等	**
***
你的初始能量为 P，初始分数为 0，只有一包令牌。<br>令牌的值为 token[i]，每个令牌最多只能使用一次，可能的两种使用方法如下：<br>如果你至少有 token[i] 点能量，可以将令牌置为正面朝上，失去 token[i] 点能量，并得到 1 分。<br>如果我们至少有 1 分，可以将令牌置为反面朝上，获得 token[i] 点能量，并失去 1 分。<br>在使用任意数量的令牌后，返回我们可以得到的最大分数。<br>示例 1：<br>输入：tokens = [100], P = 50<br>输出：0<br>示例 2：<br>输入：tokens = [100,200], P = 150<br>输出：1<br>示例 3：<br>输入：tokens = [100,200,300,400], P = 200<br>输出：2<br>提示：<br>tokens.length <= 1000<br>0 <= tokens[i] < 10000<br>0 <= P < 10000
***

```python
todo
```
#### 第955题	**删列造序 II	中等	**
***
给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。<br>选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。<br>比如，有 A = ["abcdef", "uvwxyz"]，删除索引序列 {0, 2, 3}，删除后 A 为["bef", "vyz"]。<br>假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组的元素是按 字典序（A[0] <= A[1] <= A[2] ... <= A[A.length - 1]）排列的，然后请你返回 D.length 的最小可能值。<br>示例 1：<br>输入：["ca","bb","ac"]<br>输出：1<br>解释：<br>删除第一列后，A = ["a", "b", "c"]。<br>现在 A 中元素是按字典排列的 (即，A[0] <= A[1] <= A[2])。<br>我们至少需要进行 1 次删除，因为最初 A 不是按字典序排列的，所以答案是 1。<br>示例 2：<br>输入：["xc","yb","za"]<br>输出：0<br>解释：<br>A 的列已经是按字典序排列了，所以我们不需要删除任何东西。<br>注意 A 的行不需要按字典序排列。<br>也就是说，A[0][0] <= A[0][1] <= ... 不一定成立。<br>示例 3：<br>输入：["zyx","wvu","tsr"]<br>输出：3<br>解释：<br>我们必须删掉每一列。<br>提示：<br>1 <= A.length <= 100<br>1 <= A[i].length <= 100
***

```python
todo
```
#### 第984题	**不含 AAA 或 BBB 的字符串	中等	**
***
给定两个整数 A 和 B，返回任意字符串 S，要求满足：<br>S 的长度为 A + B，且正好包含 A 个 'a' 字母与 B 个 'b' 字母；<br>子串 'aaa' 没有出现在 S 中；<br>子串 'bbb' 没有出现在 S 中。<br>示例 1：<br>输入：A = 1, B = 2<br>输出："abb"<br>解释："abb", "bab" 和 "bba" 都是正确答案。<br>示例 2：<br>输入：A = 4, B = 1<br>输出："aabaa"<br>提示：<br>0 <= A <= 100<br>0 <= B <= 100<br>对于给定的 A 和 B，保证存在满足要求的 S。
***

```python
todo
```
#### 第991题	**坏了的计算器	中等	**
***
在显示着数字的坏计算器上，我们可以执行以下两种操作：<br>双倍（Double）：将显示屏上的数字乘 2；<br>递减（Decrement）：将显示屏上的数字减 1 。<br>最初，计算器显示数字 X。<br>返回显示数字 Y 所需的最小操作数。<br>示例 1：<br>输入：X = 2, Y = 3<br>输出：2<br>解释：先进行双倍运算，然后再进行递减运算 {2 -> 4 -> 3}.<br>示例 2：<br>输入：X = 5, Y = 8<br>输出：2<br>解释：先递减，再双倍 {5 -> 4 -> 8}.<br>示例 3：<br>输入：X = 3, Y = 10<br>输出：3<br>解释：先双倍，然后递减，再双倍 {3 -> 6 -> 5 -> 10}.<br>示例 4：<br>输入：X = 1024, Y = 1<br>输出：1023<br>解释：执行递减运算 1023 次<br>提示：<br>1 <= X <= 10^9<br>1 <= Y <= 10^9
***

```python
todo
```
#### 第995题	**K 连续位的最小翻转次数	困难	**
***
在仅包含 0 和 1 的数组 A 中，一次 K 位翻转包括选择一个长度为 K 的（连续）子数组，同时将子数组中的每个 0 更改为 1，而每个 1 更改为 0。<br>返回所需的 K 位翻转的次数，以便数组没有值为 0 的元素。如果不可能，返回 -1。<br>示例 1：<br>输入：A = [0,1,0], K = 1<br>输出：2<br>解释：先翻转 A[0]，然后翻转 A[2]。<br>示例 2：<br>输入：A = [1,1,0], K = 2<br>输出：-1<br>解释：无论我们怎样翻转大小为 2 的子数组，我们都不能使数组变为 [1,1,1]。<br>示例 3：<br>输入：A = [0,0,0,1,0,1,1,0], K = 3<br>输出：3<br>解释：<br>翻转 A[0],A[1],A[2]: A变成 [1,1,1,1,0,1,1,0]<br>翻转 A[4],A[5],A[6]: A变成 [1,1,1,1,1,0,0,0]<br>翻转 A[5],A[6],A[7]: A变成 [1,1,1,1,1,1,1,1]<br>提示：<br>1 <= A.length <= 30000<br>1 <= K <= A.length
***

```python
todo
```
#### 第1005题	**K 次取反后最大化的数组和	简单	**
***
给定一个整数数组 A，我们只能用以下方法修改该数组：我们选择某个个索引 i 并将 A[i] 替换为 -A[i]，然后总共重复这个过程 K 次。（我们可以多次选择同一个索引 i。）<br>以这种方式修改数组后，返回数组可能的最大和。<br>示例 1：<br>输入：A = [4,2,3], K = 1<br>输出：5<br>解释：选择索引 (1,) ，然后 A 变为 [4,-2,3]。<br>示例 2：<br>输入：A = [3,-1,0,2], K = 3<br>输出：6<br>解释：选择索引 (1, 2, 2) ，然后 A 变为 [3,1,0,2]。<br>示例 3：<br>输入：A = [2,-3,-1,5,-4], K = 2<br>输出：13<br>解释：选择索引 (1, 4) ，然后 A 变为 [2,3,-1,5,4]。<br>提示：<br>1 <= A.length <= 10000<br>1 <= K <= 10000<br>-100 <= A[i] <= 100
***

```python
todo
```
#### 第1007题	**行相等的最少多米诺旋转	中等	**
***
在一排多米诺骨牌中，A[i] 和 B[i] 分别代表第 i 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）<br>我们可以旋转第 i 张多米诺，使得 A[i] 和 B[i] 的值交换。<br>返回能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。<br>如果无法做到，返回 -1.<br>示例 1：<br>输入：A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]<br>输出：2<br>解释：<br>图一表示：在我们旋转之前， A 和 B 给出的多米诺牌。<br>如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。<br>示例 2：<br>输入：A = [3,5,1,2,3], B = [3,6,3,3,4]<br>输出：-1<br>解释：<br>在这种情况下，不可能旋转多米诺牌使一行的值相等。<br>提示：<br>1 <= A[i], B[i] <= 6<br>2 <= A.length == B.length <= 20000
***

```python
todo
```
#### 第1029题	**两地调度	简单	**
***
公司计划面试 2N 人。第 i 人飞往 A 市的费用为 costs[i][0]，飞往 B 市的费用为 costs[i][1]。<br>返回将每个人都飞到某座城市的最低费用，要求每个城市都有 N 人抵达。<br>示例：<br>输入：[[10,20],[30,200],[400,50],[30,20]]<br>输出：110<br>解释：<br>第一个人去 A 市，费用为 10。<br>第二个人去 A 市，费用为 30。<br>第三个人去 B 市，费用为 50。<br>第四个人去 B 市，费用为 20。<br><br>最低总费用为 10 + 30 + 50 + 20 = 110，每个城市都有一半的人在面试。<br>提示：<br>1 <= costs.length <= 100<br>costs.length 为偶数<br>1 <= costs[i][0], costs[i][1] <= 1000
***

```python
todo
```
#### 第1046题	**最后一块石头的重量	简单	**
***
有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。<br>提示：<br>1 <= stones.length <= 30<br>1 <= stones[i] <= 1000
***

```python
todo
```
#### 第1053题	**交换一次的先前排列	中等	**
***
给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。<br>如果无法这么操作，就请返回原数组。<br>示例 1：<br>输入：[3,2,1]<br>输出：[3,1,2]<br>解释：<br>交换 2 和 1<br>示例 2：<br>输入：[1,1,5]<br>输出：[1,1,5]<br>解释：<br>这已经是最小排列<br>示例 3：<br>输入：[1,9,4,6,7]<br>输出：[1,7,4,6,9]<br>解释：<br>交换 9 和 7<br>示例 4：<br>输入：[3,1,1,3]<br>输出：[1,3,1,3]<br>解释：<br>交换 1 和 3<br>提示：<br>1 <= A.length <= 10000<br>1 <= A[i] <= 10000
***

```python
todo
```
