# 第6节

#### 第1090题	**受标签影响的最大值	中等	**
***
我们有一个项的集合，其中第 i 项的值为 values[i]，标签为 labels[i]。<br>我们从这些项中选出一个子集 S，这样一来：<br>|S| <= num_wanted<br>对于任意的标签 L，子集 S 中标签为 L 的项的数目总满足 <= use_limit。<br>返回子集 S 的最大可能的 和。<br>示例 1：<br>输入：values = [5,4,3,2,1], labels = [1,1,2,2,3], num_wanted = 3, use_limit = 1<br>输出：9<br>解释：选出的子集是第一项，第三项和第五项。<br>示例 2：<br>输入：values = [5,4,3,2,1], labels = [1,3,3,3,2], num_wanted = 3, use_limit = 2<br>输出：12<br>解释：选出的子集是第一项，第二项和第三项。<br>示例 3：<br>输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 1<br>输出：16<br>解释：选出的子集是第一项和第四项。<br>示例 4：<br>输入：values = [9,8,8,7,6], labels = [0,0,0,1,1], num_wanted = 3, use_limit = 2<br>输出：24<br>解释：选出的子集是第一项，第二项和第四项。<br>提示：<br>1 <= values.length == labels.length <= 20000<br>0 <= values[i], labels[i] <= 20000<br>1 <= num_wanted, use_limit <= values.length
***

```python
todo
```
#### 第1094题	**拼车	中等	**
***
假设你是一位顺风车司机，车上最初有 capacity 个空座位可以用来载客。由于道路的限制，车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向，你可以将其想象为一个向量）。<br>这儿有一份行程计划表 trips[][]，其中 trips[i] = [num_passengers, start_location, end_location] 包含了你的第 i 次行程信息：<br>必须接送的乘客数量；<br>乘客的上车地点；<br>以及乘客的下车地点。<br>这些给出的地点位置是从你的 初始 出发位置向前行驶到这些地点所需的距离（它们一定在你的行驶方向上）。<br>请你根据给出的行程计划表和车子的座位数，来判断你的车是否可以顺利完成接送所用乘客的任务（当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false）。<br>示例 1：<br>输入：trips = [[2,1,5],[3,3,7]], capacity = 4<br>输出：false<br>示例 2：<br>输入：trips = [[2,1,5],[3,3,7]], capacity = 5<br>输出：true<br>示例 3：<br>输入：trips = [[2,1,5],[3,5,7]], capacity = 3<br>输出：true<br>示例 4：<br>输入：trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11<br>输出：true<br>提示：<br>你可以假设乘客会自觉遵守 “先下后上” 的良好素质<br>trips.length <= 1000<br>trips[i].length == 3<br>1 <= trips[i][0] <= 100<br>0 <= trips[i][1] < trips[i][2] <= 1000<br>1 <= capacity <= 100000
***

```python
todo
```
#### 第1111题	**有效括号的嵌套深度	中等	**
***
有效括号字符串 仅由 "(" 和 ")" 构成，并符合下述几个条件之一：<br>空字符串<br>连接，可以记作 AB（A 与 B 连接），其中 A 和 B 都是有效括号字符串<br>嵌套，可以记作 (A)，其中 A 是有效括号字符串<br>类似地，我们可以定义任意有效括号字符串 s 的 嵌套深度 depth(S)：<br>s 为空时，depth("") = 0<br>s 为 A 与 B 连接时，depth(A + B) = max(depth(A), depth(B))，其中 A 和 B 都是有效括号字符串<br>s 为嵌套情况，depth("(" + A + ")") = 1 + depth(A)，其中 A 是有效括号字符串<br>例如：""，"()()"，和 "()(()())" 都是有效括号字符串，嵌套深度分别为 0，1，2，而 ")(" 和 "(()" 都不是有效括号字符串。<br>给你一个有效括号字符串 seq，将其分成两个不相交的子序列 A 和 B，且 A 和 B 满足有效括号字符串的定义（注意：A.length + B.length = seq.length）。<br>现在，你需要从中选出 任意 一组有效括号字符串 A 和 B，使 max(depth(A), depth(B)) 的可能取值最小。<br>返回长度为 seq.length 答案数组 answer ，选择 A 还是 B 的编码规则是：如果 seq[i] 是 A 的一部分，那么 answer[i] = 0。否则，answer[i] = 1。即便有多个满足要求的答案存在，你也只需返回 一个。<br>示例 1：<br>输入：seq = "(()())"<br>输出：[0,1,1,1,1,0]<br>示例 2：<br>输入：seq = "()(())()"<br>输出：[0,0,0,1,1,0,1,1]<br>提示：<br>1 <= text.size <= 10000
***

```python
todo
```
#### 第1217题	**玩筹码	简单	**
***
数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。<br>你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：<br>将第 i 个筹码向左或者右移动 2 个单位，代价为 0。<br>将第 i 个筹码向左或者右移动 1 个单位，代价为 1。<br>最开始的时候，同一位置上也可能放着两个或者更多的筹码。<br>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。<br>示例 1：<br>输入：chips = [1,2,3]<br>输出：1<br>解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。<br>示例 2：<br>输入：chips = [2,2,2,3,3]<br>输出：2<br>解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。<br>提示：<br>1 <= chips.length <= 100<br>1 <= chips[i] <= 10^9
***

```python
todo
```
#### 第1221题	**分割平衡字符串	简单	**
***
在一个「平衡字符串」中，'L' 和 'R' 字符的数量是相同的。<br>给出一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。<br>返回可以通过分割得到的平衡字符串的最大数量。<br>示例 1：<br>输入：s = "RLRRLLRLRL"<br>输出：4<br>解释：s 可以分割为 "RL", "RRLL", "RL", "RL", 每个子字符串中都包含相同数量的 'L' 和 'R'。<br>示例 2：<br>输入：s = "RLLLLRRRLR"<br>输出：3<br>解释：s 可以分割为 "RL", "LLLRRR", "LR", 每个子字符串中都包含相同数量的 'L' 和 'R'。<br>示例 3：<br>输入：s = "LLLLRRRR"<br>输出：1<br>解释：s 只能保持原样 "LLLLRRRR".<br>提示：<br>1 <= s.length <= 1000<br>s[i] = 'L' 或 'R'
***

```python
todo
```
#### 第1247题	**交换字符使得字符串相同	中等	**
***
有两个长度相同的字符串 s1 和 s2，且它们其中 只含有 字符 "x" 和 "y"，你需要通过「交换字符」的方式使这两个字符串相同。<br>每次「交换字符」的时候，你都可以在两个字符串中各选一个字符进行交换。<br>交换只能发生在两个不同的字符串之间，绝对不能发生在同一个字符串内部。也就是说，我们可以交换 s1[i] 和 s2[j]，但不能交换 s1[i] 和 s1[j]。<br>最后，请你返回使 s1 和 s2 相同的最小交换次数，如果没有方法能够使得这两个字符串相同，则返回 -1 。<br>示例 1：<br>输入：s1 = "xx", s2 = "yy"<br>输出：1<br>解释：<br>交换 s1[0] 和 s2[1]，得到 s1 = "yx"，s2 = "yx"。<br>示例 2：<br>输入：s1 = "xy", s2 = "yx"<br>输出：2<br>解释：<br>交换 s1[0] 和 s2[0]，得到 s1 = "yy"，s2 = "xx" 。<br>交换 s1[0] 和 s2[1]，得到 s1 = "xy"，s2 = "xy" 。<br>注意，你不能交换 s1[0] 和 s1[1] 使得 s1 变成 "yx"，因为我们只能交换属于两个不同字符串的字符。<br>示例 3：<br>输入：s1 = "xx", s2 = "xy"<br>输出：-1<br>示例 4：<br>输入：s1 = "xxyyxyxyxx", s2 = "xyyxyxxxyx"<br>输出：4<br>提示：<br>1 <= s1.length, s2.length <= 1000<br>s1, s2 只包含 'x' 或 'y'。
***

```python
todo
```
#### 第1253题	**重构 2 行二进制矩阵	中等	**
***
给你一个 2 行 n 列的二进制数组：<br>矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。<br>第 0 行的元素之和为 upper。<br>第 1 行的元素之和为 lower。<br>第 i 列（从 0 开始编号）的元素之和为 colsum[i]，colsum 是一个长度为 n 的整数数组。<br>你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。<br>如果有多个不同的答案，那么任意一个都可以通过本题。<br>如果不存在符合要求的答案，就请返回一个空的二维数组。<br>示例 1：<br>输入：upper = 2, lower = 1, colsum = [1,1,1]<br>输出：[[1,1,0],[0,0,1]]<br>解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。<br>示例 2：<br>输入：upper = 2, lower = 3, colsum = [2,2,1,1]<br>输出：[]<br>示例 3：<br>输入：upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]<br>输出：[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]<br>提示：<br>1 <= colsum.length <= 10^5<br>0 <= upper, lower <= colsum.length<br>0 <= colsum[i] <= 2
***

```python
todo
```
#### 第1276题	**不浪费原料的汉堡制作方案	中等	**
***
圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。<br>给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：<br>巨无霸汉堡：4 片番茄和 1 片奶酪<br>小皇堡：2 片番茄和 1 片奶酪<br>请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。<br>如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。<br>示例 1：<br>输入：tomatoSlices = 16, cheeseSlices = 7<br>输出：[1,6]<br>解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。<br>示例 2：<br>输入：tomatoSlices = 17, cheeseSlices = 4<br>输出：[]<br>解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。<br>示例 3：<br>输入：tomatoSlices = 4, cheeseSlices = 17<br>输出：[]<br>解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。<br>示例 4：<br>输入：tomatoSlices = 0, cheeseSlices = 0<br>输出：[0,0]<br>示例 5：<br>输入：tomatoSlices = 2, cheeseSlices = 1<br>输出：[0,1]<br>提示：<br>0 <= tomatoSlices <= 10^7<br>0 <= cheeseSlices <= 10^7
***

```python
todo
```
#### 第1282题	**用户分组	中等	**
***
有 n 位用户参加活动，他们的 ID 从 0 到 n - 1，每位用户都 恰好 属于某一用户组。给你一个长度为 n 的数组 groupSizes，其中包含每位用户所处的用户组的大小，请你返回用户分组情况（存在的用户组以及每个组中用户的 ID）。<br>你可以任何顺序返回解决方案，ID 的顺序也不受限制。此外，题目给出的数据保证至少存在一种解决方案。<br>示例 1：<br>输入：groupSizes = [3,3,3,3,3,1,3]<br>输出：[[5],[0,1,2],[3,4,6]]<br>解释：<br>其他可能的解决方案有 [[2,1,6],[5],[0,4,3]] 和 [[5],[0,6,2],[4,3,1]]。<br>示例 2：<br>输入：groupSizes = [2,1,3,3,3,2]<br>输出：[[1],[0,5],[2,3,4]]<br>提示：<br>groupSizes.length == n<br>1 <= n <= 500<br>1 <= groupSizes[i] <= n
***

```python
todo
```
#### 第1296题	**划分数组为连续数字的集合	中等	**
***
给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。<br>如果可以，请返回 True；否则，返回 False。<br>示例 1：<br>输入：nums = [1,2,3,3,4,4,5,6], k = 4<br>输出：true<br>解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。<br>示例 2：<br>输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3<br>输出：true<br>解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。<br>示例 3：<br>输入：nums = [3,3,2,2,1,1], k = 3<br>输出：true<br>示例 4：<br>输入：nums = [1,2,3,4], k = 3<br>输出：false<br>解释：数组不能分成几个大小为 3 的子数组。<br>提示：<br>1 <= nums.length <= 10^5<br>1 <= nums[i] <= 10^9<br>1 <= k <= nums.length
***

```python
todo
```
#### 第1326题	**灌溉花园的最少水龙头数目	困难	**
***
在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。<br>花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。<br>给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i -  ranges[i], i + ranges[i]] 。<br>请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。<br>示例 1：<br>输入：n = 5, ranges = [3,4,1,1,0,0]<br>输出：1<br>解释：<br>点 0 处的水龙头可以灌溉区间 [-3,3]<br>点 1 处的水龙头可以灌溉区间 [-3,5]<br>点 2 处的水龙头可以灌溉区间 [1,3]<br>点 3 处的水龙头可以灌溉区间 [2,4]<br>点 4 处的水龙头可以灌溉区间 [4,4]<br>点 5 处的水龙头可以灌溉区间 [5,5]<br>只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。<br>示例 2：<br>输入：n = 3, ranges = [0,0,0,0]<br>输出：-1<br>解释：即使打开所有水龙头，你也无法灌溉整个花园。<br>示例 3：<br>输入：n = 7, ranges = [1,2,1,0,2,1,0,1]<br>输出：3<br>示例 4：<br>输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]<br>输出：2<br>示例 5：<br>输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]<br>输出：1<br>提示：<br>1 <= n <= 10^4<br>ranges.length == n + 1<br>0 <= ranges[i] <= 100
***

```python
todo
```
