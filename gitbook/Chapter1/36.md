# 第4节

#### 第763题	**划分字母区间	中等	**
***
字符串 S 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一个字母只会出现在其中的一个片段。返回一个表示每个字符串片段的长度的列表。<br>示例 1:<br>输入: S = "ababcbacadefegdehijhklij"<br>输出: [9,7,8]<br>解释:<br>划分结果为 "ababcbaca", "defegde", "hijhklij"。<br>每个字母最多出现在一个片段中。<br>像 "ababcbacadefegde", "hijhklij" 的划分是错误的，因为划分的片段数较少。<br>注意:<br>S的长度在[1, 500]之间。<br>S只包含小写字母'a'到'z'。
***

```python
todo
```
#### 第765题	**情侣牵手	困难	**
***
N 对情侣坐在连续排列的 2N 个座位上，想要牵到对方的手。 计算最少交换座位的次数，以便每对情侣可以并肩坐在一起。 一次交换可选择任意两人，让他们站起来交换座位。<br>人和座位用 0 到 2N-1 的整数表示，情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2N-2, 2N-1)。<br>这些情侣的初始座位  row[i] 是由最初始坐在第 i 个座位上的人决定的。<br>示例 1:<br>输入: row = [0, 2, 1, 3]<br>输出: 1<br>解释: 我们只需要交换row[1]和row[2]的位置即可。<br>示例 2:<br>输入: row = [3, 2, 0, 1]<br>输出: 0<br>解释: 无需交换座位，所有的情侣都已经可以手牵手了。<br>说明:<br>len(row) 是偶数且数值在 [4, 60]范围内。<br>可以保证row 是序列 0...len(row)-1 的一个全排列。
***

```python
todo
```
#### 第767题	**重构字符串	中等	**
***
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。<br>若可行，输出任意可行的结果。若不可行，返回空字符串。<br>示例 1:<br>输入: S = "aab"<br>输出: "aba"<br>示例 2:<br>输入: S = "aaab"<br>输出: ""<br>注意:<br>S 只包含小写字母并且长度在[1, 500]区间内。
***

```python
todo
```
#### 第842题	**将数组拆分成斐波那契序列	中等	**
***
给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。<br>形式上，斐波那契式序列是一个非负整数列表 F，且满足：<br>0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length >= 3；<br>对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。<br>返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 []。<br>示例 1：<br>输入："123456579"<br>输出：[123,456,579]<br>示例 2：<br>输入: "11235813"<br>输出: [1,1,2,3,5,8,13]<br>示例 3：<br>输入: "112358130"<br>输出: []<br>解释: 这项任务无法完成。<br>示例 4：<br>输入："0123"<br>输出：[]<br>解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。<br>示例 5：<br>输入: "1101111"<br>输出: [110, 1, 111]<br>解释: 输出 [11,0,11,11] 也同样被接受。<br>提示：<br>1 <= S.length <= 200<br>字符串 S 中只含有数字。
***

```python
todo
```
#### 第860题	**柠檬水找零	简单	**
***
在柠檬水摊上，每一杯柠檬水的售价为 5 美元。<br>顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。<br>每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。<br>注意，一开始你手头没有任何零钱。<br>如果你能给每位顾客正确找零，返回 true ，否则返回 false 。<br>示例 1：<br>输入：[5,5,5,10,20]<br>输出：true<br>解释：<br>前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。<br>第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。<br>第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。<br>由于所有客户都得到了正确的找零，所以我们输出 true。<br>示例 2：<br>输入：[5,5,10]<br>输出：true<br>示例 3：<br>输入：[10,10]<br>输出：false<br>示例 4：<br>输入：[5,5,10,10,20]<br>输出：false<br>解释：<br>前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。<br>对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。<br>对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。<br>由于不是每位顾客都得到了正确的找零，所以答案是 false。<br>提示：<br>0 <= bills.length <= 10000<br>bills[i] 不是 5 就是 10 或是 20
***

```python
todo
```
#### 第861题	**翻转矩阵后的得分	中等	**
***
有一个二维矩阵 A 其中每个元素的值为 0 或 1 。<br>移动是指选择任一行或列，并转换该行或列中的每一个值：将所有 0 都更改为 1，将所有 1 都更改为 0。<br>在做出任意次数的移动后，将该矩阵的每一行都按照二进制数来解释，矩阵的得分就是这些数字的总和。<br>返回尽可能高的分数。<br>示例：<br>输入：[[0,0,1,1],[1,0,1,0],[1,1,0,0]]<br>输出：39<br>解释：<br>转换为 [[1,1,1,1],[1,0,0,1],[1,1,1,1]]<br>0b1111 + 0b1001 + 0b1111 = 15 + 9 + 15 = 39<br>提示：<br>1 <= A.length <= 20<br>1 <= A[0].length <= 20<br>A[i][j] 是 0 或 1
***

```python
todo
```
#### 第870题	**优势洗牌	中等	**
***
给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] > B[i] 的索引 i 的数目来描述。<br>返回 A 的任意排列，使其相对于 B 的优势最大化。<br>示例 1：<br>输入：A = [2,7,11,15], B = [1,10,4,11]<br>输出：[2,11,7,15]<br>示例 2：<br>输入：A = [12,24,8,32], B = [13,25,32,11]<br>输出：[24,32,8,12]<br>提示：<br>1 <= A.length = B.length <= 10000<br>0 <= A[i] <= 10^9<br>0 <= B[i] <= 10^9
***

```python
todo
```
#### 第874题	**模拟行走机器人	简单	**
***
机器人在一个无限大小的网格上行走，从点 (0, 0) 处开始出发，面向北方。该机器人可以接收以下三种类型的命令：<br>-2：向左转 90 度<br>-1：向右转 90 度<br>1 <= x <= 9：向前移动 x 个单位长度<br>在网格上有一些格子被视为障碍物。<br>第 i 个障碍物位于网格点  (obstacles[i][0], obstacles[i][1])<br>如果机器人试图走到障碍物上方，那么它将停留在障碍物的前一个网格方块上，但仍然可以继续该路线的其余部分。<br>返回从原点到机器人的最大欧式距离的平方。<br>示例 1：<br>输入: commands = [4,-1,3], obstacles = []<br>输出: 25<br>解释: 机器人将会到达 (3, 4)<br>示例 2：<br>输入: commands = [4,-1,4,-2,4], obstacles = [[2,4]]<br>输出: 65<br>解释: 机器人在左转走到 (1, 8) 之前将被困在 (1, 4) 处<br>提示：<br>0 <= commands.length <= 10000<br>0 <= obstacles.length <= 10000<br>-30000 <= obstacle[i][0] <= 30000<br>-30000 <= obstacle[i][1] <= 30000<br>答案保证小于 2 ^ 31
***

```python
todo
```
#### 第881题	**救生艇	中等	**
***
第 i 个人的体重为 people[i]，每艘船可以承载的最大重量为 limit。<br>每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit。<br>返回载到每一个人所需的最小船数。(保证每个人都能被船载)。<br>示例 1：<br>输入：people = [1,2], limit = 3<br>输出：1<br>解释：1 艘船载 (1, 2)<br>示例 2：<br>输入：people = [3,2,2,1], limit = 3<br>输出：3<br>解释：3 艘船分别载 (1, 2), (2) 和 (3)<br>示例 3：<br>输入：people = [3,5,3,4], limit = 5<br>输出：4<br>解释：4 艘船分别载 (3), (3), (4), (5)<br>提示：<br>1 <= people.length <= 50000<br>1 <= people[i] <= limit <= 30000
***

```python
todo
```
#### 第910题	**最小差值 II	中等	**
***
给定一个整数数组 A，对于每个整数 A[i]，我们可以选择 x = -K 或是 x = K，并将 x 加到 A[i] 中。<br>在此过程之后，我们得到一些数组 B。<br>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。<br>示例 1：<br>输入：A = [1], K = 0<br>输出：0<br>解释：B = [1]<br>示例 2：<br>输入：A = [0,10], K = 2<br>输出：6<br>解释：B = [2,8]<br>示例 3：<br>输入：A = [1,3,6], K = 3<br>输出：3<br>解释：B = [4,6,3]<br>提示：<br>1 <= A.length <= 10000<br>0 <= A[i] <= 10000<br>0 <= K <= 10000
***

```python
todo
```
#### 第921题	**使括号有效的最少添加	中等	**
***
给定一个由 '(' 和 ')' 括号组成的字符串 S，我们需要添加最少的括号（ '(' 或是 ')'，可以在任何位置），以使得到的括号字符串有效。<br>从形式上讲，只有满足下面几点之一，括号字符串才是有效的：<br>它是一个空字符串，或者<br>它可以被写成 AB （A 与 B 连接）, 其中 A 和 B 都是有效字符串，或者<br>它可以被写作 (A)，其中 A 是有效字符串。<br>给定一个括号字符串，返回为使结果字符串有效而必须添加的最少括号数。<br>示例 1：<br>输入："())"<br>输出：1<br>示例 2：<br>输入："((("<br>输出：3<br>示例 3：<br>输入："()"<br>输出：0<br>示例 4：<br>输入："()))(("<br>输出：4<br>提示：<br>S.length <= 1000<br>S 只包含 '(' 和 ')' 字符。
***

```python
todo
```
#### 第927题	**三等分	困难	**
***
给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。<br>如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：<br>A[0], A[1], ..., A[i] 组成第一部分；<br>A[i+1], A[i+2], ..., A[j-1] 作为第二部分；<br>A[j], A[j+1], ..., A[A.length - 1] 是第三部分。<br>这三个部分所表示的二进制值相等。<br>如果无法做到，就返回 [-1, -1]。<br>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。<br>示例 1：<br>输入：[1,0,1,0,1]<br>输出：[0,3]<br>示例 2：<br>输出：[1,1,0,1,1]<br>输出：[-1,-1]<br>提示：<br>3 <= A.length <= 30000<br>A[i] == 0 或 A[i] == 1
***

```python
todo
```
