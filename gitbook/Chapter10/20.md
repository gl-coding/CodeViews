# 第3节

#### 第924题	**尽量减少恶意软件的传播	困难	**
***
在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。<br>一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。<br>假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。<br>我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。<br>请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。<br>示例 1：<br>输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]<br>输出：0<br>示例 2：<br>输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]<br>输出：0<br>示例 3：<br>输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]<br>输出：1<br>提示：<br>1 < graph.length = graph[0].length <= 300<br>0 <= graph[i][j] == graph[j][i] <= 1<br>graph[i][i] = 1<br>1 <= initial.length < graph.length<br>0 <= initial[i] < graph.length
***

```python
todo
```
#### 第928题	**尽量减少恶意软件的传播 II	困难	**
***
(这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。)<br>在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。<br>一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。<br>假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。<br>我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。<br>示例 1：<br>输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]<br>输入：0<br>示例 2：<br>输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]<br>输出：1<br>示例 3：<br>输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]<br>输出：1<br>提示：<br>1 < graph.length = graph[0].length <= 300<br>0 <= graph[i][j] == graph[j][i] <= 1<br>graph[i][i] = 1<br>1 <= initial.length < graph.length<br>0 <= initial[i] < graph.length
***

```python
todo
```
#### 第947题	**移除最多的同行或同列石头	中等	**
***
在二维平面上，我们将石头放置在一些整数坐标点上。每个坐标点上最多只能有一块石头。<br><br>现在，move 操作将会移除与网格上的某一块石头共享一列或一行的一块石头。<br><br>我们最多能执行多少次 move 操作？<br>示例 1：<br>输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]<br>输出：5<br>示例 2：<br>输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]<br>输出：3<br>示例 3：<br>输入：stones = [[0,0]]<br>输出：0<br>提示：<br>1 <= stones.length <= 1000<br>0 <= stones[i][j] < 10000
***

```python
todo
```
#### 第952题	**按公因数计算最大组件大小	困难	**
***
给定一个由不同正整数的组成的非空数组 A，考虑下面的图：<br>有 A.length 个节点，按从 A[0] 到 A[A.length - 1] 标记；<br>只有当 A[i] 和 A[j] 共用一个大于 1 的公因数时，A[i] 和 A[j] 之间才有一条边。<br>返回图中最大连通组件的大小。<br>示例 1：<br>输入：[4,6,15,35]<br>输出：4<br>示例 2：<br>输入：[20,50,9,63]<br>输出：2<br>示例 3：<br>输入：[2,3,6,7,4,12,21,39]<br>输出：8<br>提示：<br>1 <= A.length <= 20000<br>1 <= A[i] <= 100000
***

```python
todo
```
#### 第959题	**由斜杠划分区域	中等	**
***
在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。<br>（请注意，反斜杠字符是转义的，因此 \ 用 "\\" 表示。）。<br>返回区域的数目。<br>示例 1：<br>输入：<br>[<br>" /",<br>"/ "<br>]<br>输出：2<br>解释：2x2 网格如下：<br>示例 2：<br>输入：<br>[<br>" /",<br>"  "<br>]<br>输出：1<br>解释：2x2 网格如下：<br>示例 3：<br>输入：<br>[<br>"\\/",<br>"/\\"<br>]<br>输出：4<br>解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）<br>2x2 网格如下：<br>示例 4：<br>输入：<br>[<br>"/\\",<br>"\\/"<br>]<br>输出：5<br>解释：（回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。）<br>2x2 网格如下：<br>示例 5：<br>输入：<br>[<br>"//",<br>"/ "<br>]<br>输出：3<br>解释：2x2 网格如下：<br>提示：<br>1 <= grid.length == grid[0].length <= 30<br>grid[i][j] 是 '/'、'\'、或 ' '。
***

```python
todo
```
#### 第990题	**等式方程的可满足性	中等	**
***
给定一个由表示变量之间关系的字符串方程组成的数组，每个字符串方程 equations[i] 的长度为 4，并采用两种不同的形式之一："a==b" 或 "a!=b"。在这里，a 和 b 是小写字母（不一定不同），表示单字母变量名。<br>只有当可以将整数分配给变量名，以便满足所有给定的方程时才返回 true，否则返回 false。<br>示例 1：<br>输入：["a==b","b!=a"]<br>输出：false<br>解释：如果我们指定，a = 1 且 b = 1，那么可以满足第一个方程，但无法满足第二个方程。没有办法分配变量同时满足这两个方程。<br>示例 2：<br>输出：["b==a","a==b"]<br>输入：true<br>解释：我们可以指定 a = 1 且 b = 1 以满足满足这两个方程。<br>示例 3：<br>输入：["a==b","b==c","a==c"]<br>输出：true<br>示例 4：<br>输入：["a==b","b!=c","c==a"]<br>输出：false<br>示例 5：<br>输入：["c==c","b==d","x!=z"]<br>输出：true<br>提示：<br>1 <= equations.length <= 500<br>equations[i].length == 4<br>equations[i][0] 和 equations[i][3] 是小写字母<br>equations[i][1] 要么是 '='，要么是 '!'<br>equations[i][2] 是 '='
***

```python
todo
```
#### 第1202题	**交换字符串中的元素	中等	**
***
给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。<br>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。<br>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。<br>示例 1:<br>输入：s = "dcab", pairs = [[0,3],[1,2]]<br>输出："bacd"<br>解释：<br>交换 s[0] 和 s[3], s = "bcad"<br>交换 s[1] 和 s[2], s = "bacd"<br>示例 2：<br>输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]<br>输出："abcd"<br>解释：<br>交换 s[0] 和 s[3], s = "bcad"<br>交换 s[0] 和 s[2], s = "acbd"<br>交换 s[1] 和 s[2], s = "abcd"<br>示例 3：<br>输入：s = "cba", pairs = [[0,1],[1,2]]<br>输出："abc"<br>解释：<br>交换 s[0] 和 s[1], s = "bca"<br>交换 s[1] 和 s[2], s = "bac"<br>交换 s[0] 和 s[1], s = "abc"<br>提示：<br>1 <= s.length <= 10^5<br>0 <= pairs.length <= 10^5<br>0 <= pairs[i][0], pairs[i][1] < s.length<br>s 中只含有小写英文字母
***

```python
todo
```
#### 第1319题	**连通网络的操作次数	中等	**
***
用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。<br>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。<br>给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。<br>示例 1：<br>输入：n = 4, connections = [[0,1],[0,2],[1,2]]<br>输出：1<br>解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。<br>示例 2：<br>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]<br>输出：2<br>示例 3：<br>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]<br>输出：-1<br>解释：线缆数量不足。<br>示例 4：<br>输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]<br>输出：0<br>提示：<br>1 <= n <= 10^5<br>1 <= connections.length <= min(n*(n-1)/2, 10^5)<br>connections[i].length == 2<br>0 <= connections[i][0], connections[i][1] < n<br>connections[i][0] != connections[i][1]<br>没有重复的连接。<br>两台计算机不会通过多条线缆连接。
***

```python
todo
```
