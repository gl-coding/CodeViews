# 第13节

#### 第1253题	**重构 2 行二进制矩阵	中等	**
***
给你一个 2 行 n 列的二进制数组：<br>矩阵是一个二进制矩阵，这意味着矩阵中的每个元素不是 0 就是 1。<br>第 0 行的元素之和为 upper。<br>第 1 行的元素之和为 lower。<br>第 i 列（从 0 开始编号）的元素之和为 colsum[i]，colsum 是一个长度为 n 的整数数组。<br>你需要利用 upper，lower 和 colsum 来重构这个矩阵，并以二维整数数组的形式返回它。<br>如果有多个不同的答案，那么任意一个都可以通过本题。<br>如果不存在符合要求的答案，就请返回一个空的二维数组。<br>示例 1：<br>输入：upper = 2, lower = 1, colsum = [1,1,1]<br>输出：[[1,1,0],[0,0,1]]<br>解释：[[1,0,1],[0,1,0]] 和 [[0,1,1],[1,0,0]] 也是正确答案。<br>示例 2：<br>输入：upper = 2, lower = 3, colsum = [2,2,1,1]<br>输出：[]<br>示例 3：<br>输入：upper = 5, lower = 5, colsum = [2,1,2,0,1,0,1,2,0,1]<br>输出：[[1,1,1,0,1,0,0,1,0,0],[1,0,1,0,0,0,1,1,0,1]]<br>提示：<br>1 <= colsum.length <= 10^5<br>0 <= upper, lower <= colsum.length<br>0 <= colsum[i] <= 2
***

```python
todo
```
#### 第1276题	**不浪费原料的汉堡制作方案	中等	**
***
圣诞活动预热开始啦，汉堡店推出了全新的汉堡套餐。为了避免浪费原料，请你帮他们制定合适的制作计划。<br>给你两个整数 tomatoSlices 和 cheeseSlices，分别表示番茄片和奶酪片的数目。不同汉堡的原料搭配如下：<br>巨无霸汉堡：4 片番茄和 1 片奶酪<br>小皇堡：2 片番茄和 1 片奶酪<br>请你以 [total_jumbo, total_small]（[巨无霸汉堡总数，小皇堡总数]）的格式返回恰当的制作方案，使得剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量都是 0。<br>如果无法使剩下的番茄片 tomatoSlices 和奶酪片 cheeseSlices 的数量为 0，就请返回 []。<br>示例 1：<br>输入：tomatoSlices = 16, cheeseSlices = 7<br>输出：[1,6]<br>解释：制作 1 个巨无霸汉堡和 6 个小皇堡需要 4*1 + 2*6 = 16 片番茄和 1 + 6 = 7 片奶酪。不会剩下原料。<br>示例 2：<br>输入：tomatoSlices = 17, cheeseSlices = 4<br>输出：[]<br>解释：只制作小皇堡和巨无霸汉堡无法用光全部原料。<br>示例 3：<br>输入：tomatoSlices = 4, cheeseSlices = 17<br>输出：[]<br>解释：制作 1 个巨无霸汉堡会剩下 16 片奶酪，制作 2 个小皇堡会剩下 15 片奶酪。<br>示例 4：<br>输入：tomatoSlices = 0, cheeseSlices = 0<br>输出：[0,0]<br>示例 5：<br>输入：tomatoSlices = 2, cheeseSlices = 1<br>输出：[0,1]<br>提示：<br>0 <= tomatoSlices <= 10^7<br>0 <= cheeseSlices <= 10^7
***

```python
todo
```
#### 第1281题	**整数的各位积和之差	简单	**
***
给你一个整数 n，请你帮忙计算并返回该整数「各位数字之积」与「各位数字之和」的差。<br>示例 1：<br>输入：n = 234<br>输出：15<br>解释：<br>各位数之积 = 2 * 3 * 4 = 24<br>各位数之和 = 2 + 3 + 4 = 9<br>结果 = 24 - 9 = 15<br>示例 2：<br>输入：n = 4421<br>输出：21<br>解释：<br>各位数之积 = 4 * 4 * 2 * 1 = 32<br>各位数之和 = 4 + 4 + 2 + 1 = 11<br>结果 = 32 - 11 = 21<br>提示：<br>1 <= n <= 10^5
***

```python
todo
```
#### 第1307题	**口算难题	困难	**
***
给你一个方程，左边用 words 表示，右边用 result 表示。<br>你需要根据以下规则检查方程是否可解：<br>每个字符都会被解码成一位数字（0 - 9）。<br>每对不同的字符必须映射到不同的数字。<br>每个 words[i] 和 result 都会被解码成一个没有前导零的数字。<br>左侧数字之和（words）等于右侧数字（result）。<br>如果方程可解，返回 True，否则返回 False。<br>示例 1：<br>输入：words = ["SEND","MORE"], result = "MONEY"<br>输出：true<br>解释：映射 'S'-> 9, 'E'->5, 'N'->6, 'D'->7, 'M'->1, 'O'->0, 'R'->8, 'Y'->'2'<br>所以 "SEND" + "MORE" = "MONEY" ,  9567 + 1085 = 10652<br>示例 2：<br>输入：words = ["SIX","SEVEN","SEVEN"], result = "TWENTY"<br>输出：true<br>解释：映射 'S'-> 6, 'I'->5, 'X'->0, 'E'->8, 'V'->7, 'N'->2, 'T'->1, 'W'->'3', 'Y'->4<br>所以 "SIX" + "SEVEN" + "SEVEN" = "TWENTY" ,  650 + 68782 + 68782 = 138214<br>示例 3：<br>输入：words = ["THIS","IS","TOO"], result = "FUNNY"<br>输出：true<br>示例 4：<br>输入：words = ["LEET","CODE"], result = "POINT"<br>输出：false<br>提示：<br>2 <= words.length <= 5<br>1 <= words[i].length, results.length <= 7<br>words[i], result 只含有大写英文字母<br>表达式中使用的不同字符数最大为 10
***

```python
todo
```
#### 第1317题	**将整数转换为两个无零整数的和	简单	**
***
「无零整数」是十进制表示中 不含任何 0 的正整数。<br>给你一个整数 n，请你返回一个 由两个整数组成的列表 [A, B]，满足：<br>A 和 B 都是无零整数<br>A + B = n<br>题目数据保证至少有一个有效的解决方案。<br>如果存在多个有效解决方案，你可以返回其中任意一个。<br>示例 1：<br>输入：n = 2<br>输出：[1,1]<br>解释：A = 1, B = 1. A + B = n 并且 A 和 B 的十进制表示形式都不包含任何 0 。<br>示例 2：<br>输入：n = 11<br>输出：[2,9]<br>示例 3：<br>输入：n = 10000<br>输出：[1,9999]<br>示例 4：<br>输入：n = 69<br>输出：[1,68]<br>示例 5：<br>输入：n = 1010<br>输出：[11,999]<br>提示：<br>2 <= n <= 10^4
***

```python
todo
```
#### 第5315题	**6 和 9 组成的最大数字	简单	**
***
给你一个仅由数字 6 和 9 组成的正整数 num。<br>你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。<br>请返回你可以得到的最大数字。<br>示例 1：<br>输入：num = 9669<br>输出：9969<br>解释：<br>改变第一位数字可以得到 6669 。<br>改变第二位数字可以得到 9969 。<br>改变第三位数字可以得到 9699 。<br>改变第四位数字可以得到 9666 。<br>其中最大的数字是 9969 。<br>示例 2：<br>输入：num = 9996<br>输出：9999<br>解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。<br>示例 3：<br>输入：num = 9999<br>输出：9999<br>解释：无需改变就已经是最大的数字了。<br>提示：<br>1 <= num <= 10^4<br>num 每一位上的数字都是 6 或者 9 。
***

```python
todo
```
