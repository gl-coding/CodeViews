# 第9节

#### 第877题	**石子游戏	中等	**
***
亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。<br>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。<br>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。<br>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。<br>示例：<br>输入：[5,3,4,5]<br>输出：true<br>解释：<br>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。<br>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。<br>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。<br>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。<br>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。<br>提示：<br>2 <= piles.length <= 500<br>piles.length 是偶数。<br>1 <= piles[i] <= 500<br>sum(piles) 是奇数。
***

```python
todo
```
#### 第878题	**第 N 个神奇数字	困难	**
***
如果正整数可以被 A 或 B 整除，那么它是神奇的。<br>返回第 N 个神奇数字。由于答案可能非常大，返回它模 10^9 + 7 的结果。<br>示例 1：<br>输入：N = 1, A = 2, B = 3<br>输出：2<br>示例 2：<br>输入：N = 4, A = 2, B = 3<br>输出：6<br>示例 3：<br>输入：N = 5, A = 2, B = 4<br>输出：10<br>示例 4：<br>输入：N = 3, A = 6, B = 4<br>输出：8<br>提示：<br>1 <= N <= 10^9<br>2 <= A <= 40000<br>2 <= B <= 40000
***

```python
todo
```
#### 第883题	**三维形体投影面积	简单	**
***
在 N * N 的网格中，我们放置了一些与 x，y，z 三轴对齐的 1 * 1 * 1 立方体。<br>每个值 v = grid[i][j] 表示 v 个正方体叠放在单元格 (i, j) 上。<br>现在，我们查看这些立方体在 xy、yz 和 zx 平面上的投影。<br>投影就像影子，将三维形体映射到一个二维平面上。<br>在这里，从顶部、前面和侧面看立方体时，我们会看到“影子”。<br>返回所有三个投影的总面积。<br>示例 1：<br>输入：[[2]]<br>输出：5<br>示例 2：<br>输入：[[1,2],[3,4]]<br>输出：17<br>解释：<br>这里有该形体在三个轴对齐平面上的三个投影(“阴影部分”)。<br>示例 3：<br>输入：[[1,0],[0,2]]<br>输出：8<br>示例 4：<br>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：14<br>示例 5：<br>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：21<br>提示：<br>1 <= grid.length = grid[0].length <= 50<br>0 <= grid[i][j] <= 50
***

```python
todo
```
#### 第885题	**螺旋矩阵 III	中等	**
***
在 R 行 C 列的矩阵上，我们从 (r0, c0) 面朝东面开始<br>这里，网格的西北角位于第一行第一列，网格的东南角位于最后一行最后一列。<br>现在，我们以顺时针按螺旋状行走，访问此网格中的每个位置。<br>每当我们移动到网格的边界之外时，我们会继续在网格之外行走（但稍后可能会返回到网格边界）。<br>最终，我们到过网格的所有 R * C 个空间。<br>按照访问顺序返回表示网格位置的坐标列表。<br>示例 1：<br>输入：R = 1, C = 4, r0 = 0, c0 = 0<br>输出：[[0,0],[0,1],[0,2],[0,3]]<br>示例 2：<br>输入：R = 5, C = 6, r0 = 1, c0 = 4<br>输出：[[1,4],[1,5],[2,5],[2,4],[2,3],[1,3],[0,3],[0,4],[0,5],[3,5],[3,4],[3,3],[3,2],[2,2],[1,2],[0,2],[4,5],[4,4],[4,3],[4,2],[4,1],[3,1],[2,1],[1,1],[0,1],[4,0],[3,0],[2,0],[1,0],[0,0]]<br>提示：<br>1 <= R <= 100<br>1 <= C <= 100<br>0 <= r0 < R<br>0 <= c0 < C
***

```python
todo
```
#### 第887题	**鸡蛋掉落	困难	**
***
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。<br>你的目标是确切地知道 F 的值是多少。<br>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？<br>示例 1：<br>输入：K = 1, N = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。<br>示例 2：<br>输入：K = 2, N = 6<br>输出：3<br>示例 3：<br>输入：K = 3, N = 14<br>输出：4<br>提示：<br>1 <= K <= 100<br>1 <= N <= 10000
***

```python
todo
```
#### 第891题	**子序列宽度之和	困难	**
***
给定一个整数数组 A ，考虑 A 的所有非空子序列。<br>对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。<br>返回 A 的所有子序列的宽度之和。<br>由于答案可能非常大，请返回答案模 10^9+7。<br>示例：<br>输入：[2,1,3]<br>输出：6<br>解释：<br>子序列为 [1]，[2]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。<br>相应的宽度是 0，0，0，1，1，2，2 。<br>这些宽度之和是 6 。<br>提示：<br>1 <= A.length <= 20000<br>1 <= A[i] <= 20000
***

```python
todo
```
#### 第892题	**三维形体的表面积	简单	**
***
在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。<br>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。<br>请你返回最终形体的表面积。<br>示例 1：<br>输入：[[2]]<br>输出：10<br>示例 2：<br>输入：[[1,2],[3,4]]<br>输出：34<br>示例 3：<br>输入：[[1,0],[0,2]]<br>输出：16<br>示例 4：<br>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32<br>示例 5：<br>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46<br>提示：<br>1 <= N <= 50<br>0 <= grid[i][j] <= 50
***

```python
todo
```
#### 第899题	**有序队列	困难	**
***
给出了一个由小写字母组成的字符串 S。然后，我们可以进行任意次数的移动。<br>在每次移动中，我们选择前 K 个字母中的一个（从左侧开始），将其从原位置移除，并放置在字符串的末尾。<br>返回我们在任意次数的移动之后可以拥有的按字典顺序排列的最小字符串。<br>示例 1：<br>输入：S = "cba", K = 1<br>输出："acb"<br>解释：<br>在第一步中，我们将第一个字符（“c”）移动到最后，获得字符串 “bac”。<br>在第二步中，我们将第一个字符（“b”）移动到最后，获得最终结果 “acb”。<br>示例 2：<br>输入：S = "baaca", K = 3<br>输出："aaabc"<br>解释：<br>在第一步中，我们将第一个字符（“b”）移动到最后，获得字符串 “aacab”。<br>在第二步中，我们将第三个字符（“c”）移动到最后，获得最终结果 “aaabc”。<br>提示：<br>1 <= K <= S.length <= 1000<br>S 只由小写字母组成。
***

```python
todo
```
#### 第902题	**最大为 N 的数字组合	困难	**
***
我们有一组排序的数字 D，它是  {'1','2','3','4','5','6','7','8','9'} 的非空子集。（请注意，'0' 不包括在内。）<br>现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如 D = {'1','3','5'}，我们可以写出像 '13', '551', '1351315' 这样的数字。<br>返回可以用 D 中的数字写出的小于或等于 N 的正整数的数目。<br>示例 1：<br>输入：D = ["1","3","5","7"], N = 100<br>输出：20<br>解释：<br>可写出的 20 个数字是：<br>1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.<br>示例 2：<br>输入：D = ["1","4","9"], N = 1000000000<br>输出：29523<br>解释：<br>我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，<br>81 个四位数字，243 个五位数字，729 个六位数字，<br>2187 个七位数字，6561 个八位数字和 19683 个九位数字。<br>总共，可以使用D中的数字写出 29523 个整数。<br>提示：<br>D 是按排序顺序的数字 '1'-'9' 的子集。<br>1 <= N <= 10^9
***

```python
todo
```
#### 第906题	**超级回文数	困难	**
***
如果一个正整数自身是回文数，而且它也是一个回文数的平方，那么我们称这个数为超级回文数。<br>现在，给定两个正整数 L 和 R （以字符串形式表示），返回包含在范围 [L, R] 中的超级回文数的数目。<br>示例：<br>输入：L = "4", R = "1000"<br>输出：4<br>解释：<br>4，9，121，以及 484 是超级回文数。<br>注意 676 不是一个超级回文数： 26 * 26 = 676，但是 26 不是回文数。<br>提示：<br>1 <= len(L) <= 18<br>1 <= len(R) <= 18<br>L 和 R 是表示 [1, 10^18) 范围的整数的字符串。<br>int(L) <= int(R)
***

```python
todo
```
#### 第908题	**最小差值 I	简单	**
***
给定一个整数数组 A，对于每个整数 A[i]，我们可以选择任意 x 满足 -K <= x <= K，并将 x 加到 A[i] 中。<br>在此过程之后，我们得到一些数组 B。<br>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。<br>示例 1：<br>输入：A = [1], K = 0<br>输出：0<br>解释：B = [1]<br>示例 2：<br>输入：A = [0,10], K = 2<br>输出：6<br>解释：B = [2,8]<br>示例 3：<br>输入：A = [1,3,6], K = 3<br>输出：0<br>解释：B = [3,3,3] 或 B = [4,4,4]<br>提示：<br>1 <= A.length <= 10000<br>0 <= A[i] <= 10000<br>0 <= K <= 10000
***

```python
todo
```
#### 第910题	**最小差值 II	中等	**
***
给定一个整数数组 A，对于每个整数 A[i]，我们可以选择 x = -K 或是 x = K，并将 x 加到 A[i] 中。<br>在此过程之后，我们得到一些数组 B。<br>返回 B 的最大值和 B 的最小值之间可能存在的最小差值。<br>示例 1：<br>输入：A = [1], K = 0<br>输出：0<br>解释：B = [1]<br>示例 2：<br>输入：A = [0,10], K = 2<br>输出：6<br>解释：B = [2,8]<br>示例 3：<br>输入：A = [1,3,6], K = 3<br>输出：3<br>解释：B = [4,6,3]<br>提示：<br>1 <= A.length <= 10000<br>0 <= A[i] <= 10000<br>0 <= K <= 10000
***

```python
todo
```
