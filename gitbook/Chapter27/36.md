# 第4节

#### 第675题	**为高尔夫比赛砍树	困难	**
***
你被请来给一个要举办高尔夫比赛的树林砍树. 树林由一个非负的二维数组表示， 在这个数组中：<br>0 表示障碍，无法触碰到.<br>1 表示可以行走的地面.<br>比1大的数 表示一颗允许走过的树的高度.<br>你被要求按照树的高度从低向高砍掉所有的树，每砍过一颗树，树的高度变为1。<br>你将从（0，0）点开始工作，你应该返回你砍完所有树需要走的最小步数。 如果你无法砍完所有的树，返回 -1 。<br>可以保证的是，没有两棵树的高度是相同的，并且至少有一颗树需要你砍。<br>示例 1:<br>输入:<br>[<br>[1,2,3],<br>[0,0,4],<br>[7,6,5]<br>]<br>输出: 6<br>示例 2:<br>输入:<br>[<br>[1,2,3],<br>[0,0,0],<br>[7,6,5]<br>]<br>输出: -1<br>示例 3:<br>输入:<br>[<br>[2,3,4],<br>[0,0,5],<br>[8,7,6]<br>]<br>输出: 6<br><br>解释: (0,0) 位置的树，你可以直接砍去，不用算步数<br>提示: 矩阵大小不会超过 50x50 。
***

```python
todo
```
#### 第690题	**员工的重要性	简单	**
***
给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。<br>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。<br>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。<br>示例 1:<br>输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>输出: 11<br>解释:<br>员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。<br>注意:<br>一个员工最多有一个直系领导，但是可以有多个直系下属<br>员工数量不超过2000。
***

```python
todo
```
#### 第743题	**网络延迟时间	中等	**
***
有 N 个网络节点，标记为 1 到 N。<br>给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。<br>现在，我们向当前的节点 K 发送了一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。<br>注意:<br>N 的范围在 [1, 100] 之间。<br>K 的范围在 [1, N] 之间。<br>times 的长度在 [1, 6000] 之间。<br>所有的边 times[i] = (u, v, w) 都有 1 <= u, v <= N 且 0 <= w <= 100。
***

```python
todo
```
#### 第752题	**打开转盘锁	中等	**
***
你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为  '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。<br>锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。<br>列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。<br>字符串 target 代表可以解锁的数字，你需要给出最小的旋转次数，如果无论如何不能解锁，返回 -1。<br>示例 1:<br>输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"<br>输出：6<br>解释：<br>可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。<br>注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，<br>因为当拨动到 "0102" 时这个锁就会被锁定。<br>示例 2:<br>输入: deadends = ["8888"], target = "0009"<br>输出：1<br>解释：<br>把最后一位反向旋转一次即可 "0000" -> "0009"。<br>示例 3:<br>输入: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"<br>输出：-1<br>解释：<br>无法旋转到目标数字且不被锁定。<br>示例 4:<br>输入: deadends = ["0000"], target = "8888"<br>输出：-1<br>提示：<br>死亡列表 deadends 的长度范围为 [1, 500]。<br>目标数字 target 不会在 deadends 之中。<br>每个 deadends 和 target 中的字符串的数字会在 10,000 个可能的情况 '0000' 到 '9999' 中产生。
***

```python
todo
```
#### 第773题	**滑动谜题	困难	**
***
在一个 2 x 3 的板上（board）有 5 块砖瓦，用数字 1~5 来表示, 以及一块空缺用 0 来表示.<br>一次移动定义为选择 0 与一个相邻的数字（上下左右）进行交换.<br>最终当板 board 的结果是 [[1,2,3],[4,5,0]] 谜板被解开。<br>给出一个谜板的初始状态，返回最少可以通过多少次移动解开谜板，如果不能解开谜板，则返回 -1 。<br>示例：<br>输入：board = [[1,2,3],[4,0,5]]<br>输出：1<br>解释：交换 0 和 5 ，1 步完成<br>输入：board = [[1,2,3],[5,4,0]]<br>输出：-1<br>解释：没有办法完成谜板<br>输入：board = [[4,1,2],[5,0,3]]<br>输出：5<br>解释：<br>最少完成谜板的最少移动次数是 5 ，<br>一种移动路径:<br>尚未移动: [[4,1,2],[5,0,3]]<br>移动 1 次: [[4,1,2],[0,5,3]]<br>移动 2 次: [[0,1,2],[4,5,3]]<br>移动 3 次: [[1,0,2],[4,5,3]]<br>移动 4 次: [[1,2,0],[4,5,3]]<br>移动 5 次: [[1,2,3],[4,5,0]]<br>输入：board = [[3,2,4],[1,5,0]]<br>输出：14<br>提示：<br>board 是一个如上所述的 2 x 3 的数组.<br>board[i][j] 是一个 [0, 1, 2, 3, 4, 5] 的排列.
***

```python
todo
```
#### 第785题	**判断二分图	中等	**
***
给定一个无向图graph，当这个图为二分图时返回true。<br>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。<br>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。<br>示例 1:<br>输入: [[1,3], [0,2], [1,3], [0,2]]<br>输出: true<br>解释:<br>无向图如下:<br>0----1<br>|    |<br>|    |<br>3----2<br>我们可以将节点分成两组: {0, 2} 和 {1, 3}。<br>示例 2:<br>输入: [[1,2,3], [0,2], [0,1,3], [0,2]]<br>输出: false<br>解释:<br>无向图如下:<br>0----1<br>| \  |<br>|  \ |<br>3----2<br>我们不能将节点分割成两个独立的子集。<br>注意:<br>graph 的长度范围为 [1, 100]。<br>graph[i] 中的元素的范围为 [0, graph.length - 1]。<br>graph[i] 不会包含 i 或者有重复的值。<br>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。
***

```python
todo
```
#### 第787题	**K 站中转内最便宜的航班	中等	**
***
有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。<br>现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。<br>示例 1:<br>输入:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 1<br>输出: 200<br>解释:<br>城市航班图如下<br><br><br>从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。<br>示例 2:<br>输入:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 0<br>输出: 500<br>解释:<br>城市航班图如下<br><br><br>从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。<br>提示：<br>n 范围是 [1, 100]，城市标签从 0 到 n - 1.<br>航班数量范围是 [0, n * (n - 1) / 2].<br>每个航班的格式 (src, dst, price).<br>每个航班的价格范围是 [1, 10000].<br>k 范围是 [0, n - 1].<br>航班没有重复，且不存在环路
***

```python
todo
```
#### 第815题	**公交路线	困难	**
***
我们有一系列公交路线。每一条路线 routes[i] 上都有一辆公交车在上面循环行驶。例如，有一条路线 routes[0] = [1, 5, 7]，表示第一辆 (下标为0) 公交车会一直按照 1->5->7->1->5->7->1->... 的车站路线行驶。<br>假设我们从 S 车站开始（初始时不在公交车上），要去往 T 站。 期间仅可乘坐公交车，求出最少乘坐的公交车数量。返回 -1 表示不可能到达终点车站。<br>示例:<br>输入:<br>routes = [[1, 2, 7], [3, 6, 7]]<br>S = 1<br>T = 6<br>输出: 2<br>解释:<br>最优策略是先乘坐第一辆公交车到达车站 7, 然后换乘第二辆公交车到车站 6。<br>说明:<br>1 <= routes.length <= 500.<br>1 <= routes[i].length <= 500.<br>0 <= routes[i][j] < 10 ^ 6.
***

```python
todo
```
#### 第847题	**访问所有节点的最短路径	困难	**
***
给出 graph 为有 N 个节点（编号为 0, 1, 2, ..., N-1）的无向连通图。<br>graph.length = N，且只有节点 i 和 j 连通时，j != i 在列表 graph[i] 中恰好出现一次。<br>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。<br>示例 1：<br>输入：[[1,2,3],[0],[0],[0]]<br>输出：4<br>解释：一个可能的路径为 [1,0,2,0,3]<br>示例 2：<br>输入：[[1],[0,2,4],[1,3,4],[2],[1,2]]<br>输出：4<br>解释：一个可能的路径为 [0,1,4,2,3]<br>提示：<br>1 <= graph.length <= 12<br>0 <= graph[i].length < graph.length
***

```python
todo
```
#### 第854题	**相似度为 K 的字符串	困难	**
***
如果可以通过将 A 中的两个小写字母精确地交换位置 K 次得到与 B 相等的字符串，我们称字符串 A 和 B 的相似度为 K（K 为非负整数）。<br>给定两个字母异位词 A 和 B ，返回 A 和 B 的相似度 K 的最小值。<br>示例 1：<br>输入：A = "ab", B = "ba"<br>输出：1<br>示例 2：<br>输入：A = "abc", B = "bca"<br>输出：2<br>示例 3：<br>输入：A = "abac", B = "baca"<br>输出：2<br>示例 4：<br>输入：A = "aabc", B = "abca"<br>输出：2<br>提示：<br>1 <= A.length == B.length <= 20<br>A 和 B 只包含集合 {'a', 'b', 'c', 'd', 'e', 'f'} 中的小写字母。
***

```python
todo
```
#### 第863题	**二叉树中所有距离为 K 的结点	中等	**
***
给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。<br>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。<br>示例 1：<br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2<br><br>输出：[7,4,1]<br><br>解释：<br>所求结点为与目标结点（值为 5）距离为 2 的结点，<br>值分别为 7，4，以及 1<br><br><br><br>注意，输入的 "root" 和 "target" 实际上是树上的结点。<br>上面的输入仅仅是对这些对象进行了序列化描述。<br>提示：<br>给定的树是非空的，且最多有 K 个结点。<br>树上的每个结点都具有唯一的值 0 <= node.val <= 500 。<br>目标结点 target 是树上的结点。<br>0 <= K <= 1000.
***

```python
todo
```
#### 第864题	**获取所有钥匙的最短路径	困难	**
***
给定一个二维网格 grid。 "." 代表一个空房间， "#" 代表一堵墙， "@" 是起点，（"a", "b", ...）代表钥匙，（"A", "B", ...）代表锁。<br>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。<br>假设 K 为钥匙/锁的个数，且满足 1 <= K <= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。<br>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。<br>示例 1：<br>输入：["@.a.#","###.#","b.A.B"]<br>输出：8<br>示例 2：<br>输入：["@..aA","..B#.","....b"]<br>输出：6<br>提示：<br>1 <= grid.length <= 30<br>1 <= grid[0].length <= 30<br>grid[i][j] 只含有 '.', '#', '@', 'a'-'f' 以及 'A'-'F'<br>钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。
***

```python
todo
```
