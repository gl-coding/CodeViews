# 第5节

#### 第909题	**蛇梯棋	中等	**
***
在一块 N x N 的棋盘 board 上，从棋盘的左下角开始，每一行交替方向，按从 1 到 N*N 的数字给方格编号。例如，对于一块 6 x 6 大小的棋盘，可以编号如下：<br>玩家从棋盘上的方格 1 （总是在最后一行、第一列）开始出发。<br>每一次从方格 x 起始的移动都由以下部分组成：<br>你选择一个目标方块 S，它的编号是 x+1，x+2，x+3，x+4，x+5，或者 x+6，只要这个数字 <= N*N。<br>如果 S 有一个蛇或梯子，你就移动到那个蛇或梯子的目的地。否则，你会移动到 S。<br>在 r 行 c 列上的方格里有 “蛇” 或 “梯子”；如果 board[r][c] != -1，那个蛇或梯子的目的地将会是 board[r][c]。<br>注意，你每次移动最多只能爬过蛇或梯子一次：就算目的地是另一条蛇或梯子的起点，你也不会继续移动。<br>返回达到方格 N*N 所需的最少移动次数，如果不可能，则返回 -1。<br>示例：<br>输入：[<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,35,-1,-1,13,-1],<br>[-1,-1,-1,-1,-1,-1],<br>[-1,15,-1,-1,-1,-1]]<br>输出：4<br>解释：<br>首先，从方格 1 [第 5 行，第 0 列] 开始。<br>你决定移动到方格 2，并必须爬过梯子移动到到方格 15。<br>然后你决定移动到方格 17 [第 3 行，第 5 列]，必须爬过蛇到方格 13。<br>然后你决定移动到方格 14，且必须通过梯子移动到方格 35。<br>然后你决定移动到方格 36, 游戏结束。<br>可以证明你需要至少 4 次移动才能到达第 N*N 个方格，所以答案是 4。<br>提示：<br>2 <= board.length = board[0].length <= 20<br>board[i][j] 介于 1 和 N*N 之间或者等于 -1。<br>编号为 1 的方格上没有蛇或梯子。<br>编号为 N*N 的方格上没有蛇或梯子。
***

```python
todo
```
#### 第913题	**猫和老鼠	困难	**
***
两个玩家分别扮演猫（Cat）和老鼠（Mouse）在无向图上进行游戏，他们轮流行动。<br>该图按下述规则给出：graph[a] 是所有结点 b 的列表，使得 ab 是图的一条边。<br>老鼠从结点 1 开始并率先出发，猫从结点 2 开始且随后出发，在结点 0 处有一个洞。<br>在每个玩家的回合中，他们必须沿着与他们所在位置相吻合的图的一条边移动。例如，如果老鼠位于结点 1，那么它只能移动到 graph[1] 中的（任何）结点去。<br>此外，猫无法移动到洞（结点 0）里。<br>然后，游戏在出现以下三种情形之一时结束：<br>如果猫和老鼠占据相同的结点，猫获胜。<br>如果老鼠躲入洞里，老鼠获胜。<br>如果某一位置重复出现（即，玩家们的位置和移动顺序都与上一个回合相同），游戏平局。<br>给定 graph，并假设两个玩家都以最佳状态参与游戏，如果老鼠获胜，则返回 1；如果猫获胜，则返回 2；如果平局，则返回 0。<br>示例：<br>输入：[[2,5],[3],[0,4,5],[1,4,5],[2,3],[0,2,3]]<br>输出：0<br>解释：<br>4---3---1<br>|   |<br>2---5<br>\ /<br>0<br>提示：<br>3 <= graph.length <= 200<br>保证 graph[1] 非空。<br>保证 graph[2] 包含非零元素。
***

```python
todo
```
#### 第934题	**最短的桥	中等	**
***
在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）<br>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。<br>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）<br>示例 1：<br>输入：[[0,1],[1,0]]<br>输出：1<br>示例 2：<br>输入：[[0,1,0],[0,0,0],[0,0,1]]<br>输出：2<br>示例 3：<br>输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1<br>提示：<br>1 <= A.length = A[0].length <= 100<br>A[i][j] == 0 或 A[i][j] == 1
***

```python
todo
```
#### 第993题	**二叉树的堂兄弟节点	简单	**
***
在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。<br>如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。<br>我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。<br>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。<br>示例 1：<br>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false<br>示例 2：<br>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4<br>输出：true<br>示例 3：<br>输入：root = [1,2,3,null,4], x = 2, y = 3<br>输出：false<br>提示：<br>二叉树的节点数介于 2 到 100 之间。<br>每个节点的值都是唯一的、范围为 1 到 100 的整数。
***

```python
todo
```
#### 第994题	**腐烂的橘子	简单	**
***
在给定的网格中，每个单元格可以有以下三个值之一：<br>值 0 代表空单元格；<br>值 1 代表新鲜橘子；<br>值 2 代表腐烂的橘子。<br>每分钟，任何与腐烂的橘子（在 4 个正方向上）相邻的新鲜橘子都会腐烂。<br>返回直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 -1。<br>示例 1：<br>输入：[[2,1,1],[1,1,0],[0,1,1]]<br>输出：4<br>示例 2：<br>输入：[[2,1,1],[0,1,1],[1,0,1]]<br>输出：-1<br>解释：左下角的橘子（第 2 行， 第 0 列）永远不会腐烂，因为腐烂只会发生在 4 个正向上。<br>示例 3：<br>输入：[[0,2]]<br>输出：0<br>解释：因为 0 分钟时已经没有新鲜橘子了，所以答案就是 0 。<br>提示：<br>1 <= grid.length <= 10<br>1 <= grid[0].length <= 10<br>grid[i][j] 仅为 0、1 或 2
***

```python
todo
```
#### 第1036题	**逃离大迷宫	困难	**
***
在一个 10^6 x 10^6 的网格中，每个网格块的坐标为 (x, y)，其中 0 <= x, y < 10^6。<br>我们从源方格 source 开始出发，意图赶往目标方格 target。每次移动，我们都可以走到网格中在四个方向上相邻的方格，只要该方格不在给出的封锁列表 blocked 上。<br>只有在可以通过一系列的移动到达目标方格时才返回 true。否则，返回 false。<br>示例 1：<br>输入：blocked = [[0,1],[1,0]], source = [0,0], target = [0,2]<br>输出：false<br>解释：<br>从源方格无法到达目标方格，因为我们无法在网格中移动。<br>示例 2：<br>输入：blocked = [], source = [0,0], target = [999999,999999]<br>输出：true<br>解释：<br>因为没有方格被封锁，所以一定可以到达目标方格。<br>提示：<br>0 <= blocked.length <= 200<br>blocked[i].length == 2<br>0 <= blocked[i][j] < 10^6<br>source.length == target.length == 2<br>0 <= source[i][j], target[i][j] < 10^6<br>source != target
***

```python
todo
```
#### 第1091题	**二进制矩阵中的最短路径	中等	**
***
在一个 N × N 的方形网格中，每个单元格有两种状态：空（0）或者阻塞（1）。<br>一条从左上角到右下角、长度为 k 的畅通路径，由满足下述条件的单元格 C_1, C_2, ..., C_k 组成：<br>相邻单元格 C_i 和 C_{i+1} 在八个方向之一上连通（此时，C_i 和 C_{i+1} 不同且共享边或角）<br>C_1 位于 (0, 0)（即，值为 grid[0][0]）<br>C_k 位于 (N-1, N-1)（即，值为 grid[N-1][N-1]）<br>如果 C_i 位于 (r, c)，则 grid[r][c] 为空（即，grid[r][c] == 0）<br>返回这条从左上角到右下角的最短畅通路径的长度。如果不存在这样的路径，返回 -1 。<br>示例 1：<br>输入：[[0,1],[1,0]]<br><br>输出：2<br>示例 2：<br>输入：[[0,0,0],[1,1,0],[1,1,0]]<br><br>输出：4<br>提示：<br>1 <= grid.length == grid[0].length <= 100<br>grid[i][j] 为 0 或 1
***

```python
todo
```
#### 第1129题	**颜色交替的最短路径	中等	**
***
在一个有向图中，节点分别标记为 0, 1, ..., n-1。这个图中的每条边不是红色就是蓝色，且存在自环或平行边。<br>red_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的红色有向边。类似地，blue_edges 中的每一个 [i, j] 对表示从节点 i 到节点 j 的蓝色有向边。<br>返回长度为 n 的数组 answer，其中 answer[X] 是从节点 0 到节点 X 的最短路径的长度，且路径上红色边和蓝色边交替出现。如果不存在这样的路径，那么 answer[x] = -1。<br>示例 1：<br>输入：n = 3, red_edges = [[0,1],[1,2]], blue_edges = []<br>输出：[0,1,-1]<br>示例 2：<br>输入：n = 3, red_edges = [[0,1]], blue_edges = [[2,1]]<br>输出：[0,1,-1]<br>示例 3：<br>输入：n = 3, red_edges = [[1,0]], blue_edges = [[2,1]]<br>输出：[0,-1,-1]<br>示例 4：<br>输入：n = 3, red_edges = [[0,1]], blue_edges = [[1,2]]<br>输出：[0,1,2]<br>示例 5：<br>输入：n = 3, red_edges = [[0,1],[0,2]], blue_edges = [[1,0]]<br>输出：[0,1,1]<br>提示：<br>1 <= n <= 100<br>red_edges.length <= 400<br>blue_edges.length <= 400<br>red_edges[i].length == blue_edges[i].length == 2<br>0 <= red_edges[i][j], blue_edges[i][j] < n
***

```python
todo
```
#### 第1162题	**地图分析	中等	**
***
你现在手里有一份大小为 N x N 的『地图』（网格） grid，上面的每个『区域』（单元格）都用 0 和 1 标记好了。其中 0 代表海洋，1 代表陆地，你知道距离陆地区域最远的海洋区域是是哪一个吗？请返回该海洋区域到离它最近的陆地区域的距离。<br>我们这里说的距离是『曼哈顿距离』（ Manhattan Distance）：(x0, y0) 和 (x1, y1) 这两个区域之间的距离是 |x0 - x1| + |y0 - y1| 。<br>如果我们的地图上只有陆地或者海洋，请返回 -1。<br>示例 1：<br>输入：[[1,0,1],[0,0,0],[1,0,1]]<br>输出：2<br>解释：<br>海洋区域 (1, 1) 和所有陆地区域之间的距离都达到最大，最大距离为 2。<br>示例 2：<br>输入：[[1,0,0],[0,0,0],[0,0,0]]<br>输出：4<br>解释：<br>海洋区域 (2, 2) 和所有陆地区域之间的距离都达到最大，最大距离为 4。<br>提示：<br>1 <= grid.length == grid[0].length <= 100<br>grid[i][j] 不是 0 就是 1
***

```python
todo
```
#### 第1210题	**穿过迷宫的最少移动次数	困难	**
***
你还记得那条风靡全球的贪吃蛇吗？<br>我们在一个 n*n 的网格上构建了新的迷宫地图，蛇的长度为 2，也就是说它会占去两个单元格。蛇会从左上角（(0, 0) 和 (0, 1)）开始移动。我们用 0 表示空单元格，用 1 表示障碍物。蛇需要移动到迷宫的右下角（(n-1, n-2) 和 (n-1, n-1)）。<br>每次移动，蛇可以这样走：<br>如果没有障碍，则向右移动一个单元格。并仍然保持身体的水平／竖直状态。<br>如果没有障碍，则向下移动一个单元格。并仍然保持身体的水平／竖直状态。<br>如果它处于水平状态并且其下面的两个单元都是空的，就顺时针旋转 90 度。蛇从（(r, c)、(r, c+1)）移动到 （(r, c)、(r+1, c)）。<br>如果它处于竖直状态并且其右面的两个单元都是空的，就逆时针旋转 90 度。蛇从（(r, c)、(r+1, c)）移动到（(r, c)、(r, c+1)）。<br>返回蛇抵达目的地所需的最少移动次数。<br>如果无法到达目的地，请返回 -1。<br>示例 1：<br>输入：grid = [[0,0,0,0,0,1],<br>[1,1,0,0,1,0],<br>[0,0,0,0,1,1],<br>[0,0,1,0,1,0],<br>[0,1,1,0,0,0],<br>[0,1,1,0,0,0]]<br>输出：11<br>解释：<br>一种可能的解决方案是 [右, 右, 顺时针旋转, 右, 下, 下, 下, 下, 逆时针旋转, 右, 下]。<br>示例 2：<br>输入：grid = [[0,0,1,1,1,1],<br>[0,0,0,0,1,1],<br>[1,1,0,0,0,1],<br>[1,1,1,0,0,1],<br>[1,1,1,0,0,1],<br>[1,1,1,0,0,0]]<br>输出：9<br>提示：<br>2 <= n <= 100<br>0 <= grid[i][j] <= 1<br>蛇保证从空单元格开始出发。
***

```python
todo
```
#### 第1263题	**推箱子	困难	**
***
「推箱子」是一款风靡全球的益智小游戏，玩家需要将箱子推到仓库中的目标位置。<br>游戏地图用大小为 n * m 的网格 grid 表示，其中每个元素可以是墙、地板或者是箱子。<br>现在你将作为玩家参与游戏，按规则将箱子 'B' 移动到目标位置 'T' ：<br>玩家用字符 'S' 表示，只要他在地板上，就可以在网格中向上、下、左、右四个方向移动。<br>地板用字符 '.' 表示，意味着可以自由行走。<br>墙用字符 '#' 表示，意味着障碍物，不能通行。<br>箱子仅有一个，用字符 'B' 表示。相应地，网格上有一个目标位置 'T'。<br>玩家需要站在箱子旁边，然后沿着箱子的方向进行移动，此时箱子会被移动到相邻的地板单元格。记作一次「推动」。<br>玩家无法越过箱子。<br>返回将箱子推到目标位置的最小 推动 次数，如果无法做到，请返回 -1。<br>示例 1：<br>输入：grid = [["#","#","#","#","#","#"],<br>["#","T","#","#","#","#"],<br>["#",".",".","B",".","#"],<br>["#",".","#","#",".","#"],<br>["#",".",".",".","S","#"],<br>["#","#","#","#","#","#"]]<br>输出：3<br>解释：我们只需要返回推箱子的次数。<br>示例 2：<br>输入：grid = [["#","#","#","#","#","#"],<br>["#","T","#","#","#","#"],<br>["#",".",".","B",".","#"],<br>["#","#","#","#",".","#"],<br>["#",".",".",".","S","#"],<br>["#","#","#","#","#","#"]]<br>输出：-1<br>示例 3：<br>输入：grid = [["#","#","#","#","#","#"],<br>["#","T",".",".","#","#"],<br>["#",".","#","B",".","#"],<br>["#",".",".",".",".","#"],<br>["#",".",".",".","S","#"],<br>["#","#","#","#","#","#"]]<br>输出：5<br>解释：向下、向左、向左、向上再向上。<br>示例 4：<br>输入：grid = [["#","#","#","#","#","#","#"],<br>["#","S","#",".","B","T","#"],<br>["#","#","#","#","#","#","#"]]<br>输出：-1<br>提示：<br>1 <= grid.length <= 20<br>1 <= grid[i].length <= 20<br>grid 仅包含字符 '.', '#',  'S' , 'T', 以及 'B'。<br>grid 中 'S', 'B' 和 'T' 各只能出现一个。
***

```python
todo
```
#### 第1284题	**转化为全零矩阵的最少反转次数	困难	**
***
给你一个 m x n 的二进制矩阵 mat。<br>每一步，你可以选择一个单元格并将它反转（反转表示 0 变 1 ，1 变 0 ）。如果存在和它相邻的单元格，那么这些相邻的单元格也会被反转。（注：相邻的两个单元格共享同一条边。）<br>请你返回将矩阵 mat 转化为全零矩阵的最少反转次数，如果无法转化为全零矩阵，请返回 -1 。<br>二进制矩阵的每一个格子要么是 0 要么是 1 。<br>全零矩阵是所有格子都为 0 的矩阵。<br>示例 1：<br>输入：mat = [[0,0],[0,1]]<br>输出：3<br>解释：一个可能的解是反转 (1, 0)，然后 (0, 1) ，最后是 (1, 1) 。<br>示例 2：<br>输入：mat = [[0]]<br>输出：0<br>解释：给出的矩阵是全零矩阵，所以你不需要改变它。<br>示例 3：<br>输入：mat = [[1,1,1],[1,0,1],[0,0,0]]<br>输出：6<br>示例 4：<br>输入：mat = [[1,0,0],[1,0,0]]<br>输出：-1<br>解释：该矩阵无法转变成全零矩阵<br>提示：<br>m == mat.length<br>n == mat[0].length<br>1 <= m <= 3<br>1 <= n <= 3<br>mat[i][j] 是 0 或 1 。
***

```python
todo
```
