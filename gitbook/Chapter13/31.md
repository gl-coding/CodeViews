# 第4节

#### 第857题	**雇佣 K 名工人的最低成本	困难	**
***
有 N 名工人。 第 i 名工人的工作质量为 quality[i] ，其最低期望工资为 wage[i] 。<br>现在我们想雇佣 K 名工人组成一个工资组。在雇佣 一组 K 名工人时，我们必须按照下述规则向他们支付工资：<br>对工资组中的每名工人，应当按其工作质量与同组其他工人的工作质量的比例来支付工资。<br>工资组中的每名工人至少应当得到他们的最低期望工资。<br>返回组成一个满足上述条件的工资组至少需要多少钱。<br>示例 1：<br>输入： quality = [10,20,5], wage = [70,50,30], K = 2<br>输出： 105.00000<br>解释： 我们向 0 号工人支付 70，向 2 号工人支付 35。<br>示例 2：<br>输入： quality = [3,1,10,10,1], wage = [4,8,2,2,7], K = 3<br>输出： 30.66667<br>解释： 我们向 0 号工人支付 4，向 2 号和 3 号分别支付 13.33333。<br>提示：<br>1 <= K <= N <= 10000，其中 N = quality.length = wage.length<br>1 <= quality[i] <= 10000<br>1 <= wage[i] <= 10000<br>与正确答案误差在 10^-5 之内的答案将被视为正确的。
***

```python
todo
```
#### 第864题	**获取所有钥匙的最短路径	困难	**
***
给定一个二维网格 grid。 "." 代表一个空房间， "#" 代表一堵墙， "@" 是起点，（"a", "b", ...）代表钥匙，（"A", "B", ...）代表锁。<br>我们从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间。我们不能在网格外面行走，也无法穿过一堵墙。如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。<br>假设 K 为钥匙/锁的个数，且满足 1 <= K <= 6，字母表中的前 K 个字母在网格中都有自己对应的一个小写和一个大写字母。换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁。另外，代表钥匙和锁的字母互为大小写并按字母顺序排列。<br>返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。<br>示例 1：<br>输入：["@.a.#","###.#","b.A.B"]<br>输出：8<br>示例 2：<br>输入：["@..aA","..B#.","....b"]<br>输出：6<br>提示：<br>1 <= grid.length <= 30<br>1 <= grid[0].length <= 30<br>grid[i][j] 只含有 '.', '#', '@', 'a'-'f' 以及 'A'-'F'<br>钥匙的数目范围是 [1, 6]，每个钥匙都对应一个不同的字母，正好打开一个对应的锁。
***

```python
todo
```
#### 第871题	**最低加油次数	困难	**
***
汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。<br>沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。<br>假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。<br>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。<br>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。<br>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。<br>示例 1：<br>输入：target = 1, startFuel = 1, stations = []<br>输出：0<br>解释：我们可以在不加油的情况下到达目的地。<br>示例 2：<br>输入：target = 100, startFuel = 1, stations = [[10,100]]<br>输出：-1<br>解释：我们无法抵达目的地，甚至无法到达第一个加油站。<br>示例 3：<br>输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]<br>输出：2<br>解释：<br>我们出发时有 10 升燃料。<br>我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。<br>然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），<br>并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。<br>我们沿途在1两个加油站停靠，所以返回 2 。<br>提示：<br>1 <= target, startFuel, stations[i][1] <= 10^9<br>0 <= stations.length <= 500<br>0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target
***

```python
todo
```
#### 第882题	**细分图中的可到达结点	困难	**
***
从具有 0 到 N-1 的结点的无向图（“原始图”）开始，对一些边进行细分。<br>该图给出如下：edges[k] 是整数对 (i, j, n) 组成的列表，使 (i, j) 是原始图的边。<br>n 是该边上新结点的总数<br>然后，将边 (i, j) 从原始图中删除，将 n 个新结点 (x_1, x_2, ..., x_n) 添加到原始图中，<br>将 n+1 条新边 (i, x_1), (x_1, x_2), (x_2, x_3), ..., (x_{n-1}, x_n), (x_n, j) 添加到原始图中。<br>现在，你将从原始图中的结点 0 处出发，并且每次移动，你都将沿着一条边行进。<br>返回最多 M 次移动可以达到的结点数。<br>示例 1：<br>输入：edges = [[0,1,10],[0,2,1],[1,2,2]], M = 6, N = 3<br>输出：13<br>解释：<br>在 M = 6 次移动之后在最终图中可到达的结点如下所示。<br>示例 2：<br>输入：edges = [[0,1,4],[1,2,6],[0,2,8],[1,3,1]], M = 10, N = 4<br>输出：23<br>提示：<br>0 <= edges.length <= 10000<br>0 <= edges[i][0] < edges[i][1] < N<br>不存在任何 i != j 情况下 edges[i][0] == edges[j][0] 且 edges[i][1] == edges[j][1].<br>原始图没有平行的边。<br>0 <= edges[i][2] <= 10000<br>0 <= M <= 10^9<br>1 <= N <= 3000<br>可到达结点是可以从结点 0 开始使用最多 M 次移动到达的结点。
***

```python
todo
```
#### 第973题	**最接近原点的 K 个点	中等	**
***
我们有一个由平面上的点组成的列表 points。需要从中找出 K 个距离原点 (0, 0) 最近的点。<br>（这里，平面上两点之间的距离是欧几里德距离。）<br>你可以按任何顺序返回答案。除了点坐标的顺序之外，答案确保是唯一的。<br>示例 1：<br>输入：points = [[1,3],[-2,2]], K = 1<br>输出：[[-2,2]]<br>解释：<br>(1, 3) 和原点之间的距离为 sqrt(10)，<br>(-2, 2) 和原点之间的距离为 sqrt(8)，<br>由于 sqrt(8) < sqrt(10)，(-2, 2) 离原点更近。<br>我们只需要距离原点最近的 K = 1 个点，所以答案就是 [[-2,2]]。<br>示例 2：<br>输入：points = [[3,3],[5,-1],[-2,4]], K = 2<br>输出：[[3,3],[-2,4]]<br>（答案 [[-2,4],[3,3]] 也会被接受。）<br>提示：<br>1 <= K <= points.length <= 10000<br>-10000 < points[i][0] < 10000<br>-10000 < points[i][1] < 10000
***

```python
todo
```
#### 第1046题	**最后一块石头的重量	简单	**
***
有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出两块最重的石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 0。<br>提示：<br>1 <= stones.length <= 30<br>1 <= stones[i] <= 1000
***

```python
todo
```
#### 第1054题	**距离相等的条形码	中等	**
***
在一个仓库里，有一排条形码，其中第 i 个条形码为 barcodes[i]。<br>请你重新排列这些条形码，使其中两个相邻的条形码 不能 相等。 你可以返回任何满足该要求的答案，此题保证存在答案。<br>示例 1：<br>输入：[1,1,1,2,2,2]<br>输出：[2,1,2,1,2,1]<br>示例 2：<br>输入：[1,1,1,1,2,2,3,3]<br>输出：[1,3,1,3,2,1,2,1]<br>提示：<br>1 <= barcodes.length <= 10000<br>1 <= barcodes[i] <= 10000
***

```python
todo
```
