# 第3节

#### 第451题	**根据字符出现频率排序	中等	**
***
给定一个字符串，请将字符串里的字符按照出现的频率降序排列。<br>示例 1:<br>输入:<br>"tree"<br><br>输出:<br>"eert"<br><br>解释:<br>'e'出现两次，'r'和't'都只出现一次。<br>因此'e'必须出现在'r'和't'之前。此外，"eetr"也是一个有效的答案。<br>示例 2:<br>输入:<br>"cccaaa"<br><br>输出:<br>"cccaaa"<br><br>解释:<br>'c'和'a'都出现三次。此外，"aaaccc"也是有效的答案。<br>注意"cacaca"是不正确的，因为相同的字母必须放在一起。<br>示例 3:<br>输入:<br>"Aabb"<br><br>输出:<br>"bbAa"<br><br>解释:<br>此外，"bbaA"也是一个有效的答案，但"Aabb"是不正确的。<br>注意'A'和'a'被认为是两种不同的字符。
***

```python
from collections import Counter
class Solution(object):
    def frequencySort(self, s):
        """
        :type s: str
        :rtype: str
        """
        d = Counter(s)
        buf = {}
        for k, v in d.items():
            buf[v] = buf.get(v, "") + k * v
        ans = ""
        for i in reversed(xrange(0, len(s))):
            ans += buf.get(i, "")
        return ans
```
#### 第502题	**IPO	困难	**
***
假设 力扣（LeetCode）即将开始其 IPO。为了以更高的价格将股票卖给风险投资公司，力扣 希望在 IPO 之前开展一些项目以增加其资本。 由于资源有限，它只能在 IPO 之前完成最多 k 个不同的项目。帮助 力扣 设计完成最多 k 个不同项目后得到最大总资本的方式。<br>给定若干个项目。对于每个项目 i，它都有一个纯利润 Pi，并且需要最小的资本 Ci 来启动相应的项目。最初，你有 W 资本。当你完成一个项目时，你将获得纯利润，且利润将被添加到你的总资本中。<br>总而言之，从给定项目中选择最多 k 个不同项目的列表，以最大化最终资本，并输出最终可获得的最多资本。<br>示例 1:<br>输入: k=2, W=0, Profits=[1,2,3], Capital=[0,1,1].<br><br>输出: 4<br><br>解释:<br>由于你的初始资本为 0，你尽可以从 0 号项目开始。<br>在完成后，你将获得 1 的利润，你的总资本将变为 1。<br>此时你可以选择开始 1 号或 2 号项目。<br>由于你最多可以选择两个项目，所以你需要完成 2 号项目以获得最大的资本。<br>因此，输出最后最大化的资本，为 0 + 1 + 3 = 4。<br>注意:<br>假设所有输入数字都是非负整数。<br>表示利润和资本的数组的长度不超过 50000。<br>答案保证在 32 位有符号整数范围内。
***

```python
class Solution(object):
    def findMaximizedCapital(self, k, W, Profits, Capital):
        current = []
        future = sorted(zip(Capital, Profits))[::-1]
        for _ in range(k):
            while future and future[-1][0] <= W:
                heapq.heappush(current, -future.pop()[1])
            if current:
                W -= heapq.heappop(current)
        return W```
#### 第659题	**分割数组为连续子序列	中等	**
***
输入一个按升序排序的整数数组（可能包含重复数字），你需要将它们分割成几个子序列，其中每个子序列至少包含三个连续整数。返回你是否能做出这样的分割？<br>示例 1：<br>输入: [1,2,3,3,4,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3<br>3, 4, 5<br>示例 2：<br>输入: [1,2,3,3,4,4,5,5]<br>输出: True<br>解释:<br>你可以分割出这样两个连续子序列 :<br>1, 2, 3, 4, 5<br>3, 4, 5<br>示例 3：<br>输入: [1,2,3,4,4,5]<br>输出: False<br>提示：<br>输入的数组长度范围为 [1, 10000]
***

```python
class Solution(object):
    def isPossible(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        d = collections.defaultdict(list)
        for num in nums:
            if d[num - 1]:
                heapq.heappush(d[num], heapq.heappop(d[num - 1]) + 1)
            else:
                heapq.heappush(d[num], 1)
        return not any(length < 3 for length in sum(d.values(), []))

```
#### 第692题	**前K个高频单词	中等	**
***
给一非空的单词列表，返回前 k 个出现次数最多的单词。<br>返回的答案应该按单词出现频率由高到低排序。如果不同的单词有相同出现频率，按字母顺序排序。<br>示例 1：<br>输入: ["i", "love", "leetcode", "i", "love", "coding"], k = 2<br>输出: ["i", "love"]<br>解析: "i" 和 "love" 为出现次数最多的两个单词，均为2次。<br>注意，按字母顺序 "i" 在 "love" 之前。<br>示例 2：<br>输入: ["the", "day", "is", "sunny", "the", "the", "the", "sunny", "is", "is"], k = 4<br>输出: ["the", "is", "sunny", "day"]<br>解析: "the", "is", "sunny" 和 "day" 是出现次数最多的四个单词，<br>出现次数依次为 4, 3, 2 和 1 次。<br>注意：<br>假定 k 总为有效值， 1 ≤ k ≤ 集合元素数。<br>输入的单词均由小写字母组成。<br>扩展练习：<br>尝试以 O(n log k) 时间复杂度和 O(n) 空间复杂度解决。
***

```python
todo
```
#### 第703题	**数据流中的第K大元素	简单	**
***
设计一个找到数据流中第K大元素的类（class）。注意是排序后的第K大元素，不是第K个不同的元素。<br>你的 KthLargest 类需要一个同时接收整数 k 和整数数组nums 的构造器，它包含数据流中的初始元素。每次调用 KthLargest.add，返回当前数据流中第K大的元素。<br>示例:<br>int k = 3;<br>int[] arr = [4,5,8,2];<br>KthLargest kthLargest = new KthLargest(3, arr);<br>kthLargest.add(3);   // returns 4<br>kthLargest.add(5);   // returns 5<br>kthLargest.add(10);  // returns 5<br>kthLargest.add(9);   // returns 8<br>kthLargest.add(4);   // returns 8<br>说明:<br>你可以假设 nums 的长度≥ k-1 且k ≥ 1。
***

```python
todo
```
#### 第719题	**找出第 k 小的距离对	困难	**
***
给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。<br>示例 1:<br>输入：<br>nums = [1,3,1]<br>k = 1<br>输出：0<br>解释：<br>所有数对如下：<br>(1,3) -> 2<br>(1,1) -> 0<br>(3,1) -> 2<br>因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。<br>提示:<br>2 <= len(nums) <= 10000.<br>0 <= nums[i] < 1000000.<br>1 <= k <= len(nums) * (len(nums) - 1) / 2.
***

```python
todo
```
#### 第743题	**网络延迟时间	中等	**
***
有 N 个网络节点，标记为 1 到 N。<br>给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。<br>现在，我们向当前的节点 K 发送了一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。<br>注意:<br>N 的范围在 [1, 100] 之间。<br>K 的范围在 [1, N] 之间。<br>times 的长度在 [1, 6000] 之间。<br>所有的边 times[i] = (u, v, w) 都有 1 <= u, v <= N 且 0 <= w <= 100。
***

```python
todo
```
#### 第767题	**重构字符串	中等	**
***
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。<br>若可行，输出任意可行的结果。若不可行，返回空字符串。<br>示例 1:<br>输入: S = "aab"<br>输出: "aba"<br>示例 2:<br>输入: S = "aaab"<br>输出: ""<br>注意:<br>S 只包含小写字母并且长度在[1, 500]区间内。
***

```python
todo
```
#### 第778题	**水位上升的泳池中游泳	困难	**
***
在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。<br>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。<br>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？<br>示例 1:<br>输入: [[0,2],[1,3]]<br>输出: 3<br>解释:<br>时间为0时，你位于坐标方格的位置为 (0, 0)。<br>此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。<br><br>等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置<br>示例2:<br>输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br>输入: 16<br>解释:<br>0  1  2  3  4<br>24 23 22 21  5<br>12 13 14 15 16<br>11 17 18 19 20<br>10  9  8  7  6<br><br>最终的路线用加粗进行了标记。<br>我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的<br>提示:<br>2 <= N <= 50.<br>grid[i][j] 位于区间 [0, ..., N*N - 1] 内。
***

```python
todo
```
#### 第786题	**第 K 个最小的素数分数	困难	**
***
一个已排序好的表 A，其包含 1 和其他一些素数.  当列表中的每一个 p<q 时，我们可以构造一个分数 p/q 。<br>那么第 k 个最小的分数是多少呢?  以整数数组的形式返回你的答案, 这里 answer[0] = p 且 answer[1] = q.<br>示例:<br>输入: A = [1, 2, 3, 5], K = 3<br>输出: [2, 5]<br>解释:<br>已构造好的分数,排序后如下所示:<br>1/5, 1/3, 2/5, 1/2, 3/5, 2/3.<br>很明显第三个最小的分数是 2/5.<br><br>输入: A = [1, 7], K = 1<br>输出: [1, 7]<br>注意:<br>A 的取值范围在 2 — 2000.<br>每个 A[i] 的值在 1 —30000.<br>K 取值范围为 1 —A.length * (A.length - 1) / 2
***

```python
todo
```
#### 第787题	**K 站中转内最便宜的航班	中等	**
***
有 n 个城市通过 m 个航班连接。每个航班都从城市 u 开始，以价格 w 抵达 v。<br>现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到从 src 到 dst 最多经过 k 站中转的最便宜的价格。 如果没有这样的路线，则输出 -1。<br>示例 1:<br>输入:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 1<br>输出: 200<br>解释:<br>城市航班图如下<br><br><br>从城市 0 到城市 2 在 1 站中转以内的最便宜价格是 200，如图中红色所示。<br>示例 2:<br>输入:<br>n = 3, edges = [[0,1,100],[1,2,100],[0,2,500]]<br>src = 0, dst = 2, k = 0<br>输出: 500<br>解释:<br>城市航班图如下<br><br><br>从城市 0 到城市 2 在 0 站中转以内的最便宜价格是 500，如图中蓝色所示。<br>提示：<br>n 范围是 [1, 100]，城市标签从 0 到 n - 1.<br>航班数量范围是 [0, n * (n - 1) / 2].<br>每个航班的格式 (src, dst, price).<br>每个航班的价格范围是 [1, 10000].<br>k 范围是 [0, n - 1].<br>航班没有重复，且不存在环路
***

```python
todo
```
#### 第818题	**赛车	困难	**
***
你的赛车起始停留在位置 0，速度为 +1，正行驶在一个无限长的数轴上。（车也可以向负数方向行驶。）<br>你的车会根据一系列由 A（加速）和 R（倒车）组成的指令进行自动驾驶 。<br>当车得到指令 "A" 时, 将会做出以下操作： position += speed, speed *= 2。<br>当车得到指令 "R" 时, 将会做出以下操作：如果当前速度是正数，则将车速调整为 speed = -1 ；否则将车速调整为 speed = 1。  (当前所处位置不变。)<br>例如，当得到一系列指令 "AAR" 后, 你的车将会走过位置 0->1->3->3，并且速度变化为 1->2->4->-1。<br>现在给定一个目标位置，请给出能够到达目标位置的最短指令列表的长度。<br>示例 1:<br>输入:<br>target = 3<br>输出: 2<br>解释:<br>最短指令列表为 "AA"<br>位置变化为 0->1->3<br>示例 2:<br>输入:<br>target = 6<br>输出: 5<br>解释:<br>最短指令列表为 "AAARA"<br>位置变化为 0->1->3->7->7->6<br>说明:<br>1 <= target（目标位置） <= 10000。
***

```python
todo
```
