# 第8节

#### 第934题	**最短的桥	中等	**
***
在给定的二维二进制数组 A 中，存在两座岛。（岛是由四面相连的 1 形成的一个最大组。）<br>现在，我们可以将 0 变为 1，以使两座岛连接起来，变成一座岛。<br>返回必须翻转的 0 的最小数目。（可以保证答案至少是 1。）<br>示例 1：<br>输入：[[0,1],[1,0]]<br>输出：1<br>示例 2：<br>输入：[[0,1,0],[0,0,0],[0,0,1]]<br>输出：2<br>示例 3：<br>输入：[[1,1,1,1,1],[1,0,0,0,1],[1,0,1,0,1],[1,0,0,0,1],[1,1,1,1,1]]<br>输出：1<br>提示：<br>1 <= A.length = A[0].length <= 100<br>A[i][j] == 0 或 A[i][j] == 1
***

```python
todo
```
#### 第947题	**移除最多的同行或同列石头	中等	**
***
在二维平面上，我们将石头放置在一些整数坐标点上。每个坐标点上最多只能有一块石头。<br><br>现在，move 操作将会移除与网格上的某一块石头共享一列或一行的一块石头。<br><br>我们最多能执行多少次 move 操作？<br>示例 1：<br>输入：stones = [[0,0],[0,1],[1,0],[1,2],[2,1],[2,2]]<br>输出：5<br>示例 2：<br>输入：stones = [[0,0],[0,2],[1,1],[2,0],[2,2]]<br>输出：3<br>示例 3：<br>输入：stones = [[0,0]]<br>输出：0<br>提示：<br>1 <= stones.length <= 1000<br>0 <= stones[i][j] < 10000
***

```python
todo
```
#### 第959题	**由斜杠划分区域	中等	**
***
在由 1 x 1 方格组成的 N x N 网格 grid 中，每个 1 x 1 方块由 /、\ 或空格构成。这些字符会将方块划分为一些共边的区域。<br>（请注意，反斜杠字符是转义的，因此 \ 用 "\\" 表示。）。<br>返回区域的数目。<br>示例 1：<br>输入：<br>[<br>" /",<br>"/ "<br>]<br>输出：2<br>解释：2x2 网格如下：<br>示例 2：<br>输入：<br>[<br>" /",<br>"  "<br>]<br>输出：1<br>解释：2x2 网格如下：<br>示例 3：<br>输入：<br>[<br>"\\/",<br>"/\\"<br>]<br>输出：4<br>解释：（回想一下，因为 \ 字符是转义的，所以 "\\/" 表示 \/，而 "/\\" 表示 /\。）<br>2x2 网格如下：<br>示例 4：<br>输入：<br>[<br>"/\\",<br>"\\/"<br>]<br>输出：5<br>解释：（回想一下，因为 \ 字符是转义的，所以 "/\\" 表示 /\，而 "\\/" 表示 \/。）<br>2x2 网格如下：<br>示例 5：<br>输入：<br>[<br>"//",<br>"/ "<br>]<br>输出：3<br>解释：2x2 网格如下：<br>提示：<br>1 <= grid.length == grid[0].length <= 30<br>grid[i][j] 是 '/'、'\'、或 ' '。
***

```python
todo
```
#### 第968题	**监控二叉树	困难	**
***
给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。<br>示例 1：<br>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：<br>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br><br>提示：<br>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。
***

```python
todo
```
#### 第971题	**翻转二叉树以匹配先序遍历	中等	**
***
给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, ..., N} 中的值。<br>通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。<br>考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。<br>（回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。）<br>我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。<br>如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。<br>如果不能，则返回列表 [-1]。<br>示例 1：<br>输入：root = [1,2], voyage = [2,1]<br>输出：[-1]<br>示例 2：<br>输入：root = [1,2,3], voyage = [1,3,2]<br>输出：[1]<br>示例 3：<br>输入：root = [1,2,3], voyage = [1,2,3]<br>输出：[]<br>提示：<br>1 <= N <= 100
***

```python
todo
```
#### 第979题	**在二叉树中分配硬币	中等	**
***
给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。<br>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。<br>返回使每个结点上只有一枚硬币所需的移动次数。<br>示例 1：<br>输入：[3,0,0]<br>输出：2<br>解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。<br>示例 2：<br>输入：[0,3,0]<br>输出：3<br>解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。<br>示例 3：<br>输入：[1,0,2]<br>输出：2<br>示例 4：<br>输入：[1,0,0,null,3]<br>输出：4<br>提示：<br>1<= N <= 100<br>0 <= node.val <= N
***

```python
todo
```
#### 第980题	**不同路径 III	困难	**
***
在二维网格 grid 上，有 4 种类型的方格：<br>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。<br>示例 1：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>输出：2<br>解释：我们有以下两条路径：<br>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)<br>2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)<br>示例 2：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]<br>输出：4<br>解释：我们有以下四条路径：<br>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)<br>2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)<br>3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)<br>4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)<br>示例 3：<br>输入：[[0,1],[2,0]]<br>输出：0<br>解释：<br>没有一条路能完全穿过每一个空的方格一次。<br>请注意，起始和结束方格可以位于网格中的任意位置。<br>提示：<br>1 <= grid.length * grid[0].length <= 20
***

```python
todo
```
#### 第988题	**从叶结点开始的最小字符串	中等	**
***
给定一颗根结点为 root 的二叉树，书中的每个结点都有一个从 0 到 25 的值，分别代表字母 'a' 到 'z'：值 0 代表 'a'，值 1 代表 'b'，依此类推。<br>找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。<br>（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 "ab" 比 "aba" 要小。叶结点是指没有子结点的结点。）<br>示例 1：<br>输入：[0,1,2,3,4,3,4]<br>输出："dba"<br>示例 2：<br>输入：[25,1,3,1,3,0,2]<br>输出："adz"<br>示例 3：<br>输入：[2,2,1,null,1,0,null,0]<br>输出："abc"<br>提示：<br>给定树的结点数介于 1 和 8500 之间。<br>树中的每个结点都有一个介于 0 和 25 之间的值。
***

```python
todo
```
#### 第1020题	**飞地的数量	中等	**
***
给出一个二维数组 A，每个单元格为 0（代表海）或 1（代表陆地）。<br>移动是指在陆地上从一个地方走到另一个地方（朝四个方向之一）或离开网格的边界。<br>返回网格中无法在任意次数的移动中离开网格边界的陆地单元格的数量。<br>示例 1：<br>输入：[[0,0,0,0],[1,0,1,0],[0,1,1,0],[0,0,0,0]]<br>输出：3<br>解释：<br>有三个 1 被 0 包围。一个 1 没有被包围，因为它在边界上。<br>示例 2：<br>输入：[[0,1,1,0],[0,0,1,0],[0,0,1,0],[0,0,0,0]]<br>输出：0<br>解释：<br>所有 1 都在边界上或可以到达边界。<br>提示：<br>1 <= A.length <= 500<br>1 <= A[i].length <= 500<br>0 <= A[i][j] <= 1<br>所有行的大小都相同
***

```python
todo
```
#### 第1026题	**节点与其祖先之间的最大差值	中等	**
***
给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。<br>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）<br>示例：<br>输入：[8,3,10,1,6,null,14,null,null,4,7,13]<br>输出：7<br>解释：<br>我们有大量的节点与其祖先的差值，其中一些如下：<br>|8 - 3| = 5<br>|3 - 7| = 4<br>|8 - 1| = 7<br>|10 - 13| = 3<br>在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。<br>提示：<br>树中的节点数在 2 到 5000 之间。<br>每个节点的值介于 0 到 100000 之间。
***

```python
todo
```
#### 第1028题	**从先序遍历还原二叉树	困难	**
***
我们从二叉树的根节点 root 开始进行深度优先搜索。<br>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。<br>如果节点只有一个子节点，那么保证该子节点为左子节点。<br>给出遍历输出 S，还原树并返回其根节点 root。<br>示例 1：<br>输入："1-2--3--4-5--6--7"<br>输出：[1,2,5,3,4,6,7]<br>示例 2：<br>输入："1-2--3---4-5--6---7"<br>输出：[1,2,5,3,null,6,null,4,null,7]<br>示例 3：<br>输入："1-401--349---90--88"<br>输出：[1,401,null,349,88,90]<br>提示：<br>原始树中的节点数介于 1 和 1000 之间。<br>每个节点的值介于 1 和 10 ^ 9 之间。
***

```python
todo
```
#### 第1034题	**边框着色	中等	**
***
给出一个二维整数网格 grid，网格中的每个值表示该位置处的网格块的颜色。<br>只有当两个网格块的颜色相同，而且在四个方向中任意一个方向上相邻时，它们属于同一连通分量。<br>连通分量的边界是指连通分量中的所有与不在分量中的正方形相邻（四个方向上）的所有正方形，或者在网格的边界上（第一行/列或最后一行/列）的所有正方形。<br>给出位于 (r0, c0) 的网格块和颜色 color，使用指定颜色 color 为所给网格块的连通分量的边界进行着色，并返回最终的网格 grid 。<br>示例 1：<br>输入：grid = [[1,1],[1,2]], r0 = 0, c0 = 0, color = 3<br>输出：[[3, 3], [3, 2]]<br>示例 2：<br>输入：grid = [[1,2,2],[2,3,2]], r0 = 0, c0 = 1, color = 3<br>输出：[[1, 3, 3], [2, 3, 3]]<br>示例 3：<br>输入：grid = [[1,1,1],[1,1,1],[1,1,1]], r0 = 1, c0 = 1, color = 2<br>输出：[[2, 2, 2], [2, 1, 2], [2, 2, 2]]<br>提示：<br>1 <= grid.length <= 50<br>1 <= grid[0].length <= 50<br>1 <= grid[i][j] <= 1000<br>0 <= r0 < grid.length<br>0 <= c0 < grid[0].length<br>1 <= color <= 1000
***

```python
todo
```
