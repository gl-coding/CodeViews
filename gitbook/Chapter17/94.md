# 第9节

#### 第1080题	**根到叶路径上的不足节点	中等	**
***
给定一棵二叉树的根 root，请你考虑它所有 从根到叶的路径：从根到任何叶的路径。（所谓一个叶子节点，就是一个没有子节点的节点）<br>假如通过节点 node 的每种可能的 “根-叶” 路径上值的总和全都小于给定的 limit，则该节点被称之为「不足节点」，需要被删除。<br>请你删除所有不足节点，并返回生成的二叉树的根。<br>示例 1：<br>输入：root = [1,2,3,4,-99,-99,7,8,9,-99,-99,12,13,-99,14], limit = 1<br><br>输出：[1,2,3,4,null,null,7,8,9,null,14]<br>示例 2：<br>输入：root = [5,4,8,11,null,17,4,7,1,null,null,5,3], limit = 22<br><br>输出：[5,4,8,11,null,17,4,7,null,null,null,5]<br>示例 3：<br>输入：root = [5,-6,-6], limit = 0<br>输出：[]<br>提示：<br>给定的树有 1 到 5000 个节点<br>-10^5 <= node.val <= 10^5<br>-10^9 <= limit <= 10^9
***

```python
todo
```
#### 第1110题	**删点成林	中等	**
***
给出二叉树的根节点 root，树上每个节点都有一个不同的值。<br>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。<br>返回森林中的每棵树。你可以按任意顺序组织答案。<br>示例：<br>输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]<br>输出：[[1,2,null,4],[6],[7]]<br>提示：<br>树中的节点数最大为 1000。<br>每个节点都有一个介于 1 到 1000 之间的值，且各不相同。<br>to_delete.length <= 1000<br>to_delete 包含一些从 1 到 1000、各不相同的值。
***

```python
todo
```
#### 第1123题	**最深叶节点的最近公共祖先	中等	**
***
给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。<br>回想一下：<br>叶节点 是二叉树中没有子节点的节点<br>树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1<br>如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。<br>示例 1：<br>输入：root = [1,2,3]<br>输出：[1,2,3]<br>示例 2：<br>输入：root = [1,2,3,4]<br>输出：[4]<br>示例 3：<br>输入：root = [1,2,3,4,5]<br>输出：[2,4,5]<br>提示：<br>给你的树中将有 1 到 1000 个节点。<br>树中每个节点的值都在 1 到 1000 之间。
***

```python
todo
```
#### 第1145题	**二叉树着色游戏	中等	**
***
有两位极客玩家参与了一场「二叉树着色」的游戏。游戏中，给出二叉树的根节点 root，树上总共有 n 个节点，且 n 为奇数，其中每个节点上的值从 1 到 n 各不相同。<br>游戏从「一号」玩家开始（「一号」玩家为红色，「二号」玩家为蓝色），最开始时，<br>「一号」玩家从 [1, n] 中取一个值 x（1 <= x <= n）；<br>「二号」玩家也从 [1, n] 中取一个值 y（1 <= y <= n）且 y != x。<br>「一号」玩家给值为 x 的节点染上红色，而「二号」玩家给值为 y 的节点染上蓝色。<br>之后两位玩家轮流进行操作，每一回合，玩家选择一个他之前涂好颜色的节点，将所选节点一个 未着色 的邻节点（即左右子节点、或父节点）进行染色。<br>如果当前玩家无法找到这样的节点来染色时，他的回合就会被跳过。<br>若两个玩家都没有可以染色的节点时，游戏结束。着色节点最多的那位玩家获得胜利 ✌️。<br>现在，假设你是「二号」玩家，根据所给出的输入，假如存在一个 y 值可以确保你赢得这场游戏，则返回 true；若无法获胜，就请返回 false。<br>示例：<br>输入：root = [1,2,3,4,5,6,7,8,9,10,11], n = 11, x = 3<br>输出：True<br>解释：第二个玩家可以选择值为 2 的节点。<br>提示：<br>二叉树的根节点为 root，树上由 n 个节点，节点上的值从 1 到 n 各不相同。<br>n 为奇数。<br>1 <= x <= n <= 100
***

```python
todo
```
#### 第1192题	**查找集群内的「关键连接」	困难	**
***
力扣数据中心有 n 台服务器，分别按从 0 到 n-1 的方式进行了编号。<br>它们之间以「服务器到服务器」点对点的形式相互连接组成了一个内部集群，其中连接 connections 是无向的。<br>从形式上讲，connections[i] = [a, b] 表示服务器 a 和 b 之间形成连接。任何服务器都可以直接或者间接地通过网络到达任何其他服务器。<br>「关键连接」是在该集群中的重要连接，也就是说，假如我们将它移除，便会导致某些服务器无法访问其他服务器。<br>请你以任意顺序返回该集群内的所有 「关键连接」。<br>示例 1：<br>输入：n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]<br>输出：[[1,3]]<br>解释：[[3,1]] 也是正确的。<br>提示：<br>1 <= n <= 10^5<br>n-1 <= connections.length <= 10^5<br>connections[i][0] != connections[i][1]<br>不存在重复的连接
***

```python
todo
```
#### 第1203题	**项目管理	困难	**
***
公司共有 n 个项目和  m 个小组，每个项目要不没有归属，要不就由其中的一个小组负责。<br>我们用 group[i] 代表第 i 个项目所属的小组，如果这个项目目前无人接手，那么 group[i] 就等于 -1。（项目和小组都是从零开始编号的）<br>请你帮忙按要求安排这些项目的进度，并返回排序后的项目列表：<br>同一小组的项目，排序后在列表中彼此相邻。<br>项目之间存在一定的依赖关系，我们用一个列表 beforeItems 来表示，其中 beforeItems[i] 表示在进行第 i 个项目前（位于第 i 个项目左侧）应该完成的所有项目。<br>结果要求：<br>如果存在多个解决方案，只需要返回其中任意一个即可。<br>如果没有合适的解决方案，就请返回一个 空列表。<br>示例 1：<br>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3,6],[],[],[]]<br>输出：[6,3,4,1,5,2,0,7]<br>示例 2：<br>输入：n = 8, m = 2, group = [-1,-1,1,0,0,1,0,-1], beforeItems = [[],[6],[5],[6],[3],[],[4],[]]<br>输出：[]<br>解释：与示例 1 大致相同，但是在排序后的列表中，4 必须放在 6 的前面。<br>提示：<br>1 <= m <= n <= 3*10^4<br>group.length == beforeItems.length == n<br>-1 <= group[i] <= m-1<br>0 <= beforeItems[i].length <= n-1<br>0 <= beforeItems[i][j] <= n-1<br>i != beforeItems[i][j]
***

```python
todo
```
#### 第1254题	**统计封闭岛屿的数目	中等	**
***
有一个二维矩阵 grid ，每个位置要么是陆地（记号为 0 ）要么是水域（记号为 1 ）。<br>我们从一块陆地出发，每次可以往上下左右 4 个方向相邻区域走，能走到的所有陆地区域，我们将其称为一座「岛屿」。<br>如果一座岛屿 完全 由水域包围，即陆地边缘上下左右所有相邻区域都是水域，那么我们将其称为 「封闭岛屿」。<br>请返回封闭岛屿的数目。<br>示例 1：<br>输入：grid = [[1,1,1,1,1,1,1,0],[1,0,0,0,0,1,1,0],[1,0,1,0,1,1,1,0],[1,0,0,0,0,1,0,1],[1,1,1,1,1,1,1,0]]<br>输出：2<br>解释：<br>灰色区域的岛屿是封闭岛屿，因为这座岛屿完全被水域包围（即被 1 区域包围）。<br>示例 2：<br>输入：grid = [[0,0,1,0,0],[0,1,0,1,0],[0,1,1,1,0]]<br>输出：1<br>示例 3：<br>输入：grid = [[1,1,1,1,1,1,1],<br>[1,0,0,0,0,0,1],<br>[1,0,1,1,1,0,1],<br>[1,0,1,0,1,0,1],<br>[1,0,1,1,1,0,1],<br>[1,0,0,0,0,0,1],<br>[1,1,1,1,1,1,1]]<br>输出：2<br>提示：<br>1 <= grid.length, grid[0].length <= 100<br>0 <= grid[i][j] <=1
***

```python
todo
```
#### 第1302题	**层数最深叶子节点的和	中等	**
***
给你一棵二叉树，请你返回层数最深的叶子节点的和。<br>示例：<br>输入：root = [1,2,3,4,5,null,6,7,null,null,null,null,8]<br>输出：15<br>提示：<br>树中节点数目在 1 到 10^4 之间。<br>每个节点的值在 1 到 100 之间。
***

```python
todo
```
#### 第1315题	**祖父节点值为偶数的节点和	中等	**
***
给你一棵二叉树，请你返回满足以下条件的所有节点的值之和：<br>该节点的祖父节点的值为偶数。（一个节点的祖父节点是指该节点的父节点的父节点。）<br>如果不存在祖父节点值为偶数的节点，那么返回 0 。<br>示例：<br>输入：root = [6,7,8,2,7,1,3,9,null,1,4,null,null,null,5]<br>输出：18<br>解释：图中红色节点的祖父节点的值为偶数，蓝色节点为这些红色节点的祖父节点。<br>提示：<br>树中节点的数目在 1 到 10^4 之间。<br>每个节点的值在 1 到 100 之间。
***

```python
todo
```
#### 第1319题	**连通网络的操作次数	中等	**
***
用以太网线缆将 n 台计算机连接成一个网络，计算机的编号从 0 到 n-1。线缆用 connections 表示，其中 connections[i] = [a, b] 连接了计算机 a 和 b。<br>网络中的任何一台计算机都可以通过网络直接或者间接访问同一个网络中其他任意一台计算机。<br>给你这个计算机网络的初始布线 connections，你可以拔开任意两台直连计算机之间的线缆，并用它连接一对未直连的计算机。请你计算并返回使所有计算机都连通所需的最少操作次数。如果不可能，则返回 -1 。<br>示例 1：<br>输入：n = 4, connections = [[0,1],[0,2],[1,2]]<br>输出：1<br>解释：拔下计算机 1 和 2 之间的线缆，并将它插到计算机 1 和 3 上。<br>示例 2：<br>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2],[1,3]]<br>输出：2<br>示例 3：<br>输入：n = 6, connections = [[0,1],[0,2],[0,3],[1,2]]<br>输出：-1<br>解释：线缆数量不足。<br>示例 4：<br>输入：n = 5, connections = [[0,1],[0,2],[3,4],[2,3]]<br>输出：0<br>提示：<br>1 <= n <= 10^5<br>1 <= connections.length <= min(n*(n-1)/2, 10^5)<br>connections[i].length == 2<br>0 <= connections[i][0], connections[i][1] < n<br>connections[i][0] != connections[i][1]<br>没有重复的连接。<br>两台计算机不会通过多条线缆连接。
***

```python
todo
```
