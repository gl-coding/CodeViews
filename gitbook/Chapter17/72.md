# 第7节

#### 第802题	**找到最终的安全状态	中等	**
***
在有向图中, 我们从某个节点和每个转向处开始, 沿着图的有向边走。 如果我们到达的节点是终点 (即它没有连出的有向边), 我们停止。<br>现在, 如果我们最后能走到终点，那么我们的起始节点是最终安全的。 更具体地说, 存在一个自然数 K,  无论选择从哪里开始行走, 我们走了不到 K 步后必能停止在一个终点。<br>哪些节点最终是安全的？ 结果返回一个有序的数组。<br>该有向图有 N 个节点，标签为 0, 1, ..., N-1, 其中 N 是 graph 的节点数.  图以以下的形式给出: graph[i] 是节点 j 的一个列表，满足 (i, j) 是图的一条有向边。<br>示例：<br>输入：graph = [[1,2],[2,3],[5],[0],[5],[],[]]<br>输出：[2,4,5,6]<br>这里是上图的示意图。<br>提示：<br>graph 节点数不超过 10000.<br>图的边数不会超过 32000.<br>每个 graph[i] 被排序为不同的整数列表， 在区间 [0, graph.length - 1] 中选取。
***

```python
todo
```
#### 第827题	**最大人工岛	困难	**
***
在二维地图上， 0代表海洋， 1代表陆地，我们最多只能将一格 0 海洋变成 1变成陆地。<br>进行填海之后，地图上最大的岛屿面积是多少？（上、下、左、右四个方向相连的 1 可形成岛屿）<br>示例 1:<br>输入: [[1, 0], [0, 1]]<br>输出: 3<br>解释: 将一格0变成1，最终连通两个小岛得到面积为 3 的岛屿。<br>示例 2:<br>输入: [[1, 1], [1, 0]]<br>输出: 4<br>解释: 将一格0变成1，岛屿的面积扩大为 4。<br>示例 3:<br>输入: [[1, 1], [1, 1]]<br>输出: 4<br>解释: 没有0可以让我们变成1，面积依然为 4。<br>说明:<br>1 <= grid.length = grid[0].length <= 50<br>0 <= grid[i][j] <= 1
***

```python
todo
```
#### 第834题	**树中距离之和	困难	**
***
给定一个无向、连通的树。树中有 N 个标记为 0...N-1 的节点以及 N-1 条边 。<br>第 i 条边连接节点 edges[i][0] 和 edges[i][1] 。<br>返回一个表示节点 i 与其他所有节点距离之和的列表 ans。<br>示例 1:<br>输入: N = 6, edges = [[0,1],[0,2],[2,3],[2,4],[2,5]]<br>输出: [8,12,6,10,10,10]<br>解释:<br>如下为给定的树的示意图：<br>0<br>/ \<br>1   2<br>/|\<br>3 4 5<br><br>我们可以计算出 dist(0,1) + dist(0,2) + dist(0,3) + dist(0,4) + dist(0,5)<br>也就是 1 + 1 + 2 + 2 + 2 = 8。 因此，answer[0] = 8，以此类推。<br>说明: 1 <= N <= 10000
***

```python
todo
```
#### 第839题	**相似字符串组	困难	**
***
如果我们交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等，那么称 X 和 Y 两个字符串相似。如果这两个字符串本身是相等的，那它们也是相似的。<br>例如，"tars" 和 "rats" 是相似的 (交换 0 与 2 的位置)； "rats" 和 "arts" 也是相似的，但是 "star" 不与 "tars"，"rats"，或 "arts" 相似。<br>总之，它们通过相似性形成了两个关联组：{"tars", "rats", "arts"} 和 {"star"}。注意，"tars" 和 "arts" 是在同一组中，即使它们并不相似。形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。<br>我们给出了一个不包含重复的字符串列表 A。列表中的每个字符串都是 A 中其它所有字符串的一个字母异位词。请问 A 中有多少个相似字符串组？<br>示例：<br>输入：["tars","rats","arts","star"]<br>输出：2<br>提示：<br>A.length <= 2000<br>A[i].length <= 1000<br>A.length * A[i].length <= 20000<br>A 中的所有单词都只包含小写字母。<br>A 中的所有单词都具有相同的长度，且是彼此的字母异位词。<br>此问题的判断限制时间已经延长。<br>备注：<br>字母异位词[anagram]，一种把某个字符串的字母的位置（顺序）加以改换所形成的新词。
***

```python
todo
```
#### 第841题	**钥匙和房间	中等	**
***
有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。<br>在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。<br>最初，除 0 号房间外的其余所有房间都被锁住。<br>你可以自由地在房间之间来回走动。<br>如果能进入每个房间返回 true，否则返回 false。<br>示例 1：<br>输入: [[1],[2],[3],[]]<br>输出: true<br>解释:<br>我们从 0 号房间开始，拿到钥匙 1。<br>之后我们去 1 号房间，拿到钥匙 2。<br>然后我们去 2 号房间，拿到钥匙 3。<br>最后我们去了 3 号房间。<br>由于我们能够进入每个房间，我们返回 true。<br>示例 2：<br>输入：[[1,3],[3,0,1],[2],[0]]<br>输出：false<br>解释：我们不能进入 2 号房间。<br>提示：<br>1 <= rooms.length <= 1000<br>0 <= rooms[i].length <= 1000<br>所有房间中的钥匙数量总计不超过 3000。
***

```python
todo
```
#### 第851题	**喧闹和富有	中等	**
***
在一组 N 个人（编号为 0, 1, 2, ..., N-1）中，每个人都有不同数目的钱，以及不同程度的安静（quietness）。<br>为了方便起见，我们将编号为 x 的人简称为 "person x "。<br>如果能够肯定 person x 比 person y 更有钱的话，我们会说 richer[i] = [x, y] 。注意 richer 可能只是有效观察的一个子集。<br>另外，如果 person x 的安静程度为 q ，我们会说 quiet[x] = q 。<br>现在，返回答案 answer ，其中 answer[x] = y 的前提是，在所有拥有的钱不少于 person x 的人中，person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。<br>示例：<br>输入：richer = [[1,0],[2,1],[3,1],[3,7],[4,3],[5,3],[6,3]], quiet = [3,2,5,4,6,1,7,0]<br>输出：[5,5,2,5,4,5,6,7]<br>解释：<br>answer[0] = 5，<br>person 5 比 person 3 有更多的钱，person 3 比 person 1 有更多的钱，person 1 比 person 0 有更多的钱。<br>唯一较为安静（有较低的安静值 quiet[x]）的人是 person 7，<br>但是目前还不清楚他是否比 person 0 更有钱。<br><br>answer[7] = 7，<br>在所有拥有的钱肯定不少于 person 7 的人中(这可能包括 person 3，4，5，6 以及 7)，<br>最安静(有较低安静值 quiet[x])的人是 person 7。<br><br>其他的答案也可以用类似的推理来解释。<br>提示：<br>1 <= quiet.length = N <= 500<br>0 <= quiet[i] < N，所有 quiet[i] 都不相同。<br>0 <= richer.length <= N * (N-1) / 2<br>0 <= richer[i][j] < N<br>richer[i][0] != richer[i][1]<br>richer[i] 都是不同的。<br>对 richer 的观察在逻辑上是一致的。
***

```python
todo
```
#### 第863题	**二叉树中所有距离为 K 的结点	中等	**
***
给定一个二叉树（具有根结点 root）， 一个目标结点 target ，和一个整数值 K 。<br>返回到目标结点 target 距离为 K 的所有结点的值的列表。 答案可以以任何顺序返回。<br>示例 1：<br>输入：root = [3,5,1,6,2,0,8,null,null,7,4], target = 5, K = 2<br><br>输出：[7,4,1]<br><br>解释：<br>所求结点为与目标结点（值为 5）距离为 2 的结点，<br>值分别为 7，4，以及 1<br><br><br><br>注意，输入的 "root" 和 "target" 实际上是树上的结点。<br>上面的输入仅仅是对这些对象进行了序列化描述。<br>提示：<br>给定的树是非空的，且最多有 K 个结点。<br>树上的每个结点都具有唯一的值 0 <= node.val <= 500 。<br>目标结点 target 是树上的结点。<br>0 <= K <= 1000.
***

```python
todo
```
#### 第872题	**叶子相似的树	简单	**
***
请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。<br>举个例子，如上图所示，给定一颗叶值序列为 (6, 7, 4, 9, 8) 的树。<br>如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。<br>如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。<br>提示：<br>给定的两颗树可能会有 1 到 100 个结点。
***

```python
todo
```
#### 第886题	**可能的二分法	中等	**
***
给定一组 N 人（编号为 1, 2, ..., N）， 我们想把每个人分进任意大小的两组。<br>每个人都可能不喜欢其他人，那么他们不应该属于同一组。<br>形式上，如果 dislikes[i] = [a, b]，表示不允许将编号为 a 和 b 的人归入同一组。<br>当可以用这种方法将每个人分进两组时，返回 true；否则返回 false。<br>示例 1：<br>输入：N = 4, dislikes = [[1,2],[1,3],[2,4]]<br>输出：true<br>解释：group1 [1,4], group2 [2,3]<br>示例 2：<br>输入：N = 3, dislikes = [[1,2],[1,3],[2,3]]<br>输出：false<br>示例 3：<br>输入：N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]<br>输出：false<br>提示：<br>1 <= N <= 2000<br>0 <= dislikes.length <= 10000<br>1 <= dislikes[i][j] <= N<br>dislikes[i][0] < dislikes[i][1]<br>对于 dislikes[i] == dislikes[j] 不存在 i != j
***

```python
todo
```
#### 第897题	**递增顺序查找树	简单	**
***
给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。<br>示例 ：<br>输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]<br><br>5<br>/ \<br>3    6<br>/ \    \<br>2   4    8<br>/        / \<br>1        7   9<br><br>输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br><br>1<br>\<br>2<br>\<br>3<br>\<br>4<br>\<br>5<br>\<br>6<br>\<br>7<br>\<br>8<br>\<br>9<br>提示：<br>给定树中的结点数介于 1 和 100 之间。<br>每个结点都有一个从 0 到 1000 范围内的唯一整数值。
***

```python
todo
```
#### 第924题	**尽量减少恶意软件的传播	困难	**
***
在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。<br>一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。<br>假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。<br>我们可以从初始列表中删除一个节点。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。<br>请注意，如果某个节点已从受感染节点的列表 initial 中删除，它以后可能仍然因恶意软件传播而受到感染。<br>示例 1：<br>输入：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]<br>输出：0<br>示例 2：<br>输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]<br>输出：0<br>示例 3：<br>输入：graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]<br>输出：1<br>提示：<br>1 < graph.length = graph[0].length <= 300<br>0 <= graph[i][j] == graph[j][i] <= 1<br>graph[i][i] = 1<br>1 <= initial.length < graph.length<br>0 <= initial[i] < graph.length
***

```python
todo
```
#### 第928题	**尽量减少恶意软件的传播 II	困难	**
***
(这个问题与 尽量减少恶意软件的传播 是一样的，不同之处用粗体表示。)<br>在节点网络中，只有当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j。<br>一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。<br>假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。<br>我们可以从初始列表中删除一个节点，并完全移除该节点以及从该节点到任何其他节点的任何连接。如果移除这一节点将最小化 M(initial)， 则返回该节点。如果有多个节点满足条件，就返回索引最小的节点。<br>示例 1：<br>输出：graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]<br>输入：0<br>示例 2：<br>输入：graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]<br>输出：1<br>示例 3：<br>输入：graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]<br>输出：1<br>提示：<br>1 < graph.length = graph[0].length <= 300<br>0 <= graph[i][j] == graph[j][i] <= 1<br>graph[i][i] = 1<br>1 <= initial.length < graph.length<br>0 <= initial[i] < graph.length
***

```python
todo
```
