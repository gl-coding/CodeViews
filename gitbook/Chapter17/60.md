# 第6节

#### 第679题	**24 点游戏	困难	**
***
你有 4 张写有 1 到 9 数字的牌。你需要判断是否能通过 *，/，+，-，(，) 的运算得到 24。<br>示例 1:<br>输入: [4, 1, 8, 7]<br>输出: True<br>解释: (8-4) * (7-1) = 24<br>示例 2:<br>输入: [1, 2, 1, 2]<br>输出: False<br>注意:<br>除法运算符 / 表示实数除法，而不是整数除法。例如 4 / (1 - 2/3) = 12 。<br>每个运算符对两个数进行运算。特别是我们不能用 - 作为一元运算符。例如，[1, 1, 1, 1] 作为输入时，表达式 -1 - 1 - 1 - 1 是不允许的。<br>你不能将数字连接在一起。例如，输入为 [1, 2, 1, 2] 时，不能写成 12 + 12 。
***

```python
todo
```
#### 第685题	**冗余连接 II	困难	**
***
在本问题中，有根树指满足以下条件的有向图。该树只有一个根节点，所有其他节点都是该根节点的后继。每一个节点只有一个父节点，除了根节点没有父节点。<br>输入一个有向图，该图由一个有着N个节点 (节点值不重复1, 2, ..., N) 的树及一条附加的边构成。附加的边的两个顶点包含在1到N中间，这条附加的边不属于树中已存在的边。<br>结果图是一个以边组成的二维数组。 每一个边 的元素是一对 [u, v]，用以表示有向图中连接顶点 u and v和顶点的边，其中父节点u是子节点v的一个父节点。<br>返回一条能删除的边，使得剩下的图是有N个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。<br>示例 1:<br>输入: [[1,2], [1,3], [2,3]]<br>输出: [2,3]<br>解释: 给定的有向图如下:<br>1<br>/ \<br>v   v<br>2-->3<br>示例 2:<br>输入: [[1,2], [2,3], [3,4], [4,1], [1,5]]<br>输出: [4,1]<br>解释: 给定的有向图如下:<br>5 <- 1 -> 2<br>^    |<br>|    v<br>4 <- 3<br>注意:<br>二维数组大小的在3到1000范围内。<br>二维数组中的每个整数在1到N之间，其中 N 是二维数组的大小。
***

```python
todo
```
#### 第690题	**员工的重要性	简单	**
***
给定一个保存员工信息的数据结构，它包含了员工唯一的id，重要度 和 直系下属的id。<br>比如，员工1是员工2的领导，员工2是员工3的领导。他们相应的重要度为15, 10, 5。那么员工1的数据结构是[1, 15, [2]]，员工2的数据结构是[2, 10, [3]]，员工3的数据结构是[3, 5, []]。注意虽然员工3也是员工1的一个下属，但是由于并不是直系下属，因此没有体现在员工1的数据结构中。<br>现在输入一个公司的所有员工信息，以及单个员工id，返回这个员工和他所有下属的重要度之和。<br>示例 1:<br>输入: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>输出: 11<br>解释:<br>员工1自身的重要度是5，他有两个直系下属2和3，而且2和3的重要度均为3。因此员工1的总重要度是 5 + 3 + 3 = 11。<br>注意:<br>一个员工最多有一个直系领导，但是可以有多个直系下属<br>员工数量不超过2000。
***

```python
todo
```
#### 第695题	**岛屿的最大面积	中等	**
***
给定一个包含了一些 0 和 1的非空二维数组 grid , 一个 岛屿 是由四个方向 (水平或垂直) 的 1 (代表土地) 构成的组合。你可以假设二维矩阵的四个边缘都被水包围着。<br>找到给定的二维数组中最大的岛屿面积。(如果没有岛屿，则返回面积为0。)<br>示例 1:<br>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br>[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>[0,1,1,0,1,0,0,0,0,0,0,0,0],<br>[0,1,0,0,1,1,0,0,1,0,1,0,0],<br>[0,1,0,0,1,1,0,0,1,1,1,0,0],<br>[0,0,0,0,0,0,0,0,0,0,1,0,0],<br>[0,0,0,0,0,0,0,1,1,1,0,0,0],<br>[0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>对于上面这个给定矩阵应返回 6。注意答案不应该是11，因为岛屿只能包含水平或垂直的四个方向的‘1’。<br>示例 2:<br>[[0,0,0,0,0,0,0,0]]<br>对于上面这个给定的矩阵, 返回 0。<br>注意: 给定的矩阵grid 的长度和宽度都不超过 50。
***

```python
todo
```
#### 第721题	**账户合并	中等	**
***
给定一个列表 accounts，每个元素 accounts[i] 是一个字符串列表，其中第一个元素 accounts[i][0] 是 名称 (name)，其余元素是 emails 表示该帐户的邮箱地址。<br>现在，我们想合并这些帐户。如果两个帐户都有一些共同的邮件地址，则两个帐户必定属于同一个人。请注意，即使两个帐户具有相同的名称，它们也可能属于不同的人，因为人们可能具有相同的名称。一个人最初可以拥有任意数量的帐户，但其所有帐户都具有相同的名称。<br>合并帐户后，按以下格式返回帐户：每个帐户的第一个元素是名称，其余元素是按顺序排列的邮箱地址。accounts 本身可以以任意顺序返回。<br>例子 1:<br>Input:<br>accounts = [["John", "johnsmith@mail.com", "john00@mail.com"], ["John", "johnnybravo@mail.com"], ["John", "johnsmith@mail.com", "john_newyork@mail.com"], ["Mary", "mary@mail.com"]]<br>Output: [["John", 'john00@mail.com', 'john_newyork@mail.com', 'johnsmith@mail.com'],  ["John", "johnnybravo@mail.com"], ["Mary", "mary@mail.com"]]<br>Explanation:<br>第一个和第三个 John 是同一个人，因为他们有共同的电子邮件 "johnsmith@mail.com"。<br>第二个 John 和 Mary 是不同的人，因为他们的电子邮件地址没有被其他帐户使用。<br>我们可以以任何顺序返回这些列表，例如答案[['Mary'，'mary@mail.com']，['John'，'johnnybravo@mail.com']，<br>['John'，'john00@mail.com'，'john_newyork@mail.com'，'johnsmith@mail.com']]仍然会被接受。<br>注意：<br>accounts的长度将在[1，1000]的范围内。<br>accounts[i]的长度将在[1，10]的范围内。<br>accounts[i][j]的长度将在[1，30]的范围内。
***

```python
todo
```
#### 第733题	**图像渲染	简单	**
***
有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。<br>给你一个坐标 (sr, sc) 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 newColor，让你重新上色这幅图像。<br>为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。<br>最后返回经过上色渲染后的图像。<br>示例 1:<br>输入:<br>image = [[1,1,1],[1,1,0],[1,0,1]]<br>sr = 1, sc = 1, newColor = 2<br>输出: [[2,2,2],[2,2,0],[2,0,1]]<br>解析:<br>在图像的正中间，(坐标(sr,sc)=(1,1)),<br>在路径上所有符合条件的像素点的颜色都被更改成2。<br>注意，右下角的像素没有更改为2，<br>因为它不是在上下左右四个方向上与初始点相连的像素点。<br>注意:<br>image 和 image[0] 的长度在范围 [1, 50] 内。<br>给出的初始点将满足 0 <= sr < image.length 和 0 <= sc < image[0].length。<br>image[i][j] 和 newColor 表示的颜色值在范围 [0, 65535]内。
***

```python
todo
```
#### 第743题	**网络延迟时间	中等	**
***
有 N 个网络节点，标记为 1 到 N。<br>给定一个列表 times，表示信号经过有向边的传递时间。 times[i] = (u, v, w)，其中 u 是源节点，v 是目标节点， w 是一个信号从源节点传递到目标节点的时间。<br>现在，我们向当前的节点 K 发送了一个信号。需要多久才能使所有节点都收到信号？如果不能使所有节点收到信号，返回 -1。<br>注意:<br>N 的范围在 [1, 100] 之间。<br>K 的范围在 [1, N] 之间。<br>times 的长度在 [1, 6000] 之间。<br>所有的边 times[i] = (u, v, w) 都有 1 <= u, v <= N 且 0 <= w <= 100。
***

```python
todo
```
#### 第749题	**隔离病毒	困难	**
***
病毒扩散得很快，现在你的任务是尽可能地通过安装防火墙来隔离病毒。<br>假设世界由二维矩阵组成，0 表示该区域未感染病毒，而 1 表示该区域已感染病毒。可以在任意 2 个四方向相邻单元之间的共享边界上安装一个防火墙（并且只有一个防火墙）。<br>每天晚上，病毒会从被感染区域向相邻未感染区域扩散，除非被防火墙隔离。现由于资源有限，每天你只能安装一系列防火墙来隔离其中一个被病毒感染的区域（一个区域或连续的一片区域），且该感染区域对未感染区域的威胁最大且保证唯一。<br>你需要努力使得最后有部分区域不被病毒感染，如果可以成功，那么返回需要使用的防火墙个数; 如果无法实现，则返回在世界被病毒全部感染时已安装的防火墙个数。<br>示例 1：<br>输入: grid =<br>[[0,1,0,0,0,0,0,1],<br>[0,1,0,0,0,0,0,1],<br>[0,0,0,0,0,0,0,1],<br>[0,0,0,0,0,0,0,0]]<br>输出: 10<br>说明:<br>一共有两块被病毒感染的区域: 从左往右第一块需要 5 个防火墙，同时若该区域不隔离，晚上将感染 5 个未感染区域（即被威胁的未感染区域个数为 5）;<br>第二块需要 4 个防火墙，同理被威胁的未感染区域个数是 4。因此，第一天先隔离左边的感染区域，经过一晚后，病毒传播后世界如下:<br>[[0,1,0,0,0,0,1,1],<br>[0,1,0,0,0,0,1,1],<br>[0,0,0,0,0,0,1,1],<br>[0,0,0,0,0,0,0,1]]<br>第二题，只剩下一块未隔离的被感染的连续区域，此时需要安装 5 个防火墙，且安装完毕后病毒隔离任务完成。<br>示例 2：<br>输入: grid =<br>[[1,1,1],<br>[1,0,1],<br>[1,1,1]]<br>输出: 4<br>说明:<br>此时只需要安装 4 面防火墙，就有一小区域可以幸存，不被病毒感染。<br>注意不需要在世界边界建立防火墙。<br>示例 3:<br>输入: grid =<br>[[1,1,1,0,0,0,0,0,0],<br>[1,0,1,0,1,1,1,1,1],<br>[1,1,1,0,0,0,0,0,0]]<br>输出: 13<br>说明:<br>在隔离右边感染区域后，隔离左边病毒区域只需要 2 个防火墙了。<br>说明:<br>grid 的行数和列数范围是 [1, 50]。<br>grid[i][j] 只包含 0 或 1 。<br>题目保证每次选取感染区域进行隔离时，一定存在唯一一个对未感染区域的威胁最大的区域。
***

```python
todo
```
#### 第753题	**破解保险箱	困难	**
***
有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。<br>你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。<br>举个例子，假设密码是 "345"，你可以输入 "012345" 来打开它，只是你输入了 6 个字符.<br>请返回一个能打开保险箱的最短字符串。<br>示例1:<br>输入: n = 1, k = 2<br>输出: "01"<br>说明: "10"也可以打开保险箱。<br>示例2:<br>输入: n = 2, k = 2<br>输出: "00110"<br>说明: "01100", "10011", "11001" 也能打开保险箱。<br>提示：<br>n 的范围是 [1, 4]。<br>k 的范围是 [1, 10]。<br>k^n 最大可能为 4096。
***

```python
todo
```
#### 第756题	**金字塔转换矩阵	中等	**
***
现在，我们用一些方块来堆砌一个金字塔。 每个方块用仅包含一个字母的字符串表示。<br>使用三元组表示金字塔的堆砌规则如下：<br>对于三元组(A, B, C) ，“C”为顶层方块，方块“A”、“B”分别作为方块“C”下一层的的左、右子块。当且仅当(A, B, C)是被允许的三元组，我们才可以将其堆砌上。<br>初始时，给定金字塔的基层 bottom，用一个字符串表示。一个允许的三元组列表 allowed，每个三元组用一个长度为 3 的字符串表示。<br>如果可以由基层一直堆到塔尖就返回 true，否则返回 false。<br>示例 1:<br>输入: bottom = "BCD", allowed = ["BCG", "CDE", "GEA", "FFF"]<br>输出: true<br>解析:<br>可以堆砌成这样的金字塔:<br>A<br>/ \<br>G   E<br>/ \ / \<br>B   C   D<br><br>因为符合('B', 'C', 'G'), ('C', 'D', 'E') 和 ('G', 'E', 'A') 三种规则。<br>示例 2:<br>输入: bottom = "AABA", allowed = ["AAA", "AAB", "ABA", "ABB", "BAC"]<br>输出: false<br>解析:<br>无法一直堆到塔尖。<br>注意, 允许存在像 (A, B, C) 和 (A, B, D) 这样的三元组，其中 C != D。<br>注意：<br>bottom 的长度范围在 [2, 8]。<br>allowed 的长度范围在[0, 200]。<br>方块的标记字母范围为{'A', 'B', 'C', 'D', 'E', 'F', 'G'}。
***

```python
todo
```
#### 第778题	**水位上升的泳池中游泳	困难	**
***
在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。<br>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。<br>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？<br>示例 1:<br>输入: [[0,2],[1,3]]<br>输出: 3<br>解释:<br>时间为0时，你位于坐标方格的位置为 (0, 0)。<br>此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。<br><br>等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置<br>示例2:<br>输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br>输入: 16<br>解释:<br>0  1  2  3  4<br>24 23 22 21  5<br>12 13 14 15 16<br>11 17 18 19 20<br>10  9  8  7  6<br><br>最终的路线用加粗进行了标记。<br>我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的<br>提示:<br>2 <= N <= 50.<br>grid[i][j] 位于区间 [0, ..., N*N - 1] 内。
***

```python
todo
```
#### 第785题	**判断二分图	中等	**
***
给定一个无向图graph，当这个图为二分图时返回true。<br>如果我们能将一个图的节点集合分割成两个独立的子集A和B，并使图中的每一条边的两个节点一个来自A集合，一个来自B集合，我们就将这个图称为二分图。<br>graph将会以邻接表方式给出，graph[i]表示图中与节点i相连的所有节点。每个节点都是一个在0到graph.length-1之间的整数。这图中没有自环和平行边： graph[i] 中不存在i，并且graph[i]中没有重复的值。<br>示例 1:<br>输入: [[1,3], [0,2], [1,3], [0,2]]<br>输出: true<br>解释:<br>无向图如下:<br>0----1<br>|    |<br>|    |<br>3----2<br>我们可以将节点分成两组: {0, 2} 和 {1, 3}。<br>示例 2:<br>输入: [[1,2,3], [0,2], [0,1,3], [0,2]]<br>输出: false<br>解释:<br>无向图如下:<br>0----1<br>| \  |<br>|  \ |<br>3----2<br>我们不能将节点分割成两个独立的子集。<br>注意:<br>graph 的长度范围为 [1, 100]。<br>graph[i] 中的元素的范围为 [0, graph.length - 1]。<br>graph[i] 不会包含 i 或者有重复的值。<br>图是无向的: 如果j 在 graph[i]里边, 那么 i 也会在 graph[j]里边。
***

```python
todo
```
