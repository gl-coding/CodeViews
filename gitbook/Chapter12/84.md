# 第8节

#### 第736题	**Lisp 语法解析	困难	**
***
给定一个类似 Lisp 语句的表达式 expression，求出其计算结果。<br>表达式语法如下所示:<br>表达式可以为整数，let 语法，add 语法，mult 语法。表达式的结果总是一个整数。<br>(整数可以是正整数、负整数、0)<br>let 语法表示为 (let v1 e1 v2 e2 ... vn en expr), 其中 let语法总是以字符串 "let"来表示，接下来会跟随一个或多个交替变量或表达式，也就是说，第一个变量 v1被分配为表达式 e1 的值，第二个变量 v2 被分配为表达式 e2 的值，以此类推；最终 let 语法的值为 expr表达式的值。<br>add语法表示为 (add e1 e2)，其中 add 语法总是以字符串 "add"来表示，该语法总是有两个表达式e1、e2, 该语法的最终结果是 e1 表达式的值与 e2 表达式的值之和。<br>mult语法表示为 (mult e1 e2) ，其中 mult 语法总是以字符串"mult"表示， 该语法总是有两个表达式 e1、e2，该语法的最终结果是 e1 表达式的值与 e2 表达式的值之积。<br>在该题目中，变量的命名以小写字符开始，之后跟随0个或多个小写字符或数字。为了方便，"add"，"let"，"mult"会被定义为"关键字"，不会在表达式的变量命名中出现。<br>最后，要说一下范围的概念。在做计算时，需要注意优先级，在最内层(根据括号)的表达式的值应该先计算,然后依次计算外层的表达式。我们将保证每一个测试的表达式都是合法的。有关范围的更多详细信息，请参阅示例。<br>示例:<br>输入: (add 1 2)<br>输出: 3<br><br>输入: (mult 3 (add 2 3))<br>输出: 15<br><br>输入: (let x 2 (mult x 5))<br>输出: 10<br><br>输入: (let x 2 (mult x (let x 3 y 4 (add x y))))<br>输出: 14<br>解释:<br>表达式 (add x y), 在获取 x 值时, 我们应当由最内层依次向外计算, 首先遇到了 x=3, 所以此处的 x 值是 3.<br><br><br>输入: (let x 3 x 2 x)<br>输出: 2<br>解释: let 语句中的赋值运算按顺序处理即可<br><br>输入: (let x 1 y 2 x (add x y) (add x y))<br>输出: 5<br>解释:<br>第一个 (add x y) 计算结果是 3，并且将此值赋给了 x 。<br>第二个 (add x y) 计算结果就是 3+2 = 5 。<br><br>输入: (let x 2 (add (let x 3 (let x 4 x)) x))<br>输出: 6<br>解释:<br>(let x 4 x) 中的 x 的作用范围仅在()之内。所以最终做加法操作时，x 的值是 2 。<br><br>输入: (let a1 3 b2 (add a1 1) b2)<br>输出: 4<br>解释:<br>变量命名时可以在第一个小写字母后跟随数字.<br>注意:<br>我们给定的 expression 表达式都是格式化后的：表达式前后没有多余的空格，表达式的不同部分(关键字、变量、表达式)之间仅使用一个空格分割，并且在相邻括号之间也没有空格。我们给定的表达式均为合法的且最终结果为整数。<br>我们给定的表达式长度最多为 2000 (表达式也不会为空，因为那不是一个合法的表达式)。<br>最终的结果和中间的计算结果都将是一个 32 位整数。
***

```python
todo
```
#### 第761题	**特殊的二进制序列	困难	**
***
特殊的二进制序列是具有以下两个性质的二进制序列：<br>0 的数量与 1 的数量相等。<br>二进制序列的每一个前缀码中 1 的数量要大于等于 0 的数量。<br>给定一个特殊的二进制序列 S，以字符串形式表示。定义一个操作 为首先选择 S 的两个连续且非空的特殊的子串，然后将它们交换。（两个子串为连续的当且仅当第一个子串的最后一个字符恰好为第二个子串的第一个字符的前一个字符。)<br>在任意次数的操作之后，交换后的字符串按照字典序排列的最大的结果是什么？<br>示例 1:<br>输入: S = "11011000"<br>输出: "11100100"<br>解释:<br>将子串 "10" （在S[1]出现） 和 "1100" （在S[3]出现）进行交换。<br>这是在进行若干次操作后按字典序排列最大的结果。<br>说明:<br>S 的长度不超过 50。<br>S 保证为一个满足上述定义的特殊 的二进制序列。
***

```python
todo
```
#### 第767题	**重构字符串	中等	**
***
给定一个字符串S，检查是否能重新排布其中的字母，使得两相邻的字符不同。<br>若可行，输出任意可行的结果。若不可行，返回空字符串。<br>示例 1:<br>输入: S = "aab"<br>输出: "aba"<br>示例 2:<br>输入: S = "aaab"<br>输出: ""<br>注意:<br>S 只包含小写字母并且长度在[1, 500]区间内。
***

```python
todo
```
#### 第770题	**基本计算器 IV	困难	**
***
给定一个表达式 expression 如 expression = "e + 8 - a + 5" 和一个求值映射，如 {"e": 1}（给定的形式为 evalvars = ["e"] 和 evalints = [1]），返回表示简化表达式的标记列表，例如 ["-1*a","14"]<br>表达式交替使用块和符号，每个块和符号之间有一个空格。<br>块要么是括号中的表达式，要么是变量，要么是非负整数。<br>块是括号中的表达式，变量或非负整数。<br>变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像 "2x" 或 "-x" 这样的前导系数或一元运算符 。<br>表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。例如，expression = "1 + 2 * 3" 的答案是 ["7"]。<br>输出格式如下：<br>对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。例如，我们永远不会写像 “b*a*c” 这样的项，只写 “a*b*c”。<br>项的次数等于被乘的自变量的数目，并计算重复项。(例如，"a*a*b*c" 的次数为 4。)。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。<br>项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。<br>格式良好的一个示例答案是 ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"] 。<br>系数为 0 的项（包括常数项）不包括在内。例如，“0” 的表达式输出为 []。<br>示例：<br>输入：expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]<br>输出：["-1*a","14"]<br><br>输入：expression = "e - 8 + temperature - pressure",<br>evalvars = ["e", "temperature"], evalints = [1, 12]<br>输出：["-1*pressure","5"]<br><br>输入：expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []<br>输出：["1*e*e","-64"]<br><br>输入：expression = "7 - 7", evalvars = [], evalints = []<br>输出：[]<br><br>输入：expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = []<br>输出：["5*a*b*c"]<br><br>输入：expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))",<br>evalvars = [], evalints = []<br>输出：["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]<br>提示：<br>expression 的长度在 [1, 250] 范围内。<br>evalvars, evalints 在范围 [0, 100] 内，且长度相同。
***

```python
todo
```
#### 第788题	**旋转数字	简单	**
***
我们称一个数 X 为好数, 如果它的每位数字逐个地被旋转 180 度后，我们仍可以得到一个有效的，且和 X 不同的数。要求每位数字都要被旋转。<br>如果一个数的每位数字被旋转以后仍然还是一个数字， 则这个数是有效的。0, 1, 和 8 被旋转后仍然是它们自己；2 和 5 可以互相旋转成对方；6 和 9 同理，除了这些以外其他的数字旋转以后都不再是有效的数字。<br>现在我们有一个正整数 N, 计算从 1 到 N 中有多少个数 X 是好数？<br>示例:<br>输入: 10<br>输出: 4<br>解释:<br>在[1, 10]中有四个好数： 2, 5, 6, 9。<br>注意 1 和 10 不是好数, 因为他们在旋转之后不变。<br>注意:<br>N 的取值范围是 [1, 10000]。
***

```python
todo
```
#### 第791题	**自定义字符串排序	中等	**
***
字符串S和 T 只包含小写字符。在S中，所有字符只会出现一次。<br>S 已经根据某种规则进行了排序。我们要根据S中的字符顺序对T进行排序。更具体地说，如果S中x在y之前出现，那么返回的字符串中x也应出现在y之前。<br>返回任意一种符合条件的字符串T。<br>示例:<br>输入:<br>S = "cba"<br>T = "abcd"<br>输出: "cbad"<br>解释:<br>S中出现了字符 "a", "b", "c", 所以 "a", "b", "c" 的顺序应该是 "c", "b", "a".<br>由于 "d" 没有在S中出现, 它可以放在T的任意位置. "dcba", "cdba", "cbda" 都是合法的输出。<br>注意:<br>S的最大长度为26，其中没有重复的字符。<br>T的最大长度为200。<br>S和T只包含小写字符。
***

```python
todo
```
#### 第804题	**唯一摩尔斯密码词	简单	**
***
国际摩尔斯密码定义一种标准编码方式，将每个字母对应于一个由一系列点和短线组成的字符串， 比如: "a" 对应 ".-", "b" 对应 "-...", "c" 对应 "-.-.", 等等。<br>为了方便，所有26个英文字母对应摩尔斯密码表如下：<br>[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."]<br>给定一个单词列表，每个单词可以写成每个字母对应摩尔斯密码的组合。例如，"cab" 可以写成 "-.-..--..."，(即 "-.-." + "-..." + ".-"字符串的结合)。我们将这样一个连接过程称作单词翻译。<br>返回我们可以获得所有词不同单词翻译的数量。<br>例如:<br>输入: words = ["gin", "zen", "gig", "msg"]<br>输出: 2<br>解释:<br>各单词翻译如下:<br>"gin" -> "--...-."<br>"zen" -> "--...-."<br>"gig" -> "--...--."<br>"msg" -> "--...--."<br><br>共有 2 种不同翻译, "--...-." 和 "--...--.".<br>注意:<br>单词列表words 的长度不会超过 100。<br>每个单词 words[i]的长度范围为 [1, 12]。<br>每个单词 words[i]只包含小写字母。
***

```python
todo
```
#### 第809题	**情感丰富的文字	中等	**
***
有时候人们会用重复写一些字母来表示额外的感受，比如 "hello" -> "heeellooo", "hi" -> "hiii"。我们将相邻字母都相同的一串字符定义为相同字母组，例如："h", "eee", "ll", "ooo"。<br>对于一个给定的字符串 S ，如果另一个单词能够通过将一些字母组扩张从而使其和 S 相同，我们将这个单词定义为可扩张的（stretchy）。扩张操作定义如下：选择一个字母组（包含字母 c ），然后往其中添加相同的字母 c 使其长度达到 3 或以上。<br>例如，以 "hello" 为例，我们可以对字母组 "o" 扩张得到 "hellooo"，但是无法以同样的方法得到 "helloo" 因为字母组 "oo" 长度小于 3。此外，我们可以进行另一种扩张 "ll" -> "lllll" 以获得 "helllllooo"。如果 S = "helllllooo"，那么查询词 "hello" 是可扩张的，因为可以对它执行这两种扩张操作使得 query = "hello" -> "hellooo" -> "helllllooo" = S。<br>输入一组查询单词，输出其中可扩张的单词数量。<br>示例：<br>输入：<br>S = "heeellooo"<br>words = ["hello", "hi", "helo"]<br>输出：1<br>解释：<br>我们能通过扩张 "hello" 的 "e" 和 "o" 来得到 "heeellooo"。<br>我们不能通过扩张 "helo" 来得到 "heeellooo" 因为 "ll" 的长度小于 3 。<br>说明：<br>0 <= len(S) <= 100。<br>0 <= len(words) <= 100。<br>0 <= len(words[i]) <= 100。<br>S 和所有在 words 中的单词都只由小写字母组成。
***

```python
todo
```
#### 第816题	**模糊坐标	中等	**
***
我们有一些二维坐标，如 "(1, 3)" 或 "(2, 0.5)"，然后我们移除所有逗号，小数点和空格，得到一个字符串S。返回所有可能的原始字符串到一个列表中。<br>原始的坐标表示法不会存在多余的零，所以不会出现类似于"00", "0.0", "0.00", "1.0", "001", "00.01"或一些其他更小的数来表示坐标。此外，一个小数点前至少存在一个数，所以也不会出现“.1”形式的数字。<br>最后返回的列表可以是任意顺序的。而且注意返回的两个数字中间（逗号之后）都有一个空格。<br>示例 1:<br>输入: "(123)"<br>输出: ["(1, 23)", "(12, 3)", "(1.2, 3)", "(1, 2.3)"]<br>示例 2:<br>输入: "(00011)"<br>输出:  ["(0.001, 1)", "(0, 0.011)"]<br>解释:<br>0.0, 00, 0001 或 00.01 是不被允许的。<br>示例 3:<br>输入: "(0123)"<br>输出: ["(0, 123)", "(0, 12.3)", "(0, 1.23)", "(0.1, 23)", "(0.1, 2.3)", "(0.12, 3)"]<br>示例 4:<br>输入: "(100)"<br>输出: [(10, 0)]<br>解释:<br>1.0 是不被允许的。<br>提示:<br>4 <= S.length <= 12.<br>S[0] = "(", S[S.length - 1] = ")", 且字符串 S 中的其他元素都是数字。
***

```python
todo
```
#### 第819题	**最常见的单词	简单	**
***
给定一个段落 (paragraph) 和一个禁用单词列表 (banned)。返回出现次数最多，同时不在禁用列表中的单词。题目保证至少有一个词不在禁用列表中，而且答案唯一。<br>禁用列表中的单词用小写字母表示，不含标点符号。段落中的单词不区分大小写。答案都是小写字母。<br>示例：<br>输入:<br>paragraph = "Bob hit a ball, the hit BALL flew far after it was hit."<br>banned = ["hit"]<br>输出: "ball"<br>解释:<br>"hit" 出现了3次，但它是一个禁用的单词。<br>"ball" 出现了2次 (同时没有其他单词出现2次)，所以它是段落里出现次数最多的，且不在禁用列表中的单词。<br>注意，所有这些单词在段落里不区分大小写，标点符号需要忽略（即使是紧挨着单词也忽略， 比如 "ball,"），<br>"hit"不是最终的答案，虽然它出现次数更多，但它在禁用单词列表中。<br>说明：<br>1 <= 段落长度 <= 1000.<br>1 <= 禁用单词个数 <= 100.<br>1 <= 禁用单词长度 <= 10.<br>答案是唯一的, 且都是小写字母 (即使在 paragraph 里是大写的，即使是一些特定的名词，答案都是小写的。)<br>paragraph 只包含字母、空格和下列标点符号!?',;.<br>不存在没有连字符或者带有连字符的单词。<br>单词里只包含字母，不会出现省略号或者其他标点符号。
***

```python
todo
```
#### 第824题	**山羊拉丁文	简单	**
***
给定一个由空格分割单词的句子 S。每个单词只包含大写或小写字母。<br>我们要将句子转换为 “Goat Latin”（一种类似于 猪拉丁文 - Pig Latin 的虚构语言）。<br>山羊拉丁文的规则如下：<br>如果单词以元音开头（a, e, i, o, u），在单词后添加"ma"。<br>例如，单词"apple"变为"applema"。<br><br>如果单词以辅音字母开头（即非元音字母），移除第一个字符并将它放到末尾，之后再添加"ma"。<br>例如，单词"goat"变为"oatgma"。<br><br>根据单词在句子中的索引，在单词最后添加与索引相同数量的字母'a'，索引从1开始。<br>例如，在第一个单词后添加"a"，在第二个单词后添加"aa"，以此类推。<br>返回将 S 转换为山羊拉丁文后的句子。<br>示例 1:<br>输入: "I speak Goat Latin"<br>输出: "Imaa peaksmaaa oatGmaaaa atinLmaaaaa"<br>示例 2:<br>输入: "The quick brown fox jumped over the lazy dog"<br>输出: "heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa"<br>说明:<br>S 中仅包含大小写字母和空格。单词间有且仅有一个空格。<br>1 <= S.length <= 150。
***

```python
todo
```
#### 第831题	**隐藏个人信息	中等	**
***
给你一条个人信息 string S，它可能是一个邮箱地址，也可能是一个电话号码。<br>我们将隐藏它的隐私信息，通过如下规则:<br><u>1. 电子邮箱</u><br>定义名称 <name> 是长度大于等于 2 （length ≥ 2），并且只包含小写字母 a-z 和大写字母 A-Z 的字符串。<br>电子邮箱地址由名称 <name> 开头，紧接着是符号 <font face="Menlo, Monaco, Consolas, Courier New, monospace">'@'</font>，后面接着一个名称 <name>，再接着一个点号 '.'，然后是一个名称 <name>。<br>电子邮箱地址确定为有效的，并且格式是 "name1@name2.name3"。<br>为了隐藏电子邮箱，所有的名称 <name> 必须被转换成小写的，并且第一个名称 <name> 的第一个字母和最后一个字母的中间的所有字母由 5 个 '*' 代替。<br><u>2. 电话号码</u><br>电话号码是一串包括数字 0-9，以及 {'+', '-', '(', ')', ' '} 这几个字符的字符串。你可以假设电话号码包含 10 到 13 个数字。<br>电话号码的最后 10 个数字组成本地号码，在这之前的数字组成国际号码。注意，国际号码是可选的。我们只暴露最后 4 个数字并隐藏所有其他数字。<br>本地号码是有格式的，并且如 "***-***-1111" 这样显示，这里的 1 表示暴露的数字。<br>为了隐藏有国际号码的电话号码，像 "+111 111 111 1111"，我们以 "+***-***-***-1111" 的格式来显示。在本地号码前面的 '+' 号和第一个 '-' 号仅当电话号码中包含国际号码时存在。例如，一个 12 位的电话号码应当以 "+**-" 开头进行显示。<br>注意：像 "("，")"，" " 这样的不相干的字符以及不符合上述格式的额外的减号或者加号都应当被删除。<br>最后，将提供的信息正确隐藏后返回。<br>示例 1：<br>输入: "LeetCode@LeetCode.com"<br>输出: "l*****e@leetcode.com"<br>解释：<br>所有的名称转换成小写, 第一个名称的第一个字符和最后一个字符中间由 5 个星号代替。<br>因此，"leetcode" -> "l*****e"。<br>示例 2：<br>输入: "AB@qq.com"<br>输出: "a*****b@qq.com"<br>解释:<br>第一个名称"ab"的第一个字符和最后一个字符的中间必须有 5 个星号<br>因此，"ab" -> "a*****b"。<br>示例 3：<br>输入: "1(234)567-890"<br>输出: "***-***-7890"<br>解释:<br>10 个数字的电话号码，那意味着所有的数字都是本地号码。<br>示例 4：<br>输入: "86-(10)12345678"<br>输出: "+**-***-***-5678"<br>解释:<br>12 位数字，2 个数字是国际号码另外 10 个数字是本地号码 。<br>注意:<br>S.length <= 40。<br>邮箱的长度至少是 8。<br>电话号码的长度至少是 10。
***

```python
todo
```
