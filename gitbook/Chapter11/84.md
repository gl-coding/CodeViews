# 第8节

#### 第865题	**具有所有最深结点的最小子树	中等	**
***
给定一个根为 root 的二叉树，每个结点的深度是它到根的最短距离。<br>如果一个结点在整个树的任意结点之间具有最大的深度，则该结点是最深的。<br>一个结点的子树是该结点加上它的所有后代的集合。<br>返回能满足“以该结点为根的子树中包含所有最深的结点”这一条件的具有最大深度的结点。<br>示例：<br>输入：[3,5,1,6,2,0,8,null,null,7,4]<br>输出：[2,7,4]<br>解释：<br><br>我们返回值为 2 的结点，在图中用黄色标记。<br>在图中用蓝色标记的是树的最深的结点。<br>输入 "[3, 5, 1, 6, 2, 0, 8, null, null, 7, 4]" 是对给定的树的序列化表述。<br>输出 "[2, 7, 4]" 是对根结点的值为 2 的子树的序列化表述。<br>输入和输出都具有 TreeNode 类型。<br>提示：<br>树中结点的数量介于 1 和 500 之间。<br>每个结点的值都是独一无二的。
***

```python
todo
```
#### 第872题	**叶子相似的树	简单	**
***
请考虑一颗二叉树上所有的叶子，这些叶子的值按从左到右的顺序排列形成一个 叶值序列 。<br>举个例子，如上图所示，给定一颗叶值序列为 (6, 7, 4, 9, 8) 的树。<br>如果有两颗二叉树的叶值序列是相同，那么我们就认为它们是 叶相似 的。<br>如果给定的两个头结点分别为 root1 和 root2 的树是叶相似的，则返回 true；否则返回 false 。<br>提示：<br>给定的两颗树可能会有 1 到 100 个结点。
***

```python
todo
```
#### 第889题	**根据前序和后序遍历构造二叉树	中等	**
***
返回与给定的前序和后序遍历匹配的任何二叉树。<br>pre 和 post 遍历中的值是不同的正整数。<br>示例：<br>输入：pre = [1,2,4,5,3,6,7], post = [4,5,2,6,7,3,1]<br>输出：[1,2,3,4,5,6,7]<br>提示：<br>1 <= pre.length == post.length <= 30<br>pre[] 和 post[] 都是 1, 2, ..., pre.length 的排列<br>每个输入保证至少有一个答案。如果有多个答案，可以返回其中一个。
***

```python
todo
```
#### 第894题	**所有可能的满二叉树	中等	**
***
满二叉树是一类二叉树，其中每个结点恰好有 0 或 2 个子结点。<br>返回包含 N 个结点的所有可能满二叉树的列表。 答案的每个元素都是一个可能树的根结点。<br>答案中每个树的每个结点都必须有 node.val=0。<br>你可以按任何顺序返回树的最终列表。<br>示例：<br>输入：7<br>输出：[[0,0,0,null,null,0,0,null,null,0,0],[0,0,0,null,null,0,0,0,0],[0,0,0,0,0,0,0],[0,0,0,0,0,null,null,null,null,0,0],[0,0,0,0,0,null,null,0,0]]<br>解释：<br>提示：<br>1 <= N <= 20
***

```python
todo
```
#### 第897题	**递增顺序查找树	简单	**
***
给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。<br>示例 ：<br>输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]<br><br>5<br>/ \<br>3    6<br>/ \    \<br>2   4    8<br>/        / \<br>1        7   9<br><br>输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]<br><br>1<br>\<br>2<br>\<br>3<br>\<br>4<br>\<br>5<br>\<br>6<br>\<br>7<br>\<br>8<br>\<br>9<br>提示：<br>给定树中的结点数介于 1 和 100 之间。<br>每个结点都有一个从 0 到 1000 范围内的唯一整数值。
***

```python
todo
```
#### 第919题	**完全二叉树插入器	中等	**
***
完全二叉树是每一层（除最后一层外）都是完全填充（即，结点数达到最大）的，并且所有的结点都尽可能地集中在左侧。<br>设计一个用完全二叉树初始化的数据结构 CBTInserter，它支持以下几种操作：<br>CBTInserter(TreeNode root) 使用头结点为 root 的给定树初始化该数据结构；<br>CBTInserter.insert(int v) 将 TreeNode 插入到存在值为 node.val = v  的树中以使其保持完全二叉树的状态，并返回插入的 TreeNode 的父结点的值；<br>CBTInserter.get_root() 将返回树的头结点。<br>示例 1：<br>输入：inputs = ["CBTInserter","insert","get_root"], inputs = [[[1]],[2],[]]<br>输出：[null,1,[1,2]]<br>示例 2：<br>输入：inputs = ["CBTInserter","insert","insert","get_root"], inputs = [[[1,2,3,4,5,6]],[7],[8],[]]<br>输出：[null,3,4,[1,2,3,4,5,6,7,8]]<br>提示：<br>最初给定的树是完全二叉树，且包含 1 到 1000 个结点。<br>每个测试用例最多调用 CBTInserter.insert  操作 10000 次。<br>给定结点或插入结点的每个值都在 0 到 5000 之间。
***

```python
todo
```
#### 第938题	**二叉搜索树的范围和	简单	**
***
给定二叉搜索树的根结点 root，返回 L 和 R（含）之间的所有结点的值的和。<br>二叉搜索树保证具有唯一的值。<br>示例 1：<br>输入：root = [10,5,15,3,7,null,18], L = 7, R = 15<br>输出：32<br>示例 2：<br>输入：root = [10,5,15,3,7,13,18,1,null,6], L = 6, R = 10<br>输出：23<br>提示：<br>树中的结点数量最多为 10000 个。<br>最终的答案保证小于 2^31。
***

```python
todo
```
#### 第951题	**翻转等价二叉树	中等	**
***
我们可以为二叉树 T 定义一个翻转操作，如下所示：选择任意节点，然后交换它的左子树和右子树。<br>只要经过一定次数的翻转操作后，能使 X 等于 Y，我们就称二叉树 X 翻转等价于二叉树 Y。<br>编写一个判断两个二叉树是否是翻转等价的函数。这些树由根节点 root1 和 root2 给出。<br>示例：<br>输入：root1 = [1,2,3,4,5,6,null,null,null,7,8], root2 = [1,3,2,null,6,4,5,null,null,null,null,8,7]<br>输出：true<br>解释：We flipped at nodes with values 1, 3, and 5.<br>提示：<br>每棵树最多有 100 个节点。<br>每棵树中的每个值都是唯一的、在 [0, 99] 范围内的整数。
***

```python
todo
```
#### 第958题	**二叉树的完全性检验	中等	**
***
给定一个二叉树，确定它是否是一个完全二叉树。<br>百度百科中对完全二叉树的定义如下：<br>若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树。（注：第 h 层可能包含 1~ 2h 个节点。）<br>示例 1：<br>输入：[1,2,3,4,5,6]<br>输出：true<br>解释：最后一层前的每一层都是满的（即，结点值为 {1} 和 {2,3} 的两层），且最后一层中的所有结点（{4,5,6}）都尽可能地向左。<br>示例 2：<br>输入：[1,2,3,4,5,null,7]<br>输出：false<br>解释：值为 7 的结点没有尽可能靠向左侧。<br>提示：<br>树中将会有 1 到 100 个结点。
***

```python
todo
```
#### 第965题	**单值二叉树	简单	**
***
如果二叉树每个节点都具有相同的值，那么该二叉树就是单值二叉树。<br>只有给定的树是单值二叉树时，才返回 true；否则返回 false。<br>示例 1：<br>输入：[1,1,1,1,1,null,1]<br>输出：true<br>示例 2：<br>输入：[2,2,2,5,2]<br>输出：false<br>提示：<br>给定树的节点数范围是 [1, 100]。<br>每个节点的值都是整数，范围为 [0, 99] 。
***

```python
todo
```
#### 第968题	**监控二叉树	困难	**
***
给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。<br>示例 1：<br>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：<br>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br><br>提示：<br>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。
***

```python
todo
```
#### 第971题	**翻转二叉树以匹配先序遍历	中等	**
***
给定一个有 N 个节点的二叉树，每个节点都有一个不同于其他节点且处于 {1, ..., N} 中的值。<br>通过交换节点的左子节点和右子节点，可以翻转该二叉树中的节点。<br>考虑从根节点开始的先序遍历报告的 N 值序列。将这一 N 值序列称为树的行程。<br>（回想一下，节点的先序遍历意味着我们报告当前节点的值，然后先序遍历左子节点，再先序遍历右子节点。）<br>我们的目标是翻转最少的树中节点，以便树的行程与给定的行程 voyage 相匹配。<br>如果可以，则返回翻转的所有节点的值的列表。你可以按任何顺序返回答案。<br>如果不能，则返回列表 [-1]。<br>示例 1：<br>输入：root = [1,2], voyage = [2,1]<br>输出：[-1]<br>示例 2：<br>输入：root = [1,2,3], voyage = [1,3,2]<br>输出：[1]<br>示例 3：<br>输入：root = [1,2,3], voyage = [1,2,3]<br>输出：[]<br>提示：<br>1 <= N <= 100
***

```python
todo
```
