# 第9节

#### 第979题	**在二叉树中分配硬币	中等	**
***
给定一个有 N 个结点的二叉树的根结点 root，树中的每个结点上都对应有 node.val 枚硬币，并且总共有 N 枚硬币。<br>在一次移动中，我们可以选择两个相邻的结点，然后将一枚硬币从其中一个结点移动到另一个结点。(移动可以是从父结点到子结点，或者从子结点移动到父结点。)。<br>返回使每个结点上只有一枚硬币所需的移动次数。<br>示例 1：<br>输入：[3,0,0]<br>输出：2<br>解释：从树的根结点开始，我们将一枚硬币移到它的左子结点上，一枚硬币移到它的右子结点上。<br>示例 2：<br>输入：[0,3,0]<br>输出：3<br>解释：从根结点的左子结点开始，我们将两枚硬币移到根结点上 [移动两次]。然后，我们把一枚硬币从根结点移到右子结点上。<br>示例 3：<br>输入：[1,0,2]<br>输出：2<br>示例 4：<br>输入：[1,0,0,null,3]<br>输出：4<br>提示：<br>1<= N <= 100<br>0 <= node.val <= N
***

```python
todo
```
#### 第987题	**二叉树的垂序遍历	中等	**
***
给定二叉树，按垂序遍历返回其结点值。<br>对位于 (X, Y) 的每个结点而言，其左右子结点分别位于 (X-1, Y-1) 和 (X+1, Y-1)。<br>把一条垂线从 X = -infinity 移动到 X = +infinity ，每当该垂线与结点接触时，我们按从上到下的顺序报告结点的值（ Y 坐标递减）。<br>如果两个结点位置相同，则首先报告的结点值较小。<br>按 X 坐标顺序返回非空报告的列表。每个报告都有一个结点值列表。<br>示例 1：<br>输入：[3,9,20,null,null,15,7]<br>输出：[[9],[3,15],[20],[7]]<br>解释：<br>在不丧失其普遍性的情况下，我们可以假设根结点位于 (0, 0)：<br>然后，值为 9 的结点出现在 (-1, -1)；<br>值为 3 和 15 的两个结点分别出现在 (0, 0) 和 (0, -2)；<br>值为 20 的结点出现在 (1, -1)；<br>值为 7 的结点出现在 (2, -2)。<br>示例 2：<br>输入：[1,2,3,4,5,6,7]<br>输出：[[4],[2],[1,5,6],[3],[7]]<br>解释：<br>根据给定的方案，值为 5 和 6 的两个结点出现在同一位置。<br>然而，在报告 "[1,5,6]" 中，结点值 5 排在前面，因为 5 小于 6。<br>提示：<br>树的结点数介于 1 和 1000 之间。<br>每个结点值介于 0 和 1000 之间。
***

```python
todo
```
#### 第988题	**从叶结点开始的最小字符串	中等	**
***
给定一颗根结点为 root 的二叉树，书中的每个结点都有一个从 0 到 25 的值，分别代表字母 'a' 到 'z'：值 0 代表 'a'，值 1 代表 'b'，依此类推。<br>找出按字典序最小的字符串，该字符串从这棵树的一个叶结点开始，到根结点结束。<br>（小贴士：字符串中任何较短的前缀在字典序上都是较小的：例如，在字典序上 "ab" 比 "aba" 要小。叶结点是指没有子结点的结点。）<br>示例 1：<br>输入：[0,1,2,3,4,3,4]<br>输出："dba"<br>示例 2：<br>输入：[25,1,3,1,3,0,2]<br>输出："adz"<br>示例 3：<br>输入：[2,2,1,null,1,0,null,0]<br>输出："abc"<br>提示：<br>给定树的结点数介于 1 和 8500 之间。<br>树中的每个结点都有一个介于 0 和 25 之间的值。
***

```python
todo
```
#### 第993题	**二叉树的堂兄弟节点	简单	**
***
在二叉树中，根节点位于深度 0 处，每个深度为 k 的节点的子节点位于深度 k+1 处。<br>如果二叉树的两个节点深度相同，但父节点不同，则它们是一对堂兄弟节点。<br>我们给出了具有唯一值的二叉树的根节点 root，以及树中两个不同节点的值 x 和 y。<br>只有与值 x 和 y 对应的节点是堂兄弟节点时，才返回 true。否则，返回 false。<br>示例 1：<br>输入：root = [1,2,3,4], x = 4, y = 3<br>输出：false<br>示例 2：<br>输入：root = [1,2,3,null,4,null,5], x = 5, y = 4<br>输出：true<br>示例 3：<br>输入：root = [1,2,3,null,4], x = 2, y = 3<br>输出：false<br>提示：<br>二叉树的节点数介于 2 到 100 之间。<br>每个节点的值都是唯一的、范围为 1 到 100 的整数。
***

```python
todo
```
#### 第998题	**最大二叉树 II	中等	**
***
最大树定义：一个树，其中每个节点的值都大于其子树中的任何其他值。<br>给出最大树的根节点 root。<br>就像之前的问题那样，给定的树是从表 A（root = Construct(A)）递归地使用下述 Construct(A) 例程构造的：<br>如果 A 为空，返回 null<br>否则，令 A[i] 作为 A 的最大元素。创建一个值为 A[i] 的根节点 root<br>root 的左子树将被构建为 Construct([A[0], A[1], ..., A[i-1]])<br>root 的右子树将被构建为 Construct([A[i+1], A[i+2], ..., A[A.length - 1]])<br>返回 root<br>请注意，我们没有直接给定 A，只有一个根节点 root = Construct(A).<br>假设 B 是 A 的副本，并附加值 val。保证 B 中的值是不同的。<br>返回 Construct(B)。<br>示例 1：<br>输入：root = [4,1,3,null,null,2], val = 5<br>输出：[5,4,null,1,3,null,null,2]<br>解释：A = [1,4,2,3], B = [1,4,2,3,5]<br>示例 2：<br>输入：root = [5,2,4,null,1], val = 3<br>输出：[5,2,4,null,1,null,3]<br>解释：A = [2,1,5,4], B = [2,1,5,4,3]<br>示例 3：<br>输入：root = [5,2,3,null,1], val = 4<br>输出：[5,2,4,null,1,3]<br>解释：A = [2,1,5,3], B = [2,1,5,3,4]<br>提示：<br>1 <= B.length <= 100
***

```python
todo
```
#### 第1008题	**先序遍历构造二叉树	中等	**
***
返回与给定先序遍历 preorder 相匹配的二叉搜索树（binary search tree）的根结点。<br>(回想一下，二叉搜索树是二叉树的一种，其每个节点都满足以下规则，对于 node.left 的任何后代，值总 < node.val，而 node.right 的任何后代，值总 > node.val。此外，先序遍历首先显示节点的值，然后遍历 node.left，接着遍历 node.right。）<br>示例：<br>输入：[8,5,1,7,10,12]<br>输出：[8,5,10,1,7,null,12]<br>提示：<br>1 <= preorder.length <= 100<br>先序 preorder 中的值是不同的。
***

```python
todo
```
#### 第1022题	**从根到叶的二进制数之和	简单	**
***
给出一棵二叉树，其上每个结点的值都是 0 或 1 。每一条从根到叶的路径都代表一个从最高有效位开始的二进制数。例如，如果路径为 0 -> 1 -> 1 -> 0 -> 1，那么它表示二进制数 01101，也就是 13 。<br>对树上的每一片叶子，我们都要找出从根到该叶子的路径所表示的数字。<br>以 10^9 + 7 为模，返回这些数字之和。<br>示例：<br>输入：[1,0,1,0,1,0,1]<br>输出：22<br>解释：(100) + (101) + (110) + (111) = 4 + 5 + 6 + 7 = 22<br>提示：<br>树中的结点数介于 1 和 1000 之间。<br>node.val 为 0 或 1 。
***

```python
todo
```
#### 第1026题	**节点与其祖先之间的最大差值	中等	**
***
给定二叉树的根节点 root，找出存在于不同节点 A 和 B 之间的最大值 V，其中 V = |A.val - B.val|，且 A 是 B 的祖先。<br>（如果 A 的任何子节点之一为 B，或者 A 的任何子节点是 B 的祖先，那么我们认为 A 是 B 的祖先）<br>示例：<br>输入：[8,3,10,1,6,null,14,null,null,4,7,13]<br>输出：7<br>解释：<br>我们有大量的节点与其祖先的差值，其中一些如下：<br>|8 - 3| = 5<br>|3 - 7| = 4<br>|8 - 1| = 7<br>|10 - 13| = 3<br>在所有可能的差值中，最大值 7 由 |8 - 1| = 7 得出。<br>提示：<br>树中的节点数在 2 到 5000 之间。<br>每个节点的值介于 0 到 100000 之间。
***

```python
todo
```
#### 第1028题	**从先序遍历还原二叉树	困难	**
***
我们从二叉树的根节点 root 开始进行深度优先搜索。<br>在遍历中的每个节点处，我们输出 D 条短划线（其中 D 是该节点的深度），然后输出该节点的值。（如果节点的深度为 D，则其直接子节点的深度为 D + 1。根节点的深度为 0）。<br>如果节点只有一个子节点，那么保证该子节点为左子节点。<br>给出遍历输出 S，还原树并返回其根节点 root。<br>示例 1：<br>输入："1-2--3--4-5--6--7"<br>输出：[1,2,5,3,4,6,7]<br>示例 2：<br>输入："1-2--3---4-5--6---7"<br>输出：[1,2,5,3,null,6,null,4,null,7]<br>示例 3：<br>输入："1-401--349---90--88"<br>输出：[1,401,null,349,88,90]<br>提示：<br>原始树中的节点数介于 1 和 1000 之间。<br>每个节点的值介于 1 和 10 ^ 9 之间。
***

```python
todo
```
#### 第1104题	**二叉树寻路	中等	**
***
在一棵无限的二叉树上，每个节点都有两个子节点，树中的节点 逐行 依次按 “之” 字形进行标记。<br>如下图所示，在奇数行（即，第一行、第三行、第五行……）中，按从左到右的顺序进行标记；<br>而偶数行（即，第二行、第四行、第六行……）中，按从右到左的顺序进行标记。<br>给你树上某一个节点的标号 label，请你返回从根节点到该标号为 label 节点的路径，该路径是由途经的节点标号所组成的。<br>示例 1：<br>输入：label = 14<br>输出：[1,3,4,14]<br>示例 2：<br>输入：label = 26<br>输出：[1,2,6,10,26]<br>提示：<br>1 <= label <= 10^6
***

```python
todo
```
#### 第1110题	**删点成林	中等	**
***
给出二叉树的根节点 root，树上每个节点都有一个不同的值。<br>如果节点值在 to_delete 中出现，我们就把该节点从树上删去，最后得到一个森林（一些不相交的树构成的集合）。<br>返回森林中的每棵树。你可以按任意顺序组织答案。<br>示例：<br>输入：root = [1,2,3,4,5,6,7], to_delete = [3,5]<br>输出：[[1,2,null,4],[6],[7]]<br>提示：<br>树中的节点数最大为 1000。<br>每个节点都有一个介于 1 到 1000 之间的值，且各不相同。<br>to_delete.length <= 1000<br>to_delete 包含一些从 1 到 1000、各不相同的值。
***

```python
todo
```
#### 第1123题	**最深叶节点的最近公共祖先	中等	**
***
给你一个有根节点的二叉树，找到它最深的叶节点的最近公共祖先。<br>回想一下：<br>叶节点 是二叉树中没有子节点的节点<br>树的根节点的 深度 为 0，如果某一节点的深度为 d，那它的子节点的深度就是 d+1<br>如果我们假定 A 是一组节点 S 的 最近公共祖先，S 中的每个节点都在以 A 为根节点的子树中，且 A 的深度达到此条件下可能的最大值。<br>示例 1：<br>输入：root = [1,2,3]<br>输出：[1,2,3]<br>示例 2：<br>输入：root = [1,2,3,4]<br>输出：[4]<br>示例 3：<br>输入：root = [1,2,3,4,5]<br>输出：[2,4,5]<br>提示：<br>给你的树中将有 1 到 1000 个节点。<br>树中每个节点的值都在 1 到 1000 之间。
***

```python
todo
```
