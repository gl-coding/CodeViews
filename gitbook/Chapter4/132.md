# 第12节

#### 第888题	**公平的糖果交换	简单	**
***
爱丽丝和鲍勃有不同大小的糖果棒：A[i] 是爱丽丝拥有的第 i 块糖的大小，B[j] 是鲍勃拥有的第 j 块糖的大小。<br>因为他们是朋友，所以他们想交换一个糖果棒，这样交换后，他们都有相同的糖果总量。（一个人拥有的糖果总量是他们拥有的糖果棒大小的总和。）<br>返回一个整数数组 ans，其中 ans[0] 是爱丽丝必须交换的糖果棒的大小，ans[1] 是 Bob 必须交换的糖果棒的大小。<br>如果有多个答案，你可以返回其中任何一个。保证答案存在。<br>示例 1：<br>输入：A = [1,1], B = [2,2]<br>输出：[1,2]<br>示例 2：<br>输入：A = [1,2], B = [2,3]<br>输出：[1,2]<br>示例 3：<br>输入：A = [2], B = [1,3]<br>输出：[2,3]<br>示例 4：<br>输入：A = [1,2,5], B = [2,4]<br>输出：[5,4]<br>提示：<br>1 <= A.length <= 10000<br>1 <= B.length <= 10000<br>1 <= A[i] <= 100000<br>1 <= B[i] <= 100000<br>保证爱丽丝与鲍勃的糖果总量不同。<br>答案肯定存在。
***

```python
todo
```
#### 第891题	**子序列宽度之和	困难	**
***
给定一个整数数组 A ，考虑 A 的所有非空子序列。<br>对于任意序列 S ，设 S 的宽度是 S 的最大元素和最小元素的差。<br>返回 A 的所有子序列的宽度之和。<br>由于答案可能非常大，请返回答案模 10^9+7。<br>示例：<br>输入：[2,1,3]<br>输出：6<br>解释：<br>子序列为 [1]，[2]，[3]，[2,1]，[2,3]，[1,3]，[2,1,3] 。<br>相应的宽度是 0，0，0，1，1，2，2 。<br>这些宽度之和是 6 。<br>提示：<br>1 <= A.length <= 20000<br>1 <= A[i] <= 20000
***

```python
todo
```
#### 第896题	**单调数列	简单	**
***
如果数组是单调递增或单调递减的，那么它是单调的。<br>如果对于所有 i <= j，A[i] <= A[j]，那么数组 A 是单调递增的。 如果对于所有 i <= j，A[i]> = A[j]，那么数组 A 是单调递减的。<br>当给定的数组 A 是单调数组时返回 true，否则返回 false。<br>示例 1：<br>输入：[1,2,2,3]<br>输出：true<br>示例 2：<br>输入：[6,5,4,4]<br>输出：true<br>示例 3：<br>输入：[1,3,2]<br>输出：false<br>示例 4：<br>输入：[1,2,4,5]<br>输出：true<br>示例 5：<br>输入：[1,1,1]<br>输出：true<br>提示：<br>1 <= A.length <= 50000<br>-100000 <= A[i] <= 100000
***

```python
todo
```
#### 第900题	**RLE 迭代器	中等	**
***
编写一个遍历游程编码序列的迭代器。<br>迭代器由 RLEIterator(int[] A) 初始化，其中 A 是某个序列的游程编码。更具体地，对于所有偶数 i，A[i] 告诉我们在序列中重复非负整数值 A[i + 1] 的次数。<br>迭代器支持一个函数：next(int n)，它耗尽接下来的  n 个元素（n >= 1）并返回以这种方式耗去的最后一个元素。如果没有剩余的元素可供耗尽，则  next 返回 -1 。<br>例如，我们以 A = [3,8,0,9,2,5] 开始，这是序列 [8,8,8,5,5] 的游程编码。这是因为该序列可以读作 “三个八，零个九，两个五”。<br>示例：<br>输入：["RLEIterator","next","next","next","next"], [[[3,8,0,9,2,5]],[2],[1],[1],[2]]<br>输出：[null,8,8,5,-1]<br>解释：<br>RLEIterator 由 RLEIterator([3,8,0,9,2,5]) 初始化。<br>这映射到序列 [8,8,8,5,5]。<br>然后调用 RLEIterator.next 4次。<br><br>.next(2) 耗去序列的 2 个项，返回 8。现在剩下的序列是 [8, 5, 5]。<br><br>.next(1) 耗去序列的 1 个项，返回 8。现在剩下的序列是 [5, 5]。<br><br>.next(1) 耗去序列的 1 个项，返回 5。现在剩下的序列是 [5]。<br><br>.next(2) 耗去序列的 2 个项，返回 -1。 这是由于第一个被耗去的项是 5，<br>但第二个项并不存在。由于最后一个要耗去的项不存在，我们返回 -1。<br>提示：<br>0 <= A.length <= 1000<br>A.length 是偶数。<br>0 <= A[i] <= 10^9<br>每个测试用例最多调用 1000 次 RLEIterator.next(int n)。<br>每次调用 RLEIterator.next(int n) 都有 1 <= n <= 10^9 。
***

```python
todo
```
#### 第905题	**按奇偶排序数组	简单	**
***
给定一个非负整数数组 A，返回一个数组，在该数组中， A 的所有偶数元素之后跟着所有奇数元素。<br>你可以返回满足此条件的任何数组作为答案。<br>示例：<br>输入：[3,1,2,4]<br>输出：[2,4,3,1]<br>输出 [4,2,3,1]，[2,4,1,3] 和 [4,2,1,3] 也会被接受。<br>提示：<br>1 <= A.length <= 5000<br>0 <= A[i] <= 5000
***

```python
todo
```
#### 第907题	**子数组的最小值之和	中等	**
***
给定一个整数数组 A，找到 min(B) 的总和，其中 B 的范围为 A 的每个（连续）子数组。<br>由于答案可能很大，因此返回答案模 10^9 + 7。<br>示例：<br>输入：[3,1,2,4]<br>输出：17<br>解释：<br>子数组为 [3]，[1]，[2]，[4]，[3,1]，[1,2]，[2,4]，[3,1,2]，[1,2,4]，[3,1,2,4]。<br>最小值为 3，1，2，4，1，1，2，1，1，1，和为 17。<br>提示：<br>1 <= A <= 30000<br>1 <= A[i] <= 30000
***

```python
todo
```
#### 第914题	**卡牌分组	简单	**
***
给定一副牌，每张牌上都写着一个整数。<br>此时，你需要选定一个数字 X，使我们可以将整副牌按下述规则分成 1 组或更多组：<br>每组都有 X 张牌。<br>组内所有的牌上都写着相同的整数。<br>仅当你可选的 X >= 2 时返回 true。<br>示例 1：<br>输入：[1,2,3,4,4,3,2,1]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[3,3]，[4,4]<br>示例 2：<br>输入：[1,1,1,2,2,2,3,3]<br>输出：false<br>解释：没有满足要求的分组。<br>示例 3：<br>输入：[1]<br>输出：false<br>解释：没有满足要求的分组。<br>示例 4：<br>输入：[1,1]<br>输出：true<br>解释：可行的分组是 [1,1]<br>示例 5：<br>输入：[1,1,2,2,2,2]<br>输出：true<br>解释：可行的分组是 [1,1]，[2,2]，[2,2]<br><br>提示：<br>1 <= deck.length <= 10000<br>0 <= deck[i] < 10000
***

```python
todo
```
#### 第915题	**分割数组	中等	**
***
给定一个数组 A，将其划分为两个不相交（没有公共元素）的连续子数组 left 和 right， 使得：<br>left 中的每个元素都小于或等于 right 中的每个元素。<br>left 和 right 都是非空的。<br>left 要尽可能小。<br>在完成这样的分组后返回 left 的长度。可以保证存在这样的划分方法。<br>示例 1：<br>输入：[5,0,3,8,6]<br>输出：3<br>解释：left = [5,0,3]，right = [8,6]<br>示例 2：<br>输入：[1,1,1,0,6,12]<br>输出：4<br>解释：left = [1,1,1,0]，right = [6,12]<br>提示：<br>2 <= A.length <= 30000<br>0 <= A[i] <= 10^6<br>可以保证至少有一种方法能够按题目所描述的那样对 A 进行划分。
***

```python
todo
```
#### 第918题	**环形子数组的最大和	中等	**
***
给定一个由整数数组 A 表示的环形数组 C，求 C 的非空子数组的最大可能和。<br>在此处，环形数组意味着数组的末端将会与开头相连呈环状。（形式上，当0 <= i < A.length 时 C[i] = A[i]，而当 i >= 0 时 C[i+A.length] = C[i]）<br>此外，子数组最多只能包含固定缓冲区 A 中的每个元素一次。（形式上，对于子数组 C[i], C[i+1], ..., C[j]，不存在 i <= k1, k2 <= j 其中 k1 % A.length = k2 % A.length）<br>示例 1：<br>输入：[1,-2,3,-2]<br>输出：3<br>解释：从子数组 [3] 得到最大和 3<br>示例 2：<br>输入：[5,-3,5]<br>输出：10<br>解释：从子数组 [5,5] 得到最大和 5 + 5 = 10<br>示例 3：<br>输入：[3,-1,2,-1]<br>输出：4<br>解释：从子数组 [2,-1,3] 得到最大和 2 + (-1) + 3 = 4<br>示例 4：<br>输入：[3,-2,2,-3]<br>输出：3<br>解释：从子数组 [3] 和 [3,-2,2] 都可以得到最大和 3<br>示例 5：<br>输入：[-2,-3,-1]<br>输出：-1<br>解释：从子数组 [-1] 得到最大和 -1<br>提示：<br>-30000 <= A[i] <= 30000<br>1 <= A.length <= 30000
***

```python
todo
```
#### 第922题	**按奇偶排序数组 II	简单	**
***
给定一个非负整数数组 A， A 中一半整数是奇数，一半整数是偶数。<br>对数组进行排序，以便当 A[i] 为奇数时，i 也是奇数；当 A[i] 为偶数时， i 也是偶数。<br>你可以返回任何满足上述条件的数组作为答案。<br>示例：<br>输入：[4,2,5,7]<br>输出：[4,5,2,7]<br>解释：[4,7,2,5]，[2,5,4,7]，[2,7,4,5] 也会被接受。<br>提示：<br>2 <= A.length <= 20000<br>A.length % 2 == 0<br>0 <= A[i] <= 1000
***

```python
todo
```
#### 第926题	**将字符串翻转到单调递增	中等	**
***
如果一个由 '0' 和 '1' 组成的字符串，是以一些 '0'（可能没有 '0'）后面跟着一些 '1'（也可能没有 '1'）的形式组成的，那么该字符串是单调递增的。<br>我们给出一个由字符 '0' 和 '1' 组成的字符串 S，我们可以将任何 '0' 翻转为 '1' 或者将 '1' 翻转为 '0'。<br>返回使 S 单调递增的最小翻转次数。<br>示例 1：<br>输入："00110"<br>输出：1<br>解释：我们翻转最后一位得到 00111.<br>示例 2：<br>输入："010110"<br>输出：2<br>解释：我们翻转得到 011111，或者是 000111。<br>示例 3：<br>输入："00011000"<br>输出：2<br>解释：我们翻转得到 00000000。<br>提示：<br>1 <= S.length <= 20000<br>S 中只包含字符 '0' 和 '1'
***

```python
todo
```
#### 第941题	**有效的山脉数组	简单	**
***
给定一个整数数组 A，如果它是有效的山脉数组就返回 true，否则返回 false。<br>让我们回顾一下，如果 A 满足下述条件，那么它是一个山脉数组：<br>A.length >= 3<br>在 0 < i < A.length - 1 条件下，存在 i 使得：<br>A[0] < A[1] < ... A[i-1] < A[i]<br>A[i] > A[i+1] > ... > A[B.length - 1]<br>示例 1：<br>输入：[2,1]<br>输出：false<br>示例 2：<br>输入：[3,5,5]<br>输出：false<br>示例 3：<br>输入：[0,3,2,1]<br>输出：true<br>提示：<br>0 <= A.length <= 10000<br>0 <= A[i] <= 10000
***

```python
todo
```
