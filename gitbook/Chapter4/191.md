# 第17节

#### 第1267题	**统计参与通信的服务器	中等	**
***
这里有一幅服务器分布图，服务器的位置标识在 m * n 的整数矩阵网格 grid 中，1 表示单元格上有服务器，0 表示没有。<br>如果两台服务器位于同一行或者同一列，我们就认为它们之间可以进行通信。<br>请你统计并返回能够与至少一台其他服务器进行通信的服务器的数量。<br>示例 1：<br>输入：grid = [[1,0],[0,1]]<br>输出：0<br>解释：没有一台服务器能与其他服务器进行通信。<br>示例 2：<br>输入：grid = [[1,0],[1,1]]<br>输出：3<br>解释：所有这些服务器都至少可以与一台别的服务器进行通信。<br>示例 3：<br>输入：grid = [[1,1,0,0],[0,0,1,0],[0,0,1,0],[0,0,0,1]]<br>输出：4<br>解释：第一行的两台服务器互相通信，第三列的两台服务器互相通信，但右下角的服务器无法与其他服务器通信。<br>提示：<br>m == grid.length<br>n == grid[i].length<br>1 <= m <= 250<br>1 <= n <= 250<br>grid[i][j] == 0 or 1
***

```python
todo
```
#### 第1275题	**找出井字棋的获胜者	简单	**
***
A 和 B 在一个 3 x 3 的网格上玩井字棋。<br>井字棋游戏的规则如下：<br>玩家轮流将棋子放在空方格 (" ") 上。<br>第一个玩家 A 总是用 "X" 作为棋子，而第二个玩家 B 总是用 "O" 作为棋子。<br>"X" 和 "O" 只能放在空方格中，而不能放在已经被占用的方格上。<br>只要有 3 个相同的（非空）棋子排成一条直线（行、列、对角线）时，游戏结束。<br>如果所有方块都放满棋子（不为空），游戏也会结束。<br>游戏结束后，棋子无法再进行任何移动。<br>给你一个数组 moves，其中每个元素是大小为 2 的另一个数组（元素分别对应网格的行和列），它按照 A 和 B 的行动顺序（先 A 后 B）记录了两人各自的棋子位置。<br>如果游戏存在获胜者（A 或 B），就返回该游戏的获胜者；如果游戏以平局结束，则返回 "Draw"；如果仍会有行动（游戏未结束），则返回 "Pending"。<br>你可以假设 moves 都 有效（遵循井字棋规则），网格最初是空的，A 将先行动。<br>示例 1：<br>输入：moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]<br>输出："A"<br>解释："A" 获胜，他总是先走。<br>"X  "    "X  "    "X  "    "X  "    "X  "<br>"   " -> "   " -> " X " -> " X " -> " X "<br>"   "    "O  "    "O  "    "OO "    "OOX"<br>示例 2：<br>输入：moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]<br>输出："B"<br>解释："B" 获胜。<br>"X  "    "X  "    "XX "    "XXO"    "XXO"    "XXO"<br>"   " -> " O " -> " O " -> " O " -> "XO " -> "XO "<br>"   "    "   "    "   "    "   "    "   "    "O  "<br>示例 3：<br>输入：moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]<br>输出："Draw"<br>输出：由于没有办法再行动，游戏以平局结束。<br>"XXO"<br>"OOX"<br>"XOX"<br>示例 4：<br>输入：moves = [[0,0],[1,1]]<br>输出："Pending"<br>解释：游戏还没有结束。<br>"X  "<br>" O "<br>"   "<br>提示：<br>1 <= moves.length <= 9<br>moves[i].length == 2<br>0 <= moves[i][j] <= 2<br>moves 里没有重复的元素。<br>moves 遵循井字棋的规则。
***

```python
todo
```
#### 第1277题	**统计全为 1 的正方形子矩阵	中等	**
***
给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。<br>示例 1：<br>输入：matrix =<br>[<br>[0,1,1,1],<br>[1,1,1,1],<br>[0,1,1,1]<br>]<br>输出：15<br>解释：<br>边长为 1 的正方形有 10 个。<br>边长为 2 的正方形有 4 个。<br>边长为 3 的正方形有 1 个。<br>正方形的总数 = 10 + 4 + 1 = 15.<br>示例 2：<br>输入：matrix =<br>[<br>[1,0,1],<br>[1,1,0],<br>[1,1,0]<br>]<br>输出：7<br>解释：<br>边长为 1 的正方形有 6 个。<br>边长为 2 的正方形有 1 个。<br>正方形的总数 = 6 + 1 = 7.<br>提示：<br>1 <= arr.length <= 300<br>1 <= arr[0].length <= 300<br>0 <= arr[i][j] <= 1
***

```python
todo
```
#### 第1287题	**有序数组中出现次数超过25%的元素	简单	**
***
给你一个非递减的 有序 整数数组，已知这个数组中恰好有一个整数，它的出现次数超过数组元素总数的 25%。<br>请你找到并返回这个整数<br>示例：<br>输入：arr = [1,2,2,6,6,6,6,7,10]<br>输出：6<br>提示：<br>1 <= arr.length <= 10^4<br>0 <= arr[i] <= 10^5
***

```python
todo
```
#### 第1292题	**元素和小于等于阈值的正方形的最大边长	中等	**
***
给你一个大小为 m x n 的矩阵 mat 和一个整数阈值 threshold。<br>请你返回元素总和小于或等于阈值的正方形区域的最大边长；如果没有这样的正方形区域，则返回 0 。<br>示例 1：<br>输入：mat = [[1,1,3,2,4,3,2],[1,1,3,2,4,3,2],[1,1,3,2,4,3,2]], threshold = 4<br>输出：2<br>解释：总和小于 4 的正方形的最大边长为 2，如图所示。<br>示例 2：<br>输入：mat = [[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2],[2,2,2,2,2]], threshold = 1<br>输出：0<br>示例 3：<br>输入：mat = [[1,1,1,1],[1,0,0,0],[1,0,0,0],[1,0,0,0]], threshold = 6<br>输出：3<br>示例 4：<br>输入：mat = [[18,70],[61,1],[25,85],[14,40],[11,96],[97,96],[63,45]], threshold = 40184<br>输出：2<br>提示：<br>1 <= m, n <= 300<br>m == mat.length<br>n == mat[i].length<br>0 <= mat[i][j] <= 10000<br>0 <= threshold <= 10^5
***

```python
todo
```
#### 第1295题	**统计位数为偶数的数字	简单	**
***
给你一个整数数组 nums，请你返回其中位数为 偶数 的数字的个数。<br>示例 1：<br>输入：nums = [12,345,2,6,7896]<br>输出：2<br>解释：<br>12 是 2 位数字（位数为偶数）<br>345 是 3 位数字（位数为奇数）<br>2 是 1 位数字（位数为奇数）<br>6 是 1 位数字 位数为奇数）<br>7896 是 4 位数字（位数为偶数）<br>因此只有 12 和 7896 是位数为偶数的数字<br>示例 2：<br>输入：nums = [555,901,482,1771]<br>输出：1<br>解释：<br>只有 1771 是位数为偶数的数字。<br>提示：<br>1 <= nums.length <= 500<br>1 <= nums[i] <= 10^5
***

```python
todo
```
#### 第1296题	**划分数组为连续数字的集合	中等	**
***
给你一个整数数组 nums 和一个正整数 k，请你判断是否可以把这个数组划分成一些由 k 个连续数字组成的集合。<br>如果可以，请返回 True；否则，返回 False。<br>示例 1：<br>输入：nums = [1,2,3,3,4,4,5,6], k = 4<br>输出：true<br>解释：数组可以分成 [1,2,3,4] 和 [3,4,5,6]。<br>示例 2：<br>输入：nums = [3,2,1,2,3,4,3,4,5,9,10,11], k = 3<br>输出：true<br>解释：数组可以分成 [1,2,3] , [2,3,4] , [3,4,5] 和 [9,10,11]。<br>示例 3：<br>输入：nums = [3,3,2,2,1,1], k = 3<br>输出：true<br>示例 4：<br>输入：nums = [1,2,3,4], k = 3<br>输出：false<br>解释：数组不能分成几个大小为 3 的子数组。<br>提示：<br>1 <= nums.length <= 10^5<br>1 <= nums[i] <= 10^9<br>1 <= k <= nums.length
***

```python
todo
```
#### 第1299题	**将每个元素替换为右侧最大元素	简单	**
***
给你一个数组 arr ，请你将每个元素用它右边最大的元素替换，如果是最后一个元素，用 -1 替换。<br>完成所有替换操作后，请你返回这个数组。<br>示例：<br>输入：arr = [17,18,5,4,6,1]<br>输出：[18,6,6,6,1,-1]<br>提示：<br>1 <= arr.length <= 10^4<br>1 <= arr[i] <= 10^5
***

```python
todo
```
#### 第1300题	**转变数组后最接近目标值的数组和	中等	**
***
给你一个整数数组 arr 和一个目标值 target ，请你返回一个整数 value ，使得将数组中所有大于 value 的值变成 value 后，数组的和最接近  target （最接近表示两者之差的绝对值最小）。<br>如果有多种使得和最接近 target 的方案，请你返回这些整数中的最小值。<br>请注意，答案不一定是 arr 中的数字。<br>示例 1：<br>输入：arr = [4,9,3], target = 10<br>输出：3<br>解释：当选择 value 为 3 时，数组会变成 [3, 3, 3]，和为 9 ，这是最接近 target 的方案。<br>示例 2：<br>输入：arr = [2,3,5], target = 10<br>输出：5<br>示例 3：<br>输入：arr = [60864,25176,27249,21296,20204], target = 56803<br>输出：11361<br>提示：<br>1 <= arr.length <= 10^4<br>1 <= arr[i], target <= 10^5
***

```python
todo
```
#### 第1304题	**和为零的N个唯一整数	简单	**
***
给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。<br>示例 1：<br>输入：n = 5<br>输出：[-7,-1,1,3,4]<br>解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。<br>示例 2：<br>输入：n = 3<br>输出：[-1,0,1]<br>示例 3：<br>输入：n = 1<br>输出：[0]<br>提示：<br>1 <= n <= 1000
***

```python
todo
```
#### 第1313题	**解压缩编码列表	简单	**
***
给你一个以行程长度编码压缩的整数列表 nums 。<br>考虑每相邻两个元素 [a, b] = [nums[2*i], nums[2*i+1]] （其中 i >= 0 ），每一对都表示解压后有 a 个值为 b 的元素。<br>请你返回解压后的列表。<br>示例：<br>输入：nums = [1,2,3,4]<br>输出：[2,4,4,4]<br>提示：<br>2 <= nums.length <= 100<br>nums.length % 2 == 0<br>1 <= nums[i] <= 100
***

```python
todo
```
