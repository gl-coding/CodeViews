# 第16节

#### 第1184题	**公交站间的距离	简单	**
***
环形公交路线上有 n 个站，按次序从 0 到 n - 1 进行编号。我们已知每一对相邻公交站之间的距离，distance[i] 表示编号为 i 的车站和编号为 (i + 1) % n 的车站之间的距离。<br>环线上的公交车都可以按顺时针和逆时针的方向行驶。<br>返回乘客从出发点 start 到目的地 destination 之间的最短距离。<br>示例 1：<br>输入：distance = [1,2,3,4], start = 0, destination = 1<br>输出：1<br>解释：公交站 0 和 1 之间的距离是 1 或 9，最小值是 1。<br>示例 2：<br>输入：distance = [1,2,3,4], start = 0, destination = 2<br>输出：3<br>解释：公交站 0 和 2 之间的距离是 3 或 7，最小值是 3。<br>示例 3：<br>输入：distance = [1,2,3,4], start = 0, destination = 3<br>输出：4<br>解释：公交站 0 和 3 之间的距离是 6 或 4，最小值是 4。<br>提示：<br>1 <= n <= 10^4<br>distance.length == n<br>0 <= start, destination < n<br>0 <= distance[i] <= 10^4
***

```python
todo
```
#### 第1185题	**一周中的第几天	简单	**
***
给你一个日期，请你设计一个算法来判断它是对应一周中的哪一天。<br>输入为三个整数：day、month 和 year，分别表示日、月、年。<br>您返回的结果必须是这几个值中的一个 {"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"}。<br>示例 1：<br>输入：day = 31, month = 8, year = 2019<br>输出："Saturday"<br>示例 2：<br>输入：day = 18, month = 7, year = 1999<br>输出："Sunday"<br>示例 3：<br>输入：day = 15, month = 8, year = 1993<br>输出："Sunday"<br>提示：<br>给出的日期一定是在 1971 到 2100 年之间的有效日期。
***

```python
todo
```
#### 第1200题	**最小绝对差	简单	**
***
给你个整数数组 arr，其中每个元素都 不相同。<br>请你找到所有具有最小绝对差的元素对，并且按升序的顺序返回。<br>示例 1：<br>输入：arr = [4,2,1,3]<br>输出：[[1,2],[2,3],[3,4]]<br>示例 2：<br>输入：arr = [1,3,6,10,15]<br>输出：[[1,3]]<br>示例 3：<br>输入：arr = [3,8,-10,23,19,-4,-14,27]<br>输出：[[-14,-10],[19,23],[23,27]]<br>提示：<br>2 <= arr.length <= 10^5<br>-10^6 <= arr[i] <= 10^6
***

```python
todo
```
#### 第1202题	**交换字符串中的元素	中等	**
***
给你一个字符串 s，以及该字符串中的一些「索引对」数组 pairs，其中 pairs[i] = [a, b] 表示字符串中的两个索引（编号从 0 开始）。<br>你可以 任意多次交换 在 pairs 中任意一对索引处的字符。<br>返回在经过若干次交换后，s 可以变成的按字典序最小的字符串。<br>示例 1:<br>输入：s = "dcab", pairs = [[0,3],[1,2]]<br>输出："bacd"<br>解释：<br>交换 s[0] 和 s[3], s = "bcad"<br>交换 s[1] 和 s[2], s = "bacd"<br>示例 2：<br>输入：s = "dcab", pairs = [[0,3],[1,2],[0,2]]<br>输出："abcd"<br>解释：<br>交换 s[0] 和 s[3], s = "bcad"<br>交换 s[0] 和 s[2], s = "acbd"<br>交换 s[1] 和 s[2], s = "abcd"<br>示例 3：<br>输入：s = "cba", pairs = [[0,1],[1,2]]<br>输出："abc"<br>解释：<br>交换 s[0] 和 s[1], s = "bca"<br>交换 s[1] 和 s[2], s = "bac"<br>交换 s[0] 和 s[1], s = "abc"<br>提示：<br>1 <= s.length <= 10^5<br>0 <= pairs.length <= 10^5<br>0 <= pairs[i][0], pairs[i][1] < s.length<br>s 中只含有小写英文字母
***

```python
todo
```
#### 第1208题	**尽可能使字符串相等	中等	**
***
给你两个长度相同的字符串，s 和 t。<br>将 s 中的第 i 个字符变到 t 中的第 i 个字符需要 |s[i] - t[i]| 的开销（开销可能为 0），也就是两个字符的 ASCII 码值的差的绝对值。<br>用于变更字符串的最大预算是 maxCost。在转化字符串时，总开销应当小于等于该预算，这也意味着字符串的转化可能是不完全的。<br>如果你可以将 s 的子字符串转化为它在 t 中对应的子字符串，则返回可以转化的最大长度。<br>如果 s 中没有子字符串可以转化成 t 中对应的子字符串，则返回 0。<br>示例 1：<br>输入：s = "abcd", t = "bcdf", cost = 3<br>输出：3<br>解释：s 中的 "abc" 可以变为 "bcd"。开销为 3，所以最大长度为 3。<br>示例 2：<br>输入：s = "abcd", t = "cdef", cost = 3<br>输出：1<br>解释：s 中的任一字符要想变成 t 中对应的字符，其开销都是 2。因此，最大长度为 1。<br>示例 3：<br>输入：s = "abcd", t = "acde", cost = 0<br>输出：1<br>解释：你无法作出任何改动，所以最大长度为 1。<br>提示：<br>1 <= s.length, t.length <= 10^5<br>0 <= maxCost <= 10^6<br>s 和 t 都只含小写英文字母。
***

```python
todo
```
#### 第1217题	**玩筹码	简单	**
***
数轴上放置了一些筹码，每个筹码的位置存在数组 chips 当中。<br>你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：<br>将第 i 个筹码向左或者右移动 2 个单位，代价为 0。<br>将第 i 个筹码向左或者右移动 1 个单位，代价为 1。<br>最开始的时候，同一位置上也可能放着两个或者更多的筹码。<br>返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。<br>示例 1：<br>输入：chips = [1,2,3]<br>输出：1<br>解释：第二个筹码移动到位置三的代价是 1，第一个筹码移动到位置三的代价是 0，总代价为 1。<br>示例 2：<br>输入：chips = [2,2,2,3,3]<br>输出：2<br>解释：第四和第五个筹码移动到位置二的代价都是 1，所以最小总代价为 2。<br>提示：<br>1 <= chips.length <= 100<br>1 <= chips[i] <= 10^9
***

```python
todo
```
#### 第1222题	**可以攻击国王的皇后	中等	**
***
在一个 8x8 的棋盘上，放置着若干「黑皇后」和一个「白国王」。<br>「黑皇后」在棋盘上的位置分布用整数坐标数组 queens 表示，「白国王」的坐标用数组 king 表示。<br>「黑皇后」的行棋规定是：横、直、斜都可以走，步数不受限制，但是，不能越子行棋。<br>请你返回可以直接攻击到「白国王」的所有「黑皇后」的坐标（任意顺序）。<br>示例 1：<br>输入：queens = [[0,1],[1,0],[4,0],[0,4],[3,3],[2,4]], king = [0,0]<br>输出：[[0,1],[1,0],[3,3]]<br>解释：<br>[0,1] 的皇后可以攻击到国王，因为他们在同一行上。<br>[1,0] 的皇后可以攻击到国王，因为他们在同一列上。<br>[3,3] 的皇后可以攻击到国王，因为他们在同一条对角线上。<br>[0,4] 的皇后无法攻击到国王，因为她被位于 [0,1] 的皇后挡住了。<br>[4,0] 的皇后无法攻击到国王，因为她被位于 [1,0] 的皇后挡住了。<br>[2,4] 的皇后无法攻击到国王，因为她和国王不在同一行/列/对角线上。<br>示例 2：<br>输入：queens = [[0,0],[1,1],[2,2],[3,4],[3,5],[4,4],[4,5]], king = [3,3]<br>输出：[[2,2],[3,4],[4,4]]<br>示例 3：<br>输入：queens = [[5,6],[7,7],[2,1],[0,7],[1,6],[5,1],[3,7],[0,3],[4,0],[1,2],[6,3],[5,0],[0,4],[2,2],[1,1],[6,4],[5,4],[0,0],[2,6],[4,5],[5,2],[1,4],[7,5],[2,3],[0,5],[4,2],[1,0],[2,7],[0,1],[4,6],[6,1],[0,6],[4,3],[1,7]], king = [3,4]<br>输出：[[2,3],[1,4],[1,6],[3,7],[4,3],[5,4],[4,5]]<br>提示：<br>1 <= queens.length <= 63<br>queens[0].length == 2<br>0 <= queens[i][j] < 8<br>king.length == 2<br>0 <= king[0], king[1] < 8<br>一个棋盘格上最多只能放置一枚棋子。
***

```python
todo
```
#### 第1232题	**缀点成线	简单	**
***
在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。<br>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。<br>示例 1：<br>输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]<br>输出：true<br>示例 2：<br>输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]<br>输出：false<br>提示：<br>2 <= coordinates.length <= 1000<br>coordinates[i].length == 2<br>-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4<br>coordinates 中不含重复的点
***

```python
todo
```
#### 第1233题	**删除子文件夹	中等	**
***
你是一位系统管理员，手里有一份文件夹列表 folder，你的任务是要删除该列表中的所有 子文件夹，并以 任意顺序 返回剩下的文件夹。<br>我们这样定义「子文件夹」：<br>如果文件夹 folder[i] 位于另一个文件夹 folder[j] 下，那么 folder[i] 就是 folder[j] 的子文件夹。<br>文件夹的「路径」是由一个或多个按以下格式串联形成的字符串：<br>/ 后跟一个或者多个小写英文字母。<br>例如，/leetcode 和 /leetcode/problems 都是有效的路径，而空字符串和 / 不是。<br>示例 1：<br>输入：folder = ["/a","/a/b","/c/d","/c/d/e","/c/f"]<br>输出：["/a","/c/d","/c/f"]<br>解释："/a/b/" 是 "/a" 的子文件夹，而 "/c/d/e" 是 "/c/d" 的子文件夹。<br>示例 2：<br>输入：folder = ["/a","/a/b/c","/a/b/d"]<br>输出：["/a"]<br>解释：文件夹 "/a/b/c" 和 "/a/b/d/" 都会被删除，因为它们都是 "/a" 的子文件夹。<br>示例 3：<br>输入：folder = ["/a/b/c","/a/b/d","/a/b/ca"]<br>输出：["/a/b/c","/a/b/ca","/a/b/d"]<br>提示：<br>1 <= folder.length <= 4 * 10^4<br>2 <= folder[i].length <= 100<br>folder[i] 只包含小写字母和 /<br>folder[i] 总是以字符 / 起始<br>每个文件夹名都是唯一的
***

```python
todo
```
#### 第1252题	**奇数值单元格的数目	简单	**
***
给你一个 n 行 m 列的矩阵，最开始的时候，每个单元格中的值都是 0。<br>另有一个索引数组 indices，indices[i] = [ri, ci] 中的 ri 和 ci 分别表示指定的行和列（从 0 开始编号）。<br>你需要将每对 [ri, ci] 指定的行和列上的所有单元格的值加 1。<br>请你在执行完所有 indices 指定的增量操作后，返回矩阵中 「奇数值单元格」 的数目。<br>示例 1：<br>输入：n = 2, m = 3, indices = [[0,1],[1,1]]<br>输出：6<br>解释：最开始的矩阵是 [[0,0,0],[0,0,0]]。<br>第一次增量操作后得到 [[1,2,1],[0,1,0]]。<br>最后的矩阵是 [[1,3,1],[1,3,1]]，里面有 6 个奇数。<br>示例 2：<br>输入：n = 2, m = 2, indices = [[1,1],[0,0]]<br>输出：0<br>解释：最后的矩阵是 [[2,2],[2,2]]，里面没有奇数。<br>提示：<br>1 <= n <= 50<br>1 <= m <= 50<br>1 <= indices.length <= 100<br>0 <= indices[i][0] < n<br>0 <= indices[i][1] < m
***

```python
todo
```
#### 第1260题	**二维网格迁移	简单	**
***
给你一个 n 行 m 列的二维网格 grid 和一个整数 k。你需要将 grid 迁移 k 次。<br>每次「迁移」操作将会引发下述活动：<br>位于 grid[i][j] 的元素将会移动到 grid[i][j + 1]。<br>位于 grid[i][n - 1] 的元素将会移动到 grid[i + 1][0]。<br>位于 grid[m - 1][ - 1] 的元素将会移动到 grid[0][0]。<br>请你返回 k 次迁移操作后最终得到的 二维网格。<br>示例 1：<br>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 1<br>输出：[[9,1,2],[3,4,5],[6,7,8]]<br>示例 2：<br>输入：grid = [[3,8,1,9],[19,7,2,5],[4,6,11,10],[12,0,21,13]], k = 4<br>输出：[[12,0,21,13],[3,8,1,9],[19,7,2,5],[4,6,11,10]]<br>示例 3：<br>输入：grid = [[1,2,3],[4,5,6],[7,8,9]], k = 9<br>输出：[[1,2,3],[4,5,6],[7,8,9]]<br>提示：<br>1 <= grid.length <= 50<br>1 <= grid[i].length <= 50<br>-1000 <= grid[i][j] <= 1000<br>0 <= k <= 100
***

```python
todo
```
#### 第1266题	**访问所有点的最小时间	简单	**
***
平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。<br>你可以按照下面的规则在平面上移动：<br>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。<br>示例 1：<br>输入：points = [[1,1],[3,4],[-1,0]]<br>输出：7<br>解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]<br>从 [1,1] 到 [3,4] 需要 3 秒<br>从 [3,4] 到 [-1,0] 需要 4 秒<br>一共需要 7 秒<br>示例 2：<br>输入：points = [[3,2],[-2,2]]<br>输出：5<br>提示：<br>points.length == n<br>1 <= n <= 100<br>points[i].length == 2<br>-1000 <= points[i][0], points[i][1] <= 1000
***

```python
todo
```
