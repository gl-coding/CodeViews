# 第10节

#### 第714题	**买卖股票的最佳时机含手续费	中等	**
***
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br>示例 1:<br>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>注意:<br>0 < prices.length <= 50000.<br>0 < prices[i] < 50000.<br>0 <= fee < 50000.
***

```python
todo
```
#### 第717题	**1比特与2比特字符	简单	**
***
有两种特殊字符。第一种字符可以用一比特0来表示。第二种字符可以用两比特(10 或 11)来表示。<br>现给一个由若干比特组成的字符串。问最后一个字符是否必定为一个一比特字符。给定的字符串总是由0结束。<br>示例 1:<br>输入:<br>bits = [1, 0, 0]<br>输出: True<br>解释:<br>唯一的编码方式是一个两比特字符和一个一比特字符。所以最后一个字符是一比特字符。<br>示例 2:<br>输入:<br>bits = [1, 1, 1, 0]<br>输出: False<br>解释:<br>唯一的编码方式是两比特字符和两比特字符。所以最后一个字符不是一比特字符。<br>注意:<br>1 <= len(bits) <= 1000.<br>bits[i] 总是0 或 1.
***

```python
todo
```
#### 第718题	**最长重复子数组	中等	**
***
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br>示例 1:<br>输入:<br>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]<br>输出: 3<br>解释:<br>长度最长的公共子数组是 [3, 2, 1]。<br>说明:<br>1 <= len(A), len(B) <= 1000<br>0 <= A[i], B[i] < 100
***

```python
todo
```
#### 第719题	**找出第 k 小的距离对	困难	**
***
给定一个整数数组，返回所有数对之间的第 k 个最小距离。一对 (A, B) 的距离被定义为 A 和 B 之间的绝对差值。<br>示例 1:<br>输入：<br>nums = [1,3,1]<br>k = 1<br>输出：0<br>解释：<br>所有数对如下：<br>(1,3) -> 2<br>(1,1) -> 0<br>(3,1) -> 2<br>因此第 1 个最小距离的数对是 (1,1)，它们之间的距离为 0。<br>提示:<br>2 <= len(nums) <= 10000.<br>0 <= nums[i] < 1000000.<br>1 <= k <= len(nums) * (len(nums) - 1) / 2.
***

```python
todo
```
#### 第724题	**寻找数组的中心索引	简单	**
***
给定一个整数类型的数组 nums，请编写一个能够返回数组“中心索引”的方法。<br>我们是这样定义数组中心索引的：数组中心索引的左侧所有元素相加的和等于右侧所有元素相加的和。<br>如果数组不存在中心索引，那么我们应该返回 -1。如果数组有多个中心索引，那么我们应该返回最靠近左边的那一个。<br>示例 1:<br>输入:<br>nums = [1, 7, 3, 6, 5, 6]<br>输出: 3<br>解释:<br>索引3 (nums[3] = 6) 的左侧数之和(1 + 7 + 3 = 11)，与右侧数之和(5 + 6 = 11)相等。<br>同时, 3 也是第一个符合要求的中心索引。<br>示例 2:<br>输入:<br>nums = [1, 2, 3]<br>输出: -1<br>解释:<br>数组中不存在满足此条件的中心索引。<br>说明:<br>nums 的长度范围为 [0, 10000]。<br>任何一个 nums[i] 将会是一个范围在 [-1000, 1000]的整数。
***

```python
todo
```
#### 第729题	**我的日程安排表 I	中等	**
***
实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。<br>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start <= x < end。<br>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。<br>每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。<br>请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)<br>示例 1:<br>MyCalendar();<br>MyCalendar.book(10, 20); // returns true<br>MyCalendar.book(15, 25); // returns false<br>MyCalendar.book(20, 30); // returns true<br>解释:<br>第一个日程安排可以添加到日历中.  第二个日程安排不能添加到日历中，因为时间 15 已经被第一个日程安排预定了。<br>第三个日程安排可以添加到日历中，因为第一个日程安排并不包含时间 20 。<br>说明:<br>每个测试用例，调用 MyCalendar.book 函数最多不超过 100次。<br>调用函数 MyCalendar.book(start, end)时， start 和 end 的取值范围为 [0, 10^9]。
***

```python
todo
```
#### 第746题	**使用最小花费爬楼梯	简单	**
***
数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。<br>每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。<br>您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。<br>示例 1:<br>输入: cost = [10, 15, 20]<br>输出: 15<br>解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。<br>示例 2:<br>输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>输出: 6<br>解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。<br>注意：<br>cost 的长度将会在 [2, 1000]。<br>每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。
***

```python
todo
```
#### 第747题	**至少是其他数字两倍的最大数	简单	**
***
在一个给定的数组nums中，总是存在一个最大元素 。<br>查找数组中的最大元素是否至少是数组中每个其他数字的两倍。<br>如果是，则返回最大元素的索引，否则返回-1。<br>示例 1:<br>输入: nums = [3, 6, 1, 0]<br>输出: 1<br>解释: 6是最大的整数, 对于数组中的其他整数,<br>6大于数组中其他元素的两倍。6的索引是1, 所以我们返回1.<br>示例 2:<br>输入: nums = [1, 2, 3, 4]<br>输出: -1<br>解释: 4没有超过3的两倍大, 所以我们返回 -1.<br>提示:<br>nums 的长度范围在[1, 50].<br>每个 nums[i] 的整数范围在 [0, 100].
***

```python
todo
```
#### 第766题	**托普利茨矩阵	简单	**
***
如果一个矩阵的每一方向由左上到右下的对角线上具有相同元素，那么这个矩阵是托普利茨矩阵。<br>给定一个 M x N 的矩阵，当且仅当它是托普利茨矩阵时返回 True。<br>示例 1:<br>输入:<br>matrix = [<br>[1,2,3,4],<br>[5,1,2,3],<br>[9,5,1,2]<br>]<br>输出: True<br>解释:<br>在上述矩阵中, 其对角线为:<br>"[9]", "[5, 5]", "[1, 1, 1]", "[2, 2, 2]", "[3, 3]", "[4]"。<br>各条对角线上的所有元素均相同, 因此答案是True。<br>示例 2:<br>输入:<br>matrix = [<br>[1,2],<br>[2,2]<br>]<br>输出: False<br>解释:<br>对角线"[1, 2]"上的元素不同。<br>说明:<br>matrix 是一个包含整数的二维数组。<br>matrix 的行数和列数均在 [1, 20]范围内。<br>matrix[i][j] 包含的整数在 [0, 99]范围内。<br>进阶:<br>如果矩阵存储在磁盘上，并且磁盘内存是有限的，因此一次最多只能将一行矩阵加载到内存中，该怎么办？<br>如果矩阵太大以至于只能一次将部分行加载到内存中，该怎么办？
***

```python
todo
```
#### 第768题	**最多能完成排序的块 II	困难	**
***
这个问题和“最多能完成排序的块”相似，但给定数组中的元素可以重复，输入数组最大长度为2000，其中的元素最大为10**8。<br>arr是一个可能包含重复元素的整数数组，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。<br>我们最多能将数组分成多少块？<br>示例 1:<br>输入: arr = [5,4,3,2,1]<br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [5, 4], [3, 2, 1] 的结果是 [4, 5, 1, 2, 3]，这不是有序的数组。<br>示例 2:<br>输入: arr = [2,1,3,4,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [2, 1], [3, 4, 4]。<br>然而，分成 [2, 1], [3], [4], [4] 可以得到最多的块数。<br>注意:<br>arr的长度在[1, 2000]之间。<br>arr[i]的大小在[0, 10**8]之间。
***

```python
todo
```
#### 第769题	**最多能完成排序的块	中等	**
***
数组arr是[0, 1, ..., arr.length - 1]的一种排列，我们将这个数组分割成几个“块”，并将这些块分别进行排序。之后再连接起来，使得连接的结果和按升序排序后的原数组相同。<br>我们最多能将数组分成多少块？<br>示例 1:<br>输入: arr = [4,3,2,1,0]<br>输出: 1<br>解释:<br>将数组分成2块或者更多块，都无法得到所需的结果。<br>例如，分成 [4, 3], [2, 1, 0] 的结果是 [3, 4, 0, 1, 2]，这不是有序的数组。<br>示例 2:<br>输入: arr = [1,0,2,3,4]<br>输出: 4<br>解释:<br>我们可以把它分成两块，例如 [1, 0], [2, 3, 4]。<br>然而，分成 [1, 0], [2], [3], [4] 可以得到最多的块数。<br>注意:<br>arr 的长度在 [1, 10] 之间。<br>arr[i]是 [0, 1, ..., arr.length - 1]的一种排列。
***

```python
todo
```
#### 第775题	**全局倒置与局部倒置	中等	**
***
数组 A 是 [0, 1, ..., N - 1] 的一种排列，N 是数组 A 的长度。全局倒置指的是 i,j 满足 0 <= i < j < N 并且 A[i] > A[j] ，局部倒置指的是 i 满足 0 <= i < N 并且 A[i] > A[i+1] 。<br>当数组 A 中全局倒置的数量等于局部倒置的数量时，返回 true 。<br>示例 1:<br>输入: A = [1,0,2]<br>输出: true<br>解释: 有 1 个全局倒置，和 1 个局部倒置。<br>示例 2:<br>输入: A = [1,2,0]<br>输出: false<br>解释: 有 2 个全局倒置，和 1 个局部倒置。<br>注意:<br>A 是 [0, 1, ..., A.length - 1] 的一种排列<br>A 的长度在 [1, 5000]之间<br>这个问题的时间限制已经减少了。
***

```python
todo
```
