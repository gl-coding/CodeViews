# 第14节

#### 第1007题	**行相等的最少多米诺旋转	中等	**
***
在一排多米诺骨牌中，A[i] 和 B[i] 分别代表第 i 个多米诺骨牌的上半部分和下半部分。（一个多米诺是两个从 1 到 6 的数字同列平铺形成的 —— 该平铺的每一半上都有一个数字。）<br>我们可以旋转第 i 张多米诺，使得 A[i] 和 B[i] 的值交换。<br>返回能使 A 中所有值或者 B 中所有值都相同的最小旋转次数。<br>如果无法做到，返回 -1.<br>示例 1：<br>输入：A = [2,1,2,4,2,2], B = [5,2,6,2,3,2]<br>输出：2<br>解释：<br>图一表示：在我们旋转之前， A 和 B 给出的多米诺牌。<br>如果我们旋转第二个和第四个多米诺骨牌，我们可以使上面一行中的每个值都等于 2，如图二所示。<br>示例 2：<br>输入：A = [3,5,1,2,3], B = [3,6,3,3,4]<br>输出：-1<br>解释：<br>在这种情况下，不可能旋转多米诺牌使一行的值相等。<br>提示：<br>1 <= A[i], B[i] <= 6<br>2 <= A.length == B.length <= 20000
***

```python
todo
```
#### 第1010题	**总持续时间可被 60 整除的歌曲	简单	**
***
在歌曲列表中，第 i 首歌曲的持续时间为 time[i] 秒。<br>返回其总持续时间（以秒为单位）可被 60 整除的歌曲对的数量。形式上，我们希望索引的数字  i < j 且有 (time[i] + time[j]) % 60 == 0。<br>示例 1：<br>输入：[30,20,150,100,40]<br>输出：3<br>解释：这三对的总持续时间可被 60 整数：<br>(time[0] = 30, time[2] = 150): 总持续时间 180<br>(time[1] = 20, time[3] = 100): 总持续时间 120<br>(time[1] = 20, time[4] = 40): 总持续时间 60<br>示例 2：<br>输入：[60,60,60]<br>输出：3<br>解释：所有三对的总持续时间都是 120，可以被 60 整数。<br>提示：<br>1 <= time.length <= 60000<br>1 <= time[i] <= 500
***

```python
todo
```
#### 第1011题	**在 D 天内送达包裹的能力	中等	**
***
传送带上的包裹必须在 D 天内从一个港口运送到另一个港口。<br>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。<br>返回能在 D 天内将传送带上的所有包裹送达的船的最低运载能力。<br>示例 1：<br>输入：weights = [1,2,3,4,5,6,7,8,9,10], D = 5<br>输出：15<br>解释：<br>船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：<br>第 1 天：1, 2, 3, 4, 5<br>第 2 天：6, 7<br>第 3 天：8<br>第 4 天：9<br>第 5 天：10<br><br>请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。<br>示例 2：<br>输入：weights = [3,2,2,4,1,4], D = 3<br>输出：6<br>解释：<br>船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：<br>第 1 天：3, 2<br>第 2 天：2, 4<br>第 3 天：1, 4<br>示例 3：<br>输入：weights = [1,2,3,1,1], D = 4<br>输出：3<br>解释：<br>第 1 天：1<br>第 2 天：2<br>第 3 天：3<br>第 4 天：1, 1<br>提示：<br>1 <= D <= weights.length <= 50000<br>1 <= weights[i] <= 500
***

```python
todo
```
#### 第1013题	**将数组分成和相等的三个部分	简单	**
***
给定一个整数数组 A，只有我们可以将其划分为三个和相等的非空部分时才返回 true，否则返回 false。<br>形式上，如果我们可以找出索引 i+1 < j 且满足 (A[0] + A[1] + ... + A[i] == A[i+1] + A[i+2] + ... + A[j-1] == A[j] + A[j-1] + ... + A[A.length - 1]) 就可以将数组三等分。<br>示例 1：<br>输出：[0,2,1,-6,6,-7,9,1,2,0,1]<br>输出：true<br>解释：0 + 2 + 1 = -6 + 6 - 7 + 9 + 1 = 2 + 0 + 1<br>示例 2：<br>输入：[0,2,1,-6,6,7,9,-1,2,0,1]<br>输出：false<br>示例 3：<br>输入：[3,3,6,5,-2,2,5,1,-9,4]<br>输出：true<br>解释：3 + 3 = 6 = 5 - 2 + 2 + 5 + 1 - 9 + 4<br>提示：<br>3 <= A.length <= 50000<br>-10000 <= A[i] <= 10000
***

```python
todo
```
#### 第1014题	**最佳观光组合	中等	**
***
给定正整数数组 A，A[i] 表示第 i 个观光景点的评分，并且两个景点 i 和 j 之间的距离为 j - i。<br>一对景点（i < j）组成的观光组合的得分为（A[i] + A[j] + i - j）：景点的评分之和减去它们两者之间的距离。<br>返回一对观光景点能取得的最高分。<br>示例：<br>输入：[8,1,5,2,6]<br>输出：11<br>解释：i = 0, j = 2, A[i] + A[j] + i - j = 8 + 5 + 0 - 2 = 11<br>提示：<br>2 <= A.length <= 50000<br>1 <= A[i] <= 1000
***

```python
todo
```
#### 第1018题	**可被 5 整除的二进制前缀	简单	**
***
给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。<br>返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。<br>示例 1：<br>输入：[0,1,1]<br>输出：[true,false,false]<br>解释：<br>输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。<br>示例 2：<br>输入：[1,1,1]<br>输出：[false,false,false]<br>示例 3：<br>输入：[0,1,1,1,1,1]<br>输出：[true,false,false,false,true,false]<br>示例 4：<br>输入：[1,1,1,0,1]<br>输出：[false,false,false,false,false]<br>提示：<br>1 <= A.length <= 30000<br>A[i] 为 0 或 1
***

```python
todo
```
#### 第1031题	**两个非重叠子数组的最大和	中等	**
***
给出非负整数数组 A ，返回两个非重叠（连续）子数组中元素的最大和，子数组的长度分别为 L 和 M。（这里需要澄清的是，长为 L 的子数组可以出现在长为 M 的子数组之前或之后。）<br>从形式上看，返回最大的 V，而 V = (A[i] + A[i+1] + ... + A[i+L-1]) + (A[j] + A[j+1] + ... + A[j+M-1]) 并满足下列条件之一：<br>0 <= i < i + L - 1 < j < j + M - 1 < A.length, 或<br>0 <= j < j + M - 1 < i < i + L - 1 < A.length.<br>示例 1：<br>输入：A = [0,6,5,2,2,5,1,9,4], L = 1, M = 2<br>输出：20<br>解释：子数组的一种选择中，[9] 长度为 1，[6,5] 长度为 2。<br>示例 2：<br>输入：A = [3,8,1,3,2,1,8,9,0], L = 3, M = 2<br>输出：29<br>解释：子数组的一种选择中，[3,8,1] 长度为 3，[8,9] 长度为 2。<br>示例 3：<br>输入：A = [2,1,5,6,0,9,5,0,3,8], L = 4, M = 3<br>输出：31<br>解释：子数组的一种选择中，[5,6,0,9] 长度为 4，[0,3,8] 长度为 3。<br>提示：<br>L >= 1<br>M >= 1<br>L + M <= A.length <= 1000<br>0 <= A[i] <= 1000
***

```python
todo
```
#### 第1035题	**不相交的线	中等	**
***
我们在两条独立的水平线上按给定的顺序写下 A 和 B 中的整数。<br>现在，我们可以绘制一些连接两个数字 A[i] 和 B[j] 的直线，只要 A[i] == B[j]，且我们绘制的直线不与任何其他连线（非水平线）相交。<br>以这种方法绘制线条，并返回我们可以绘制的最大连线数。<br>示例 1：<br>输入：A = [1,4,2], B = [1,2,4]<br>输出：2<br>解释：<br>我们可以画出两条不交叉的线，如上图所示。<br>我们无法画出第三条不相交的直线，因为从 A[1]=4 到 B[2]=4 的直线将与从 A[2]=2 到 B[1]=2 的直线相交。<br>示例 2：<br>输入：A = [2,5,1,2,5], B = [10,5,2,1,5,2]<br>输出：3<br>示例 3：<br>输入：A = [1,3,7,1,7,5], B = [1,9,2,5,1]<br>输出：2<br>提示：<br>1 <= A.length <= 500<br>1 <= B.length <= 500<br>1 <= A[i], B[i] <= 2000
***

```python
todo
```
#### 第1040题	**移动石子直到连续 II	中等	**
***
在一个长度无限的数轴上，第 i 颗石子的位置为 stones[i]。如果一颗石子的位置最小/最大，那么该石子被称作端点石子。<br>每个回合，你可以将一颗端点石子拿起并移动到一个未占用的位置，使得该石子不再是一颗端点石子。<br>值得注意的是，如果石子像 stones = [1,2,5] 这样，你将无法移动位于位置 5 的端点石子，因为无论将它移动到任何位置（例如 0 或 3），该石子都仍然会是端点石子。<br>当你无法进行任何移动时，即，这些石子的位置连续时，游戏结束。<br>要使游戏结束，你可以执行的最小和最大移动次数分别是多少？ 以长度为 2 的数组形式返回答案：answer = [minimum_moves, maximum_moves] 。<br>示例 1：<br>输入：[7,4,9]<br>输出：[1,2]<br>解释：<br>我们可以移动一次，4 -> 8，游戏结束。<br>或者，我们可以移动两次 9 -> 5，4 -> 6，游戏结束。<br>示例 2：<br>输入：[6,5,4,3,10]<br>输出：[2,3]<br>解释：<br>我们可以移动 3 -> 8，接着是 10 -> 7，游戏结束。<br>或者，我们可以移动 3 -> 7, 4 -> 8, 5 -> 9，游戏结束。<br>注意，我们无法进行 10 -> 2 这样的移动来结束游戏，因为这是不合要求的移动。<br>示例 3：<br>输入：[100,101,104,102,103]<br>输出：[0,0]<br>提示：<br>3 <= stones.length <= 10^4<br>1 <= stones[i] <= 10^9<br>stones[i] 的值各不相同。
***

```python
todo
```
#### 第1051题	**高度检查器	简单	**
***
学校在拍年度纪念照时，一般要求学生按照 非递减 的高度顺序排列。<br>请你返回至少有多少个学生没有站在正确位置数量。该人数指的是：能让所有学生以 非递减 高度排列的必要移动人数。<br>示例：<br>输入：[1,1,4,2,1,3]<br>输出：3<br>解释：<br>高度为 4、3 和最后一个 1 的学生，没有站在正确的位置。<br>提示：<br>1 <= heights.length <= 100<br>1 <= heights[i] <= 100
***

```python
todo
```
#### 第1052题	**爱生气的书店老板	中等	**
***
今天，书店老板有一家店打算试营业 customers.length 分钟。每分钟都有一些顾客（customers[i]）会进入书店，所有这些顾客都会在那一分钟结束后离开。<br>在某些时候，书店老板会生气。 如果书店老板在第 i 分钟生气，那么 grumpy[i] = 1，否则 grumpy[i] = 0。 当书店老板生气时，那一分钟的顾客就会不满意，不生气则他们是满意的。<br>书店老板知道一个秘密技巧，能抑制自己的情绪，可以让自己连续 X 分钟不生气，但却只能使用一次。<br>请你返回这一天营业下来，最多有多少客户能够感到满意的数量。<br>示例：<br>输入：customers = [1,0,1,2,1,1,7,5], grumpy = [0,1,0,1,0,1,0,1], X = 3<br>输出：16<br>解释：<br>书店老板在最后 3 分钟保持冷静。<br>感到满意的最大客户数量 = 1 + 1 + 1 + 1 + 7 + 5 = 16.<br>提示：<br>1 <= X <= customers.length == grumpy.length <= 20000<br>0 <= customers[i] <= 1000<br>0 <= grumpy[i] <= 1
***

```python
todo
```
#### 第1053题	**交换一次的先前排列	中等	**
***
给你一个正整数的数组 A（其中的元素不一定完全不同），请你返回可在 一次交换（交换两数字 A[i] 和 A[j] 的位置）后得到的、按字典序排列小于 A 的最大可能排列。<br>如果无法这么操作，就请返回原数组。<br>示例 1：<br>输入：[3,2,1]<br>输出：[3,1,2]<br>解释：<br>交换 2 和 1<br>示例 2：<br>输入：[1,1,5]<br>输出：[1,1,5]<br>解释：<br>这已经是最小排列<br>示例 3：<br>输入：[1,9,4,6,7]<br>输出：[1,7,4,6,9]<br>解释：<br>交换 9 和 7<br>示例 4：<br>输入：[3,1,1,3]<br>输出：[1,3,1,3]<br>解释：<br>交换 1 和 3<br>提示：<br>1 <= A.length <= 10000<br>1 <= A[i] <= 10000
***

```python
todo
```
