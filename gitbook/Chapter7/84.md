# 第8节

#### 第647题	**回文子串	中等	**
***
给定一个字符串，你的任务是计算这个字符串中有多少个回文子串。<br>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被计为是不同的子串。<br>示例 1:<br>输入: "abc"<br>输出: 3<br>解释: 三个回文子串: "a", "b", "c".<br>示例 2:<br>输入: "aaa"<br>输出: 6<br>说明: 6个回文子串: "a", "a", "a", "aa", "aa", "aaa".<br>注意:<br>输入的字符串长度不会超过1000。
***

```python
class Solution(object):
    def countSubstrings(self, s):
        """
        :type s: str
        :rtype: int
        """
        n = len(s)
        ans = 0
        for i in range(n):
            left = right = i
            while left >= 0 and right < n and s[left] == s[right]:
                ans += 1
                left -= 1
                right += 1

            left = i
            right = i + 1
            while left >= 0 and right < n and s[left] == s[right]:
                ans += 1
                left -= 1
                right += 1
        return ans```
#### 第650题	**只有两个键的键盘	中等	**
***
最初在一个记事本上只有一个字符 'A'。你每次可以对这个记事本进行两种操作：<br>Copy All (复制全部) : 你可以复制这个记事本中的所有字符(部分的复制是不允许的)。<br>Paste (粘贴) : 你可以粘贴你上一次复制的字符。<br>给定一个数字 n 。你需要使用最少的操作次数，在记事本中打印出恰好 n 个 'A'。输出能够打印出 n 个 'A' 的最少操作次数。<br>示例 1:<br>输入: 3<br>输出: 3<br>解释:<br>最初, 我们只有一个字符 'A'。<br>第 1 步, 我们使用 Copy All 操作。<br>第 2 步, 我们使用 Paste 操作来获得 'AA'。<br>第 3 步, 我们使用 Paste 操作来获得 'AAA'。<br>说明:<br>n 的取值范围是 [1, 1000] 。
***

```python
"""
1. group operations as ([^C][^V][^V]...[^V]) that has in total k operations and it gets k * # of A
2. n can be written as x_1 * x_2 * ... * x_N
3. then total operations # = x_1 + x_2 + ... + x_N
4. since p * q >= p + q for integers > 1, to min the result
5. decomposite x_1 to x_N to min the sum
"""

class Solution(object):
    def _minSteps(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n == 1:
            return 0
        for i in range(2, int((n + 1)**0.5) + 1):
            if n % i == 0:
                return i + self.minSteps(n / i)
        return n

    def minSteps(self, n):
        def factor(n):
            d = 2
            while d * d <= n:
                while n % d == 0:
                    n /= d
                    yield d
                d += 1
            if n > 1:
                yield n
        return sum(factor(n))



```
#### 第664题	**奇怪的打印机	困难	**
***
有台奇怪的打印机有以下两个特殊要求：<br>打印机每次只能打印同一个字符序列。<br>每次可以在任意起始和结束位置打印新字符，并且会覆盖掉原来已有的字符。<br>给定一个只包含小写英文字母的字符串，你的任务是计算这个打印机打印它需要的最少次数。<br>示例 1:<br>输入: "aaabbb"<br>输出: 2<br>解释: 首先打印 "aaa" 然后打印 "bbb"。<br>示例 2:<br>输入: "aba"<br>输出: 2<br>解释: 首先打印 "aaa" 然后在第二个位置打印 "b" 覆盖掉原来的字符 'a'。<br>提示: 输入字符串的长度不会超过 100。
***

```python
todo
```
#### 第673题	**最长递增子序列的个数	中等	**
***
给定一个未排序的整数数组，找到最长递增子序列的个数。<br>示例 1:<br>输入: [1,3,5,4,7]<br>输出: 2<br>解释: 有两个最长递增子序列，分别是 [1, 3, 4, 7] 和[1, 3, 5, 7]。<br>示例 2:<br>输入: [2,2,2,2,2]<br>输出: 5<br>解释: 最长递增子序列的长度是1，并且存在5个子序列的长度为1，因此输出5。<br>注意: 给定的数组长度不超过 2000 并且结果一定是32位有符号整数。
***

```python
todo
```
#### 第688题	**“马”在棋盘上的概率	中等	**
***
已知一个 NxN 的国际象棋棋盘，棋盘的行号和列号都是从 0 开始。即最左上角的格子记为 (0, 0)，最右下角的记为 (N-1, N-1)。<br>现有一个 “马”（也译作 “骑士”）位于 (r, c) ，并打算进行 K 次移动。<br>如下图所示，国际象棋的 “马” 每一步先沿水平或垂直方向移动 2 个格子，然后向与之相垂直的方向再移动 1 个格子，共有 8 个可选的位置。<br>现在 “马” 每一步都从可选的位置（包括棋盘外部的）中独立随机地选择一个进行移动，直到移动了 K 次或跳到了棋盘外面。<br>求移动结束后，“马” 仍留在棋盘上的概率。<br>示例：<br>输入: 3, 2, 0, 0<br>输出: 0.0625<br>解释:<br>输入的数据依次为 N, K, r, c<br>第 1 步时，有且只有 2 种走法令 “马” 可以留在棋盘上（跳到（1,2）或（2,1））。对于以上的两种情况，各自在第2步均有且只有2种走法令 “马” 仍然留在棋盘上。<br>所以 “马” 在结束后仍在棋盘上的概率为 0.0625。<br>注意：<br>N 的取值范围为 [1, 25]<br>K 的取值范围为 [0, 100]<br>开始时，“马” 总是位于棋盘上
***

```python
todo
```
#### 第689题	**三个无重叠子数组的最大和	困难	**
***
给定数组 nums 由正整数组成，找到三个互不重叠的子数组的最大和。<br>每个子数组的长度为k，我们要使这3*k个项的和最大化。<br>返回每个区间起始索引的列表（索引从 0 开始）。如果有多个结果，返回字典序最小的一个。<br>示例:<br>输入: [1,2,1,2,6,7,5,1], 2<br>输出: [0, 3, 5]<br>解释: 子数组 [1, 2], [2, 6], [7, 5] 对应的起始索引为 [0, 3, 5]。<br>我们也可以取 [2, 1], 但是结果 [1, 3, 5] 在字典序上更大。<br>注意:<br>nums.length的范围在[1, 20000]之间。<br>nums[i]的范围在[1, 65535]之间。<br>k的范围在[1, floor(nums.length / 3)]之间。
***

```python
todo
```
#### 第691题	**贴纸拼词	困难	**
***
我们给出了 N 种不同类型的贴纸。每个贴纸上都有一个小写的英文单词。<br>你希望从自己的贴纸集合中裁剪单个字母并重新排列它们，从而拼写出给定的目标字符串 target。<br>如果你愿意的话，你可以不止一次地使用每一张贴纸，而且每一张贴纸的数量都是无限的。<br>拼出目标 target 所需的最小贴纸数量是多少？如果任务不可能，则返回 -1。<br>示例 1：<br>输入：<br>["with", "example", "science"], "thehat"<br>输出：<br>3<br>解释：<br>我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。<br>把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。<br>此外，这是形成目标字符串所需的最小贴纸数量。<br>示例 2：<br>输入：<br>["notice", "possible"], "basicbasic"<br>输出：<br>-1<br>解释：<br>我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。<br>提示：<br>stickers 长度范围是 [1, 50]。<br>stickers 由小写英文单词组成（不带撇号）。<br>target 的长度在 [1, 15] 范围内，由小写字母组成。<br>在所有的测试案例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选取的，目标是两个随机单词的串联。<br>时间限制可能比平时更具挑战性。预计 50 个贴纸的测试案例平均可在35ms内解决。
***

```python
todo
```
#### 第698题	**划分为k个相等的子集	中等	**
***
给定一个整数数组  nums 和一个正整数 k，找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。<br>示例 1：<br>输入： nums = [4, 3, 2, 3, 5, 2, 1], k = 4<br>输出： True<br>说明： 有可能将其分成 4 个子集（5），（1,4），（2,3），（2,3）等于总和。<br>注意:<br>1 <= k <= len(nums) <= 16<br>0 < nums[i] < 10000
***

```python
todo
```
#### 第712题	**两个字符串的最小ASCII删除和	中等	**
***
给定两个字符串s1, s2，找到使两个字符串相等所需删除字符的ASCII值的最小和。<br>示例 1:<br>输入: s1 = "sea", s2 = "eat"<br>输出: 231<br>解释: 在 "sea" 中删除 "s" 并将 "s" 的值(115)加入总和。<br>在 "eat" 中删除 "t" 并将 116 加入总和。<br>结束时，两个字符串相等，115 + 116 = 231 就是符合条件的最小和。<br>示例 2:<br>输入: s1 = "delete", s2 = "leet"<br>输出: 403<br>解释: 在 "delete" 中删除 "dee" 字符串变成 "let"，<br>将 100[d]+101[e]+101[e] 加入总和。在 "leet" 中删除 "e" 将 101[e] 加入总和。<br>结束时，两个字符串都等于 "let"，结果即为 100+101+101+101 = 403 。<br>如果改为将两个字符串转换为 "lee" 或 "eet"，我们会得到 433 或 417 的结果，比答案更大。<br>注意:<br>0 < s1.length, s2.length <= 1000。<br>所有字符串中的字符ASCII值在[97, 122]之间。
***

```python
todo
```
#### 第714题	**买卖股票的最佳时机含手续费	中等	**
***
给定一个整数数组 prices，其中第 i 个元素代表了第 i 天的股票价格 ；非负整数 fee 代表了交易股票的手续费用。<br>你可以无限次地完成交易，但是你每次交易都需要付手续费。如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。<br>返回获得利润的最大值。<br>示例 1:<br>输入: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>输出: 8<br>解释: 能够达到的最大利润:<br>在此处买入 prices[0] = 1<br>在此处卖出 prices[3] = 8<br>在此处买入 prices[4] = 4<br>在此处卖出 prices[5] = 9<br>总利润: ((8 - 1) - 2) + ((9 - 4) - 2) = 8.<br>注意:<br>0 < prices.length <= 50000.<br>0 < prices[i] < 50000.<br>0 <= fee < 50000.
***

```python
todo
```
#### 第718题	**最长重复子数组	中等	**
***
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。<br>示例 1:<br>输入:<br>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]<br>输出: 3<br>解释:<br>长度最长的公共子数组是 [3, 2, 1]。<br>说明:<br>1 <= len(A), len(B) <= 1000<br>0 <= A[i], B[i] < 100
***

```python
todo
```
#### 第730题	**统计不同回文子字符串	困难	**
***
给定一个字符串 S，找出 S 中不同的非空回文子序列个数，并返回该数字与 10^9 + 7 的模。<br>通过从 S 中删除 0 个或多个字符来获得子字符序列。<br>如果一个字符序列与它反转后的字符序列一致，那么它是回文字符序列。<br>如果对于某个  i，A_i != B_i，那么 A_1, A_2, ... 和 B_1, B_2, ... 这两个字符序列是不同的。<br>示例 1：<br>输入：<br>S = 'bccb'<br>输出：6<br>解释：<br>6 个不同的非空回文子字符序列分别为：'b', 'c', 'bb', 'cc', 'bcb', 'bccb'。<br>注意：'bcb' 虽然出现两次但仅计数一次。<br>示例 2：<br>输入：<br>S = 'abcdabcdabcdabcdabcdabcdabcdabcddcbadcbadcbadcbadcbadcbadcbadcba'<br>输出：104860361<br>解释：<br>共有 3104860382 个不同的非空回文子字符序列，对 10^9 + 7 取模为 104860361。<br>提示：<br>字符串 S 的长度将在[1, 1000]范围内。<br>每个字符 S[i] 将会是集合 {'a', 'b', 'c', 'd'} 中的某一个。
***

```python
todo
```
