# 第10节

#### 第847题	**访问所有节点的最短路径	困难	**
***
给出 graph 为有 N 个节点（编号为 0, 1, 2, ..., N-1）的无向连通图。<br>graph.length = N，且只有节点 i 和 j 连通时，j != i 在列表 graph[i] 中恰好出现一次。<br>返回能够访问所有节点的最短路径的长度。你可以在任一节点开始和停止，也可以多次重访节点，并且可以重用边。<br>示例 1：<br>输入：[[1,2,3],[0],[0],[0]]<br>输出：4<br>解释：一个可能的路径为 [1,0,2,0,3]<br>示例 2：<br>输入：[[1],[0,2,4],[1,3,4],[2],[1,2]]<br>输出：4<br>解释：一个可能的路径为 [0,1,4,2,3]<br>提示：<br>1 <= graph.length <= 12<br>0 <= graph[i].length < graph.length
***

```python
todo
```
#### 第871题	**最低加油次数	困难	**
***
汽车从起点出发驶向目的地，该目的地位于出发位置东面 target 英里处。<br>沿途有加油站，每个 station[i] 代表一个加油站，它位于出发位置东面 station[i][0] 英里处，并且有 station[i][1] 升汽油。<br>假设汽车油箱的容量是无限的，其中最初有 startFuel 升燃料。它每行驶 1 英里就会用掉 1 升汽油。<br>当汽车到达加油站时，它可能停下来加油，将所有汽油从加油站转移到汽车中。<br>为了到达目的地，汽车所必要的最低加油次数是多少？如果无法到达目的地，则返回 -1 。<br>注意：如果汽车到达加油站时剩余燃料为 0，它仍然可以在那里加油。如果汽车到达目的地时剩余燃料为 0，仍然认为它已经到达目的地。<br>示例 1：<br>输入：target = 1, startFuel = 1, stations = []<br>输出：0<br>解释：我们可以在不加油的情况下到达目的地。<br>示例 2：<br>输入：target = 100, startFuel = 1, stations = [[10,100]]<br>输出：-1<br>解释：我们无法抵达目的地，甚至无法到达第一个加油站。<br>示例 3：<br>输入：target = 100, startFuel = 10, stations = [[10,60],[20,30],[30,30],[60,40]]<br>输出：2<br>解释：<br>我们出发时有 10 升燃料。<br>我们开车来到距起点 10 英里处的加油站，消耗 10 升燃料。将汽油从 0 升加到 60 升。<br>然后，我们从 10 英里处的加油站开到 60 英里处的加油站（消耗 50 升燃料），<br>并将汽油从 10 升加到 50 升。然后我们开车抵达目的地。<br>我们沿途在1两个加油站停靠，所以返回 2 。<br>提示：<br>1 <= target, startFuel, stations[i][1] <= 10^9<br>0 <= stations.length <= 500<br>0 < stations[0][0] < stations[1][0] < ... < stations[stations.length-1][0] < target
***

```python
todo
```
#### 第873题	**最长的斐波那契子序列的长度	中等	**
***
如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：<br>n >= 3<br>对于所有 i + 2 <= n，都有 X_i + X_{i+1} = X_{i+2}<br>给定一个严格递增的正整数数组形成序列，找到 A 中最长的斐波那契式的子序列的长度。如果一个不存在，返回  0 。<br>（回想一下，子序列是从原序列 A 中派生出来的，它从 A 中删掉任意数量的元素（也可以不删），而不改变其余元素的顺序。例如， [3, 5, 8] 是 [3, 4, 5, 6, 7, 8] 的一个子序列）<br>示例 1：<br>输入: [1,2,3,4,5,6,7,8]<br>输出: 5<br>解释:<br>最长的斐波那契式子序列为：[1,2,3,5,8] 。<br>示例 2：<br>输入: [1,3,7,11,12,14,18]<br>输出: 3<br>解释:<br>最长的斐波那契式子序列有：<br>[1,11,12]，[3,11,14] 以及 [7,11,18] 。<br>提示：<br>3 <= A.length <= 1000<br>1 <= A[0] < A[1] < ... < A[A.length - 1] <= 10^9<br>（对于以 Java，C，C++，以及 C# 的提交，时间限制被减少了 50%）
***

```python
todo
```
#### 第877题	**石子游戏	中等	**
***
亚历克斯和李用几堆石子在做游戏。偶数堆石子排成一行，每堆都有正整数颗石子 piles[i] 。<br>游戏以谁手中的石子最多来决出胜负。石子的总数是奇数，所以没有平局。<br>亚历克斯和李轮流进行，亚历克斯先开始。 每回合，玩家从行的开始或结束处取走整堆石头。 这种情况一直持续到没有更多的石子堆为止，此时手中石子最多的玩家获胜。<br>假设亚历克斯和李都发挥出最佳水平，当亚历克斯赢得比赛时返回 true ，当李赢得比赛时返回 false 。<br>示例：<br>输入：[5,3,4,5]<br>输出：true<br>解释：<br>亚历克斯先开始，只能拿前 5 颗或后 5 颗石子 。<br>假设他取了前 5 颗，这一行就变成了 [3,4,5] 。<br>如果李拿走前 3 颗，那么剩下的是 [4,5]，亚历克斯拿走后 5 颗赢得 10 分。<br>如果李拿走后 5 颗，那么剩下的是 [3,4]，亚历克斯拿走后 4 颗赢得 9 分。<br>这表明，取前 5 颗石子对亚历克斯来说是一个胜利的举动，所以我们返回 true 。<br>提示：<br>2 <= piles.length <= 500<br>piles.length 是偶数。<br>1 <= piles[i] <= 500<br>sum(piles) 是奇数。
***

```python
todo
```
#### 第879题	**盈利计划	困难	**
***
帮派里有 G 名成员，他们可能犯下各种各样的罪行。<br>第 i 种犯罪会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与。<br>让我们把这些犯罪的任何子集称为盈利计划，该计划至少产生 P 的利润。<br>有多少种方案可以选择？因为答案很大，所以返回它模 10^9 + 7 的值。<br>示例 1：<br>输入：G = 5, P = 3, group = [2,2], profit = [2,3]<br>输出：2<br>解释：<br>至少产生 3 的利润，该帮派可以犯下罪 0 和罪 1 ，或仅犯下罪 1 。<br>总的来说，有两种方案。<br>示例 2:<br>输入：G = 10, P = 5, group = [2,3,5], profit = [6,7,8]<br>输出：7<br>解释：<br>至少产生 5 的利润，只要他们犯其中一种罪就行，所以该帮派可以犯下任何罪行 。<br>有 7 种可能的计划：(0)，(1)，(2)，(0,1)，(0,2)，(1,2)，以及 (0,1,2) 。<br>提示：<br>1 <= G <= 100<br>0 <= P <= 100<br>1 <= group[i] <= 100<br>0 <= profit[i] <= 100<br>1 <= group.length = profit.length <= 100
***

```python
todo
```
#### 第887题	**鸡蛋掉落	困难	**
***
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。<br>你的目标是确切地知道 F 的值是多少。<br>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？<br>示例 1：<br>输入：K = 1, N = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。<br>示例 2：<br>输入：K = 2, N = 6<br>输出：3<br>示例 3：<br>输入：K = 3, N = 14<br>输出：4<br>提示：<br>1 <= K <= 100<br>1 <= N <= 10000
***

```python
todo
```
#### 第898题	**子数组按位或操作	中等	**
***
我们有一个非负整数数组 A。<br>对于每个（连续的）子数组 B = [A[i], A[i+1], ..., A[j]] （ i <= j），我们对 B 中的每个元素进行按位或操作，获得结果 A[i] | A[i+1] | ... | A[j]。<br>返回可能结果的数量。 （多次出现的结果在最终答案中仅计算一次。）<br>示例 1：<br>输入：[0]<br>输出：1<br>解释：<br>只有一个可能的结果 0 。<br>示例 2：<br>输入：[1,1,2]<br>输出：3<br>解释：<br>可能的子数组为 [1]，[1]，[2]，[1, 1]，[1, 2]，[1, 1, 2]。<br>产生的结果为 1，1，2，1，3，3 。<br>有三个唯一值，所以答案是 3 。<br>示例 3：<br>输入：[1,2,4]<br>输出：6<br>解释：<br>可能的结果是 1，2，3，4，6，以及 7 。<br>提示：<br>1 <= A.length <= 50000<br>0 <= A[i] <= 10^9
***

```python
todo
```
#### 第902题	**最大为 N 的数字组合	困难	**
***
我们有一组排序的数字 D，它是  {'1','2','3','4','5','6','7','8','9'} 的非空子集。（请注意，'0' 不包括在内。）<br>现在，我们用这些数字进行组合写数字，想用多少次就用多少次。例如 D = {'1','3','5'}，我们可以写出像 '13', '551', '1351315' 这样的数字。<br>返回可以用 D 中的数字写出的小于或等于 N 的正整数的数目。<br>示例 1：<br>输入：D = ["1","3","5","7"], N = 100<br>输出：20<br>解释：<br>可写出的 20 个数字是：<br>1, 3, 5, 7, 11, 13, 15, 17, 31, 33, 35, 37, 51, 53, 55, 57, 71, 73, 75, 77.<br>示例 2：<br>输入：D = ["1","4","9"], N = 1000000000<br>输出：29523<br>解释：<br>我们可以写 3 个一位数字，9 个两位数字，27 个三位数字，<br>81 个四位数字，243 个五位数字，729 个六位数字，<br>2187 个七位数字，6561 个八位数字和 19683 个九位数字。<br>总共，可以使用D中的数字写出 29523 个整数。<br>提示：<br>D 是按排序顺序的数字 '1'-'9' 的子集。<br>1 <= N <= 10^9
***

```python
todo
```
#### 第903题	**DI 序列的有效排列	困难	**
***
我们给出 S，一个源于 {'D', 'I'} 的长度为 n 的字符串 。（这些字母代表 “减少” 和 “增加”。）<br>有效排列 是对整数 {0, 1, ..., n} 的一个排列 P[0], P[1], ..., P[n]，使得对所有的 i：<br>如果 S[i] == 'D'，那么 P[i] > P[i+1]，以及；<br>如果 S[i] == 'I'，那么 P[i] < P[i+1]。<br>有多少个有效排列？因为答案可能很大，所以请返回你的答案模 10^9 + 7.<br>示例：<br>输入："DID"<br>输出：5<br>解释：<br>(0, 1, 2, 3) 的五个有效排列是：<br>(1, 0, 3, 2)<br>(2, 0, 3, 1)<br>(2, 1, 3, 0)<br>(3, 0, 2, 1)<br>(3, 1, 2, 0)<br>提示：<br>1 <= S.length <= 200<br>S 仅由集合 {'D', 'I'} 中的字符组成。
***

```python
todo
```
#### 第920题	**播放列表的数量	困难	**
***
你的音乐播放器里有 N 首不同的歌，在旅途中，你的旅伴想要听 L 首歌（不一定不同，即，允许歌曲重复）。请你为她按如下规则创建一个播放列表：<br>每首歌至少播放一次。<br>一首歌只有在其他 K 首歌播放完之后才能再次播放。<br>返回可以满足要求的播放列表的数量。由于答案可能非常大，请返回它模 10^9 + 7 的结果。<br>示例 1：<br>输入：N = 3, L = 3, K = 1<br>输出：6<br>解释：有 6 种可能的播放列表。[1, 2, 3]，[1, 3, 2]，[2, 1, 3]，[2, 3, 1]，[3, 1, 2]，[3, 2, 1].<br>示例 2：<br>输入：N = 2, L = 3, K = 0<br>输出：6<br>解释：有 6 种可能的播放列表。[1, 1, 2]，[1, 2, 1]，[2, 1, 1]，[2, 2, 1]，[2, 1, 2]，[1, 2, 2]<br>示例 3：<br>输入：N = 2, L = 3, K = 1<br>输出：2<br>解释：有 2 种可能的播放列表。[1, 2, 1]，[2, 1, 2]<br>提示：<br>0 <= K < N <= L <= 100
***

```python
todo
```
#### 第931题	**下降路径最小和	中等	**
***
给定一个方形整数数组 A，我们想要得到通过 A 的下降路径的最小和。<br>下降路径可以从第一行中的任何元素开始，并从每一行中选择一个元素。在下一行选择的元素和当前行所选元素最多相隔一列。<br>示例：<br>输入：[[1,2,3],[4,5,6],[7,8,9]]<br>输出：12<br>解释：<br>可能的下降路径有：<br>[1,4,7], [1,4,8], [1,5,7], [1,5,8], [1,5,9]<br>[2,4,7], [2,4,8], [2,5,7], [2,5,8], [2,5,9], [2,6,8], [2,6,9]<br>[3,5,7], [3,5,8], [3,5,9], [3,6,8], [3,6,9]<br>和最小的下降路径是 [1,4,7]，所以答案是 12。<br>提示：<br>1 <= A.length == A[0].length <= 100<br>-100 <= A[i][j] <= 100
***

```python
todo
```
#### 第935题	**骑士拨号器	中等	**
***
国际象棋中的骑士可以按下图所示进行移动：<br>.<br><br>这一次，我们将 “骑士” 放在电话拨号盘的任意数字键（如上图所示）上，接下来，骑士将会跳 N-1 步。每一步必须是从一个数字键跳到另一个数字键。<br>每当它落在一个键上（包括骑士的初始位置），都会拨出键所对应的数字，总共按下 N 位数字。<br>你能用这种方式拨出多少个不同的号码？<br>因为答案可能很大，所以输出答案模 10^9 + 7。<br>示例 1：<br>输入：1<br>输出：10<br>示例 2：<br>输入：2<br>输出：20<br>示例 3：<br>输入：3<br>输出：46<br>提示：<br>1 <= N <= 5000
***

```python
todo
```
