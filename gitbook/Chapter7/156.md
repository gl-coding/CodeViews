# 第14节

#### 第1235题	**规划兼职工作	困难	**
***
你打算利用空闲时间来做兼职工作赚些零花钱。<br>这里有 n 份兼职工作，每份工作预计从 startTime[i] 开始到 endTime[i] 结束，报酬为 profit[i]。<br>给你一份兼职工作表，包含开始时间 startTime，结束时间 endTime 和预计报酬 profit 三个数组，请你计算并返回可以获得的最大报酬。<br>注意，时间上出现重叠的 2 份工作不能同时进行。<br>如果你选择的工作在时间 X 结束，那么你可以立刻进行在时间 X 开始的下一份工作。<br>示例 1：<br>输入：startTime = [1,2,3,3], endTime = [3,4,5,6], profit = [50,10,40,70]<br>输出：120<br>解释：<br>我们选出第 1 份和第 4 份工作，<br>时间范围是 [1-3]+[3-6]，共获得报酬 120 = 50 + 70。<br>示例 2：<br>输入：startTime = [1,2,3,4,6], endTime = [3,5,10,6,9], profit = [20,20,100,70,60]<br>输出：150<br>解释：<br>我们选择第 1，4，5 份工作。<br>共获得报酬 150 = 20 + 70 + 60。<br>示例 3：<br>输入：startTime = [1,1,1], endTime = [2,3,4], profit = [5,6,4]<br>输出：6<br>提示：<br>1 <= startTime.length == endTime.length == profit.length <= 5 * 10^4<br>1 <= startTime[i] < endTime[i] <= 10^9<br>1 <= profit[i] <= 10^4
***

```python
todo
```
#### 第1240题	**铺瓷砖	困难	**
***
你是一位施工队的工长，根据设计师的要求准备为一套设计风格独特的房子进行室内装修。<br>房子的客厅大小为 n x m，为保持极简的风格，需要使用尽可能少的 正方形 瓷砖来铺盖地面。<br>假设正方形瓷砖的规格不限，边长都是整数。<br>请你帮设计师计算一下，最少需要用到多少块方形瓷砖？<br>示例 1：<br>输入：n = 2, m = 3<br>输出：3<br>解释：3 块地砖就可以铺满卧室。<br>2 块 1x1 地砖<br>1 块 2x2 地砖<br>示例 2：<br>输入：n = 5, m = 8<br>输出：5<br>示例 3：<br>输入：n = 11, m = 13<br>输出：6<br>提示：<br>1 <= n <= 13<br>1 <= m <= 13
***

```python
todo
```
#### 第1262题	**可被三整除的最大和	中等	**
***
给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。<br>示例 1：<br>输入：nums = [3,6,5,1,8]<br>输出：18<br>解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。<br>示例 2：<br>输入：nums = [4]<br>输出：0<br>解释：4 不能被 3 整除，所以无法选出数字，返回 0。<br>示例 3：<br>输入：nums = [1,2,3,4,4]<br>输出：12<br>解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。<br>提示：<br>1 <= nums.length <= 4 * 10^4<br>1 <= nums[i] <= 10^4
***

```python
todo
```
#### 第1269题	**停在原地的方案数	困难	**
***
有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。<br>每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地（指针不能被移动到数组范围外）。<br>给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行 steps 次操作以后，指针仍然指向索引 0 处的方案数。<br>由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。<br>示例 1：<br>输入：steps = 3, arrLen = 2<br>输出：4<br>解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。<br>向右，向左，不动<br>不动，向右，向左<br>向右，不动，向左<br>不动，不动，不动<br>示例  2：<br>输入：steps = 2, arrLen = 4<br>输出：2<br>解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。<br>向右，向左<br>不动，不动<br>示例 3：<br>输入：steps = 4, arrLen = 2<br>输出：8<br>提示：<br>1 <= steps <= 500<br>1 <= arrLen <= 10^6
***

```python
todo
```
#### 第1277题	**统计全为 1 的正方形子矩阵	中等	**
***
给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。<br>示例 1：<br>输入：matrix =<br>[<br>[0,1,1,1],<br>[1,1,1,1],<br>[0,1,1,1]<br>]<br>输出：15<br>解释：<br>边长为 1 的正方形有 10 个。<br>边长为 2 的正方形有 4 个。<br>边长为 3 的正方形有 1 个。<br>正方形的总数 = 10 + 4 + 1 = 15.<br>示例 2：<br>输入：matrix =<br>[<br>[1,0,1],<br>[1,1,0],<br>[1,1,0]<br>]<br>输出：7<br>解释：<br>边长为 1 的正方形有 6 个。<br>边长为 2 的正方形有 1 个。<br>正方形的总数 = 6 + 1 = 7.<br>提示：<br>1 <= arr.length <= 300<br>1 <= arr[0].length <= 300<br>0 <= arr[i][j] <= 1
***

```python
todo
```
#### 第1278题	**分割回文串 III	困难	**
***
给你一个由小写字母组成的字符串 s，和一个整数 k。<br>请你按下面的要求分割字符串：<br>首先，你可以将 s 中的部分字符修改为其他的小写英文字母。<br>接着，你需要把 s 分割成 k 个非空且不相交的子串，并且每个子串都是回文串。<br>请返回以这种方式分割字符串所需修改的最少字符数。<br>示例 1：<br>输入：s = "abc", k = 2<br>输出：1<br>解释：你可以把字符串分割成 "ab" 和 "c"，并修改 "ab" 中的 1 个字符，将它变成回文串。<br>示例 2：<br>输入：s = "aabbc", k = 3<br>输出：0<br>解释：你可以把字符串分割成 "aa"、"bb" 和 "c"，它们都是回文串。<br>示例 3：<br>输入：s = "leetcode", k = 8<br>输出：0<br>提示：<br>1 <= k <= s.length <= 100<br>s 中只含有小写英文字母。
***

```python
todo
```
#### 第1289题	**下降路径最小和 II	困难	**
***
给你一个整数方阵 arr ，定义「非零偏移下降路径」为：从 arr 数组中的每一行选择一个数字，且按顺序选出来的数字中，相邻数字不在原数组的同一列。<br>请你返回非零偏移下降路径数字和的最小值。<br>示例 1：<br>输入：arr = [[1,2,3],[4,5,6],[7,8,9]]<br>输出：13<br>解释：<br>所有非零偏移下降路径包括：<br>[1,5,9], [1,5,7], [1,6,7], [1,6,8],<br>[2,4,8], [2,4,9], [2,6,7], [2,6,8],<br>[3,4,8], [3,4,9], [3,5,7], [3,5,9]<br>下降路径中数字和最小的是 [1,5,7] ，所以答案是 13 。<br>提示：<br>1 <= arr.length == arr[i].length <= 200<br>-99 <= arr[i][j] <= 99
***

```python
todo
```
#### 第1301题	**最大得分的路径数目	困难	**
***
给你一个正方形字符数组 board ，你从数组最右下方的字符 'S' 出发。<br>你的目标是到达数组最左上角的字符 'E' ，数组剩余的部分为数字字符 1, 2, ..., 9 或者障碍 'X'。在每一步移动中，你可以向上、向左或者左上方移动，可以移动的前提是到达的格子没有障碍。<br>一条路径的 「得分」 定义为：路径上所有数字的和。<br>请你返回一个列表，包含两个整数：第一个整数是 「得分」 的最大值，第二个整数是得到最大得分的方案数，请把结果对 10^9 + 7 取余。<br>如果没有任何路径可以到达终点，请返回 [0, 0] 。<br>示例 1：<br>输入：board = ["E23","2X2","12S"]<br>输出：[7,1]<br>示例 2：<br>输入：board = ["E12","1X1","21S"]<br>输出：[4,2]<br>示例 3：<br>输入：board = ["E11","XXX","11S"]<br>输出：[0,0]<br>提示：<br>2 <= board.length == board[i].length <= 100
***

```python
todo
```
#### 第1312题	**让字符串成为回文串的最少插入次数	困难	**
***
给你一个字符串 s ，每一次操作你都可以在字符串的任意位置插入任意字符。<br>请你返回让 s 成为回文串的 最少操作次数 。<br>「回文串」是正读和反读都相同的字符串。<br>示例 1：<br>输入：s = "zzazz"<br>输出：0<br>解释：字符串 "zzazz" 已经是回文串了，所以不需要做任何插入操作。<br>示例 2：<br>输入：s = "mbadm"<br>输出：2<br>解释：字符串可变为 "mbdadbm" 或者 "mdbabdm" 。<br>示例 3：<br>输入：s = "leetcode"<br>输出：5<br>解释：插入 5 个字符后字符串变为 "leetcodocteel" 。<br>示例 4：<br>输入：s = "g"<br>输出：0<br>示例 5：<br>输入：s = "no"<br>输出：1<br>提示：<br>1 <= s.length <= 500<br>s 中所有字符都是小写字母。
***

```python
todo
```
#### 第1314题	**矩阵区域和	中等	**
***
给你一个 m * n 的矩阵 mat 和一个整数 K ，请你返回一个矩阵 answer ，其中每个 answer[i][j] 是所有满足下述条件的元素 mat[r][c] 的和：<br>i - K <= r <= i + K, j - K <= c <= j + K<br>(r, c) 在矩阵内。<br>示例 1：<br>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 1<br>输出：[[12,21,16],[27,45,33],[24,39,28]]<br>示例 2：<br>输入：mat = [[1,2,3],[4,5,6],[7,8,9]], K = 2<br>输出：[[45,45,45],[45,45,45],[45,45,45]]<br>提示：<br>m == mat.length<br>n == mat[i].length<br>1 <= m, n, K <= 100<br>1 <= mat[i][j] <= 100
***

```python
todo
```
#### 第1320题	**二指输入的的最小距离	困难	**
***
二指输入法定制键盘在 XY 平面上的布局如上图所示，其中每个大写英文字母都位于某个坐标处，例如字母 A 位于坐标 (0,0)，字母 B 位于坐标 (0,1)，字母 P 位于坐标 (2,3) 且字母 Z 位于坐标 (4,1)。<br>给你一个待输入字符串 word，请你计算并返回在仅使用两根手指的情况下，键入该字符串需要的最小移动总距离。坐标 (x1,y1) 和 (x2,y2) 之间的距离是 |x1 - x2| + |y1 - y2|。<br>注意，两根手指的起始位置是零代价的，不计入移动总距离。你的两根手指的起始位置也不必从首字母或者前两个字母开始。<br>示例 1：<br>输入：word = "CAKE"<br>输出：3<br>解释：<br>使用两根手指输入 "CAKE" 的最佳方案之一是：<br>手指 1 在字母 'C' 上 -> 移动距离 = 0<br>手指 1 在字母 'A' 上 -> 移动距离 = 从字母 'C' 到字母 'A' 的距离 = 2<br>手指 2 在字母 'K' 上 -> 移动距离 = 0<br>手指 2 在字母 'E' 上 -> 移动距离 = 从字母 'K' 到字母 'E' 的距离  = 1<br>总距离 = 3<br>示例 2：<br>输入：word = "HAPPY"<br>输出：6<br>解释：<br>使用两根手指输入 "HAPPY" 的最佳方案之一是：<br>手指 1 在字母 'H' 上 -> 移动距离 = 0<br>手指 1 在字母 'A' 上 -> 移动距离 = 从字母 'H' 到字母 'A' 的距离 = 2<br>手指 2 在字母 'P' 上 -> 移动距离 = 0<br>手指 2 在字母 'P' 上 -> 移动距离 = 从字母 'P' 到字母 'P' 的距离 = 0<br>手指 1 在字母 'Y' 上 -> 移动距离 = 从字母 'A' 到字母 'Y' 的距离 = 4<br>总距离 = 6<br>示例 3：<br>输入：word = "NEW"<br>输出：3<br>示例 4：<br>输入：word = "YEAR"<br>输出：7<br>提示：<br>2 <= word.length <= 300<br>每个 word[i] 都是一个大写英文字母。
***

```python
todo
```
#### 第1326题	**灌溉花园的最少水龙头数目	困难	**
***
在 x 轴上有一个一维的花园。花园长度为 n，从点 0 开始，到点 n 结束。<br>花园里总共有 n + 1 个水龙头，分别位于 [0, 1, ..., n] 。<br>给你一个整数 n 和一个长度为 n + 1 的整数数组 ranges ，其中 ranges[i] （下标从 0 开始）表示：如果打开点 i 处的水龙头，可以灌溉的区域为 [i -  ranges[i], i + ranges[i]] 。<br>请你返回可以灌溉整个花园的 最少水龙头数目 。如果花园始终存在无法灌溉到的地方，请你返回 -1 。<br>示例 1：<br>输入：n = 5, ranges = [3,4,1,1,0,0]<br>输出：1<br>解释：<br>点 0 处的水龙头可以灌溉区间 [-3,3]<br>点 1 处的水龙头可以灌溉区间 [-3,5]<br>点 2 处的水龙头可以灌溉区间 [1,3]<br>点 3 处的水龙头可以灌溉区间 [2,4]<br>点 4 处的水龙头可以灌溉区间 [4,4]<br>点 5 处的水龙头可以灌溉区间 [5,5]<br>只需要打开点 1 处的水龙头即可灌溉整个花园 [0,5] 。<br>示例 2：<br>输入：n = 3, ranges = [0,0,0,0]<br>输出：-1<br>解释：即使打开所有水龙头，你也无法灌溉整个花园。<br>示例 3：<br>输入：n = 7, ranges = [1,2,1,0,2,1,0,1]<br>输出：3<br>示例 4：<br>输入：n = 8, ranges = [4,0,0,0,0,0,0,0,4]<br>输出：2<br>示例 5：<br>输入：n = 8, ranges = [4,0,0,0,4,0,0,0,4]<br>输出：1<br>提示：<br>1 <= n <= 10^4<br>ranges.length == n + 1<br>0 <= ranges[i] <= 100
***

```python
todo
```
