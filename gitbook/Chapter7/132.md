# 第12节

#### 第1012题	**至少有 1 位重复的数字	困难	**
***
给定正整数 N，返回小于等于 N 且具有至少 1 位重复数字的正整数。<br>示例 1：<br>输入：20<br>输出：1<br>解释：具有至少 1 位重复数字的正数（<= 20）只有 11 。<br>示例 2：<br>输入：100<br>输出：10<br>解释：具有至少 1 位重复数字的正数（<= 100）有 11，22，33，44，55，66，77，88，99 和 100 。<br>示例 3：<br>输入：1000<br>输出：262<br>提示：<br>1 <= N <= 10^9
***

```python
todo
```
#### 第1024题	**视频拼接	中等	**
***
你将会获得一系列视频片段，这些片段来自于一项持续时长为 T 秒的体育赛事。这些片段可能有所重叠，也可能长度不一。<br>视频片段 clips[i] 都用区间进行表示：开始于 clips[i][0] 并于 clips[i][1] 结束。我们甚至可以对这些片段自由地再剪辑，例如片段 [0, 7] 可以剪切成 [0, 1] + [1, 3] + [3, 7] 三部分。<br>我们需要将这些片段进行再剪辑，并将剪辑后的内容拼接成覆盖整个运动过程的片段（[0, T]）。返回所需片段的最小数目，如果无法完成该任务，则返回 -1 。<br>示例 1：<br>输入：clips = [[0,2],[4,6],[8,10],[1,9],[1,5],[5,9]], T = 10<br>输出：3<br>解释：<br>我们选中 [0,2], [8,10], [1,9] 这三个片段。<br>然后，按下面的方案重制比赛片段：<br>将 [1,9] 再剪辑为 [1,2] + [2,8] + [8,9] 。<br>现在我们手上有 [0,2] + [2,8] + [8,10]，而这些涵盖了整场比赛 [0, 10]。<br>示例 2：<br>输入：clips = [[0,1],[1,2]], T = 5<br>输出：-1<br>解释：<br>我们无法只用 [0,1] 和 [0,2] 覆盖 [0,5] 的整个过程。<br>示例 3：<br>输入：clips = [[0,1],[6,8],[0,2],[5,6],[0,4],[0,3],[6,7],[1,3],[4,7],[1,4],[2,5],[2,6],[3,4],[4,5],[5,7],[6,9]], T = 9<br>输出：3<br>解释：<br>我们选取片段 [0,4], [4,7] 和 [6,9] 。<br>示例 4：<br>输入：clips = [[0,4],[2,8]], T = 5<br>输出：2<br>解释：<br>注意，你可能录制超过比赛结束时间的视频。<br>提示：<br>1 <= clips.length <= 100<br>0 <= clips[i][0], clips[i][1] <= 100<br>0 <= T <= 100
***

```python
todo
```
#### 第1025题	**除数博弈	简单	**
***
爱丽丝和鲍勃一起玩游戏，他们轮流行动。爱丽丝先手开局。<br>最初，黑板上有一个数字 N 。在每个玩家的回合，玩家需要执行以下操作：<br>选出任一 x，满足 0 < x < N 且 N % x == 0 。<br>用 N - x 替换黑板上的数字 N 。<br>如果玩家无法执行这些操作，就会输掉游戏。<br>只有在爱丽丝在游戏中取得胜利时才返回 True，否则返回 false。假设两个玩家都以最佳状态参与游戏。<br>示例 1：<br>输入：2<br>输出：true<br>解释：爱丽丝选择 1，鲍勃无法进行操作。<br>示例 2：<br>输入：3<br>输出：false<br>解释：爱丽丝选择 1，鲍勃也选择 1，然后爱丽丝无法进行操作。<br>提示：<br>1 <= N <= 1000
***

```python
todo
```
#### 第1027题	**最长等差数列	中等	**
***
给定一个整数数组 A，返回 A 中最长等差子序列的长度。<br>回想一下，A 的子序列是列表 A[i_1], A[i_2], ..., A[i_k] 其中 0 <= i_1 < i_2 < ... < i_k <= A.length - 1。并且如果 B[i+1] - B[i]( 0 <= i < B.length - 1) 的值都相同，那么序列 B 是等差的。<br>示例 1：<br>输入：[3,6,9,12]<br>输出：4<br>解释：<br>整个数组是公差为 3 的等差数列。<br>示例 2：<br>输入：[9,4,7,2,10]<br>输出：3<br>解释：<br>最长的等差子序列是 [4,7,10]。<br>示例 3：<br>输入：[20,1,15,3,10,5,8]<br>输出：4<br>解释：<br>最长的等差子序列是 [20,15,10,5]。<br>提示：<br>2 <= A.length <= 2000<br>0 <= A[i] <= 10000
***

```python
todo
```
#### 第1039题	**多边形三角剖分的最低得分	中等	**
***
给定 N，想象一个凸 N 边多边形，其顶点按顺时针顺序依次标记为 A[0], A[i], ..., A[N-1]。<br>假设您将多边形剖分为 N-2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 N-2 个三角形的值之和。<br>返回多边形进行三角剖分后可以得到的最低分。<br>示例 1：<br>输入：[1,2,3]<br>输出：6<br>解释：多边形已经三角化，唯一三角形的分数为 6。<br>示例 2：<br>输入：[3,7,4,5]<br>输出：144<br>解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。<br>示例 3：<br>输入：[1,3,1,4,1,5]<br>输出：13<br>解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。<br>提示：<br>3 <= A.length <= 50<br>1 <= A[i] <= 100
***

```python
todo
```
#### 第1048题	**最长字符串链	中等	**
***
给出一个单词列表，其中每个单词都由小写英文字母组成。<br>如果我们可以在 word1 的任何地方添加一个字母使其变成 word2，那么我们认为 word1 是 word2 的前身。例如，"abc" 是 "abac" 的前身。<br>词链是单词 [word_1, word_2, ..., word_k] 组成的序列，k >= 1，其中 word_1 是 word_2 的前身，word_2 是 word_3 的前身，依此类推。<br>从给定单词列表 words 中选择单词组成词链，返回词链的最长可能长度。<br>示例：<br>输入：["a","b","ba","bca","bda","bdca"]<br>输出：4<br>解释：最长单词链之一为 "a","ba","bda","bdca"。<br>提示：<br>1 <= words.length <= 1000<br>1 <= words[i].length <= 16<br>words[i] 仅由小写英文字母组成。
***

```python
todo
```
#### 第1049题	**最后一块石头的重量 II	中等	**
***
有一堆石头，每块石头的重量都是正整数。<br>每一回合，从中选出任意两块石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：<br>如果 x == y，那么两块石头都会被完全粉碎；<br>如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x。<br>最后，最多只会剩下一块石头。返回此石头最小的可能重量。如果没有石头剩下，就返回 0。<br>示例：<br>输入：[2,7,4,1,8,1]<br>输出：1<br>解释：<br>组合 2 和 4，得到 2，所以数组转化为 [2,7,1,8,1]，<br>组合 7 和 8，得到 1，所以数组转化为 [2,1,1,1]，<br>组合 2 和 1，得到 1，所以数组转化为 [1,1,1]，<br>组合 1 和 1，得到 0，所以数组转化为 [1]，这就是最优值。<br>提示：<br>1 <= stones.length <= 30<br>1 <= stones[i] <= 1000
***

```python
todo
```
#### 第1074题	**元素和为目标值的子矩阵数量	困难	**
***
给出矩阵 matrix 和目标值 target，返回元素总和等于目标值的非空子矩阵的数量。<br>子矩阵 x1, y1, x2, y2 是满足 x1 <= x <= x2 且 y1 <= y <= y2 的所有单元 matrix[x][y] 的集合。<br>如果 (x1, y1, x2, y2) 和 (x1', y1', x2', y2') 两个子矩阵中部分坐标不同（如：x1 != x1'），那么这两个子矩阵也不同。<br>示例 1：<br>输入：matrix = [[0,1,0],[1,1,1],[0,1,0]], target = 0<br>输出：4<br>解释：四个只含 0 的 1x1 子矩阵。<br>示例 2：<br>输入：matrix = [[1,-1],[-1,1]], target = 0<br>输出：5<br>解释：两个 1x2 子矩阵，加上两个 2x1 子矩阵，再加上一个 2x2 子矩阵。<br>提示：<br>1 <= matrix.length <= 300<br>1 <= matrix[0].length <= 300<br>-1000 <= matrix[i] <= 1000<br>-10^8 <= target <= 10^8
***

```python
todo
```
#### 第1092题	**最短公共超序列	困难	**
***
给出两个字符串 str1 和 str2，返回同时以 str1 和 str2 作为子序列的最短字符串。如果答案不止一个，则可以返回满足条件的任意一个答案。<br>（如果从字符串 T 中删除一些字符（也可能不删除，并且选出的这些字符可以位于 T 中的 任意位置），可以得到字符串 S，那么 S 就是 T 的子序列）<br>示例：<br>输入：str1 = "abac", str2 = "cab"<br>输出："cabac"<br>解释：<br>str1 = "abac" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 的第一个 "c"得到 "abac"。<br>str2 = "cab" 是 "cabac" 的一个子串，因为我们可以删去 "cabac" 末尾的 "ac" 得到 "cab"。<br>最终我们给出的答案是满足上述属性的最短字符串。<br>提示：<br>1 <= str1.length, str2.length <= 1000<br>str1 和 str2 都由小写英文字母组成。
***

```python
todo
```
#### 第1105题	**填充书架	中等	**
***
附近的家居城促销，你买回了一直心仪的可调节书架，打算把自己的书都整理到新的书架上。<br>你把要摆放的书 books 都整理好，叠成一摞：从上往下，第 i 本书的厚度为 books[i][0]，高度为 books[i][1]。<br>按顺序 将这些书摆放到总宽度为 shelf_width 的书架上。<br>先选几本书放在书架上（它们的厚度之和小于等于书架的宽度 shelf_width），然后再建一层书架。重复这个过程，直到把所有的书都放在书架上。<br>需要注意的是，在上述过程的每个步骤中，摆放书的顺序与你整理好的顺序相同。 例如，如果这里有 5 本书，那么可能的一种摆放情况是：第一和第二本书放在第一层书架上，第三本书放在第二层书架上，第四和第五本书放在最后一层书架上。<br>每一层所摆放的书的最大高度就是这一层书架的层高，书架整体的高度为各层高之和。<br>以这种方式布置书架，返回书架整体可能的最小高度。<br>示例：<br>输入：books = [[1,1],[2,3],[2,3],[1,1],[1,1],[1,1],[1,2]], shelf_width = 4<br>输出：6<br>解释：<br>3 层书架的高度和为 1 + 3 + 2 = 6 。<br>第 2 本书不必放在第一层书架上。<br>提示：<br>1 <= books.length <= 1000<br>1 <= books[i][0] <= shelf_width <= 1000<br>1 <= books[i][1] <= 1000
***

```python
todo
```
#### 第1125题	**最小的必要团队	困难	**
***
作为项目经理，你规划了一份需求的技能清单 req_skills，并打算从备选人员名单 people 中选出些人组成一个「必要团队」（ 编号为 i 的备选人员 people[i] 含有一份该备选人员掌握的技能列表）。<br>所谓「必要团队」，就是在这个团队中，对于所需求的技能列表 req_skills 中列出的每项技能，团队中至少有一名成员已经掌握。<br>我们可以用每个人的编号来表示团队中的成员：例如，团队 team = [0, 1, 3] 表示掌握技能分别为 people[0]，people[1]，和 people[3] 的备选人员。<br>请你返回 任一 规模最小的必要团队，团队成员用人员编号表示。你可以按任意顺序返回答案，本题保证答案存在。<br>示例 1：<br>输入：req_skills = ["java","nodejs","reactjs"], people = [["java"],["nodejs"],["nodejs","reactjs"]]<br>输出：[0,2]<br>示例 2：<br>输入：req_skills = ["algorithms","math","java","reactjs","csharp","aws"], people = [["algorithms","math","java"],["algorithms","math","reactjs"],["java","csharp","aws"],["reactjs","csharp"],["csharp","math"],["aws","java"]]<br>输出：[1,2]<br>提示：<br>1 <= req_skills.length <= 16<br>1 <= people.length <= 60<br>1 <= people[i].length, req_skills[i].length, people[i][j].length <= 16<br>req_skills 和 people[i] 中的元素分别各不相同<br>req_skills[i][j], people[i][j][k] 都由小写英文字母组成<br>本题保证「必要团队」一定存在
***

```python
todo
```
#### 第1130题	**叶值的最小代价生成树	中等	**
***
给你一个正整数数组 arr，考虑所有满足以下条件的二叉树：<br>每个节点都有 0 个或是 2 个子节点。<br>数组 arr 中的值与树的中序遍历中每个叶节点的值一一对应。（知识回顾：如果一个节点有 0 个子节点，那么该节点为叶节点。）<br>每个非叶节点的值等于其左子树和右子树中叶节点的最大值的乘积。<br>在所有这样的二叉树中，返回每个非叶节点的值的最小可能总和。这个和的值是一个 32 位整数。<br>示例：<br>输入：arr = [6,2,4]<br>输出：32<br>解释：<br>有两种可能的树，第一种的非叶节点的总和为 36，第二种非叶节点的总和为 32。<br><br>24            24<br>/  \          /  \<br>12   4        6    8<br>/  \               / \<br>6    2             2   4<br>提示：<br>2 <= arr.length <= 40<br>1 <= arr[i] <= 15<br>答案保证是一个 32 位带符号整数，即小于 2^31。
***

```python
todo
```
