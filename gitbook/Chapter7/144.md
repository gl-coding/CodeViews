# 第13节

#### 第1139题	**最大的以 1 为边界的正方形	中等	**
***
给你一个由若干 0 和 1 组成的二维网格 grid，请你找出边界全部由 1 组成的最大 正方形 子网格，并返回该子网格中的元素数量。如果不存在，则返回 0。<br>示例 1：<br>输入：grid = [[1,1,1],[1,0,1],[1,1,1]]<br>输出：9<br>示例 2：<br>输入：grid = [[1,1,0,0]]<br>输出：1<br>提示：<br>1 <= grid.length <= 100<br>1 <= grid[0].length <= 100<br>grid[i][j] 为 0 或 1
***

```python
todo
```
#### 第1140题	**石子游戏 II	中等	**
***
亚历克斯和李继续他们的石子游戏。许多堆石子 排成一行，每堆都有正整数颗石子 piles[i]。游戏以谁手中的石子最多来决出胜负。<br>亚历克斯和李轮流进行，亚历克斯先开始。最初，M = 1。<br>在每个玩家的回合中，该玩家可以拿走剩下的 前 X 堆的所有石子，其中 1 <= X <= 2M。然后，令 M = max(M, X)。<br>游戏一直持续到所有石子都被拿走。<br>假设亚历克斯和李都发挥出最佳水平，返回亚历克斯可以得到的最大数量的石头。<br>示例：<br>输入：piles = [2,7,9,4,4]<br>输出：10<br>解释：<br>如果亚历克斯在开始时拿走一堆石子，李拿走两堆，接着亚历克斯也拿走两堆。在这种情况下，亚历克斯可以拿到 2 + 4 + 4 = 10 颗石子。<br>如果亚历克斯在开始时拿走两堆石子，那么李就可以拿走剩下全部三堆石子。在这种情况下，亚历克斯可以拿到 2 + 7 = 9 颗石子。<br>所以我们返回更大的 10。<br>提示：<br>1 <= piles.length <= 100<br>1 <= piles[i] <= 10 ^ 4
***

```python
todo
```
#### 第1143题	**最长公共子序列	中等	**
***
给定两个字符串 text1 和 text2，返回这两个字符串的最长公共子序列。<br>一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。<br>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。两个字符串的「公共子序列」是这两个字符串所共同拥有的子序列。<br>若这两个字符串没有公共子序列，则返回 0。<br>示例 1:<br>输入：text1 = "abcde", text2 = "ace"<br>输出：3<br>解释：最长公共子序列是 "ace"，它的长度为 3。<br>示例 2:<br>输入：text1 = "abc", text2 = "abc"<br>输出：3<br>解释：最长公共子序列是 "abc"，它的长度为 3。<br>示例 3:<br>输入：text1 = "abc", text2 = "def"<br>输出：0<br>解释：两个字符串没有公共子序列，返回 0。<br>提示:<br>1 <= text1.length <= 1000<br>1 <= text2.length <= 1000<br>输入的字符串只含有小写英文字符。
***

```python
todo
```
#### 第1147题	**段式回文	困难	**
***
段式回文 其实与 一般回文 类似，只不过是最小的单位是 一段字符 而不是 单个字母。<br>举个例子，对于一般回文 "abcba" 是回文，而 "volvo" 不是，但如果我们把 "volvo" 分为 "vo"、"l"、"vo" 三段，则可以认为 “(vo)(l)(vo)” 是段式回文（分为 3 段）。<br>给你一个字符串 text，在确保它满足段式回文的前提下，请你返回 段 的 最大数量 k。<br>如果段的最大数量为 k，那么存在满足以下条件的 a_1, a_2, ..., a_k：<br>每个 a_i 都是一个非空字符串；<br>将这些字符串首位相连的结果 a_1 + a_2 + ... + a_k 和原始字符串 text 相同；<br>对于所有1 <= i <= k，都有 a_i = a_{k+1 - i}。<br>示例 1：<br>输入：text = "ghiabcdefhelloadamhelloabcdefghi"<br>输出：7<br>解释：我们可以把字符串拆分成 "(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)"。<br>示例 2：<br>输入：text = "merchant"<br>输出：1<br>解释：我们可以把字符串拆分成 "(merchant)"。<br>示例 3：<br>输入：text = "antaprezatepzapreanta"<br>输出：11<br>解释：我们可以把字符串拆分成 "(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)"。<br>示例 4：<br>输入：text = "aaa"<br>输出：3<br>解释：我们可以把字符串拆分成 "(a)(a)(a)"。<br>提示：<br>text 仅由小写英文字符组成。<br>1 <= text.length <= 1000
***

```python
todo
```
#### 第1155题	**掷骰子的N种方法	中等	**
***
这里有 d 个一样的骰子，每个骰子上都有 f 个面，分别标号为 1, 2, ..., f。<br>我们约定：掷骰子的得到总点数为各骰子面朝上的数字的总和。<br>如果需要掷出的总点数为 target，请你计算出有多少种不同的组合情况（所有的组合情况总共有 f^d 种），模 10^9 + 7 后返回。<br>示例 1：<br>输入：d = 1, f = 6, target = 3<br>输出：1<br>示例 2：<br>输入：d = 2, f = 6, target = 7<br>输出：6<br>示例 3：<br>输入：d = 2, f = 5, target = 10<br>输出：1<br>示例 4：<br>输入：d = 1, f = 2, target = 3<br>输出：0<br>示例 5：<br>输入：d = 30, f = 30, target = 500<br>输出：222616187<br>提示：<br>1 <= d, f <= 30<br>1 <= target <= 1000
***

```python
todo
```
#### 第1186题	**删除一次得到子数组最大和	中等	**
***
给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到的最大元素总和。<br>换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。<br>注意，删除一个元素后，子数组 不能为空。<br>请看示例：<br>示例 1：<br>输入：arr = [1,-2,0,3]<br>输出：4<br>解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。<br>示例 2：<br>输入：arr = [1,-2,-2,3]<br>输出：3<br>解释：我们直接选出 [3]，这就是最大和。<br>示例 3：<br>输入：arr = [-1,-1,-1,-1]<br>输出：-1<br>解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。<br>我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。<br>提示：<br>1 <= arr.length <= 10^5<br>-10^4 <= arr[i] <= 10^4
***

```python
todo
```
#### 第1187题	**使数组严格递增	困难	**
***
给你两个整数数组 arr1 和 arr2，返回使 arr1 严格递增所需要的最小「操作」数（可能为 0）。<br>每一步「操作」中，你可以分别从 arr1 和 arr2 中各选出一个索引，分别为 i 和 j，0 <= i < arr1.length 和 0 <= j < arr2.length，然后进行赋值运算 arr1[i] = arr2[j]。<br>如果无法让 arr1 严格递增，请返回 -1。<br>示例 1：<br>输入：arr1 = [1,5,3,6,7], arr2 = [1,3,2,4]<br>输出：1<br>解释：用 2 来替换 5，之后 arr1 = [1, 2, 3, 6, 7]。<br>示例 2：<br>输入：arr1 = [1,5,3,6,7], arr2 = [4,3,1]<br>输出：2<br>解释：用 3 来替换 5，然后用 4 来替换 3，得到 arr1 = [1, 3, 4, 6, 7]。<br>示例 3：<br>输入：arr1 = [1,5,3,6,7], arr2 = [1,6,3,3]<br>输出：-1<br>解释：无法使 arr1 严格递增。<br>提示：<br>1 <= arr1.length, arr2.length <= 2000<br>0 <= arr1[i], arr2[i] <= 10^9
***

```python
todo
```
#### 第1191题	**K 次串联后最大子数组之和	中等	**
***
给你一个整数数组 arr 和一个整数 k。<br>首先，我们要对该数组进行修改，即把原数组 arr 重复 k 次。<br>举个例子，如果 arr = [1, 2] 且 k = 3，那么修改后的数组就是 [1, 2, 1, 2, 1, 2]。<br>然后，请你返回修改后的数组中的最大的子数组之和。<br>注意，子数组长度可以是 0，在这种情况下它的总和也是 0。<br>由于 结果可能会很大，所以需要 模（mod） 10^9 + 7 后再返回。<br>示例 1：<br>输入：arr = [1,2], k = 3<br>输出：9<br>示例 2：<br>输入：arr = [1,-2,1], k = 5<br>输出：2<br>示例 3：<br>输入：arr = [-1,-2], k = 7<br>输出：0<br>提示：<br>1 <= arr.length <= 10^5<br>1 <= k <= 10^5<br>-10^4 <= arr[i] <= 10^4
***

```python
todo
```
#### 第1218题	**最长定差子序列	中等	**
***
给你一个整数数组 arr 和一个整数 difference，请你找出 arr 中所有相邻元素之间的差等于给定 difference 的等差子序列，并返回其中最长的等差子序列的长度。<br>示例 1：<br>输入：arr = [1,2,3,4], difference = 1<br>输出：4<br>解释：最长的等差子序列是 [1,2,3,4]。<br>示例 2：<br>输入：arr = [1,3,5,7], difference = 1<br>输出：1<br>解释：最长的等差子序列是任意单个元素。<br>示例 3：<br>输入：arr = [1,5,7,8,5,3,4,2,1], difference = -2<br>输出：4<br>解释：最长的等差子序列是 [7,5,3,1]。<br>提示：<br>1 <= arr.length <= 10^5<br>-10^4 <= arr[i], difference <= 10^4
***

```python
todo
```
#### 第1220题	**统计元音字母序列的数目	困难	**
***
给你一个整数 n，请你帮忙统计一下我们可以按下述规则形成多少个长度为 n 的字符串：<br>字符串中的每个字符都应当是小写元音字母（'a', 'e', 'i', 'o', 'u'）<br>每个元音 'a' 后面都只能跟着 'e'<br>每个元音 'e' 后面只能跟着 'a' 或者是 'i'<br>每个元音 'i' 后面 不能 再跟着另一个 'i'<br>每个元音 'o' 后面只能跟着 'i' 或者是 'u'<br>每个元音 'u' 后面只能跟着 'a'<br>由于答案可能会很大，所以请你返回 模 10^9 + 7 之后的结果。<br>示例 1：<br>输入：n = 1<br>输出：5<br>解释：所有可能的字符串分别是："a", "e", "i" , "o" 和 "u"。<br>示例 2：<br>输入：n = 2<br>输出：10<br>解释：所有可能的字符串分别是："ae", "ea", "ei", "ia", "ie", "io", "iu", "oi", "ou" 和 "ua"。<br>示例 3：<br>输入：n = 5<br>输出：68<br>提示：<br>1 <= n <= 2 * 10^4
***

```python
todo
```
#### 第1223题	**掷骰子模拟	中等	**
***
有一个骰子模拟器会每次投掷的时候生成一个 1 到 6 的随机数。<br>不过我们在使用它时有个约束，就是使得投掷骰子时，连续 掷出数字 i 的次数不能超过 rollMax[i]（i 从 1 开始编号）。<br>现在，给你一个整数数组 rollMax 和一个整数 n，请你来计算掷 n 次骰子可得到的不同点数序列的数量。<br>假如两个序列中至少存在一个元素不同，就认为这两个序列是不同的。由于答案可能很大，所以请返回 模 10^9 + 7 之后的结果。<br>示例 1：<br>输入：n = 2, rollMax = [1,1,2,2,2,3]<br>输出：34<br>解释：我们掷 2 次骰子，如果没有约束的话，共有 6 * 6 = 36 种可能的组合。但是根据 rollMax 数组，数字 1 和 2 最多连续出现一次，所以不会出现序列 (1,1) 和 (2,2)。因此，最终答案是 36-2 = 34。<br>示例 2：<br>输入：n = 2, rollMax = [1,1,1,1,1,1]<br>输出：30<br>示例 3：<br>输入：n = 3, rollMax = [1,1,1,2,2,3]<br>输出：181<br>提示：<br>1 <= n <= 5000<br>rollMax.length == 6<br>1 <= rollMax[i] <= 15
***

```python
todo
```
#### 第1227题	**飞机座位分配概率	中等	**
***
有 n 位乘客即将登机，飞机正好有 n 个座位。第一位乘客的票丢了，他随便选了一个座位坐下。<br>剩下的乘客将会：<br>如果他们自己的座位还空着，就坐到自己的座位上，<br>当他们自己的座位被占用时，随机选择其他座位<br>第 n 位乘客坐在自己的座位上的概率是多少？<br>示例 1：<br>输入：n = 1<br>输出：1.00000<br>解释：第一个人只会坐在自己的位置上。<br>示例 2：<br>输入: n = 2<br>输出: 0.50000<br>解释：在第一个人选好座位坐下后，第二个人坐在自己的座位上的概率是 0.5。<br>提示：<br>1 <= n <= 10^5
***

```python
todo
```
