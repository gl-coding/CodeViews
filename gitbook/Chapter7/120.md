# 第11节

#### 第940题	**不同的子序列 II	困难	**
***
给定一个字符串 S，计算 S 的不同非空子序列的个数。<br>因为结果可能很大，所以返回答案模 10^9 + 7.<br>示例 1：<br>输入："abc"<br>输出：7<br>解释：7 个不同的子序列分别是 "a", "b", "c", "ab", "ac", "bc", 以及 "abc"。<br>示例 2：<br>输入："aba"<br>输出：6<br>解释：6 个不同的子序列分别是 "a", "b", "ab", "ba", "aa" 以及 "aba"。<br>示例 3：<br>输入："aaa"<br>输出：3<br>解释：3 个不同的子序列分别是 "a", "aa" 以及 "aaa"。<br>提示：<br>S 只包含小写字母。<br>1 <= S.length <= 2000
***

```python
todo
```
#### 第943题	**最短超级串	困难	**
***
给定一个字符串数组 A，找到以 A 中每个字符串作为子字符串的最短字符串。<br>我们可以假设 A 中没有字符串是 A 中另一个字符串的子字符串。<br>示例 1：<br>输入：["alex","loves","leetcode"]<br>输出："alexlovesleetcode"<br>解释："alex"，"loves"，"leetcode" 的所有排列都会被接受。<br>示例 2：<br>输入：["catg","ctaagt","gcta","ttca","atgcatc"]<br>输出："gctaagttcatgcatc"<br>提示：<br>1 <= A.length <= 12<br>1 <= A[i].length <= 20
***

```python
todo
```
#### 第956题	**最高的广告牌	困难	**
***
你正在安装一个广告牌，并希望它高度最大。这块广告牌将有两个钢制支架，两边各一个。每个钢支架的高度必须相等。<br>你有一堆可以焊接在一起的钢筋 rods。举个例子，如果钢筋的长度为 1、2 和 3，则可以将它们焊接在一起形成长度为 6 的支架。<br>返回广告牌的最大可能安装高度。如果没法安装广告牌，请返回 0。<br>示例 1：<br>输入：[1,2,3,6]<br>输出：6<br>解释：我们有两个不相交的子集 {1,2,3} 和 {6}，它们具有相同的和 sum = 6。<br>示例 2：<br>输入：[1,2,3,4,5,6]<br>输出：10<br>解释：我们有两个不相交的子集 {2,3,5} 和 {4,6}，它们具有相同的和 sum = 10。<br>示例 3：<br>输入：[1,2]<br>输出：0<br>解释：没法安装广告牌，所以返回 0。<br>提示：<br>0 <= rods.length <= 20<br>1 <= rods[i] <= 1000<br>钢筋的长度总和最多为 5000
***

```python
todo
```
#### 第960题	**删列造序 III	困难	**
***
给定由 N 个小写字母字符串组成的数组 A，其中每个字符串长度相等。<br>选取一个删除索引序列，对于 A 中的每个字符串，删除对应每个索引处的字符。<br>比如，有 A = ["babca","bbazb"]，删除索引序列 {0, 1, 4}，删除后 A 为["bc","az"]。<br>假设，我们选择了一组删除索引 D，那么在执行删除操作之后，最终得到的数组的行中的每个元素都是按字典序排列的。<br>清楚起见，A[0] 是按字典序排列的（即，A[0][0] <= A[0][1] <= ... <= A[0][A[0].length - 1]），A[1] 是按字典序排列的（即，A[1][0] <= A[1][1] <= ... <= A[1][A[1].length - 1]），依此类推。<br>请你返回 D.length 的最小可能值。<br>示例 1：<br>输入：["babca","bbazb"]<br>输出：3<br>解释：<br>删除 0、1 和 4 这三列后，最终得到的数组是 A = ["bc", "az"]。<br>这两行是分别按字典序排列的（即，A[0][0] <= A[0][1] 且 A[1][0] <= A[1][1]）。<br>注意，A[0] > A[1] —— 数组 A 不一定是按字典序排列的。<br>示例 2：<br>输入：["edcba"]<br>输出：4<br>解释：如果删除的列少于 4 列，则剩下的行都不会按字典序排列。<br>示例 3：<br>输入：["ghi","def","abc"]<br>输出：0<br>解释：所有行都已按字典序排列。<br>提示：<br>1 <= A.length <= 100<br>1 <= A[i].length <= 100
***

```python
todo
```
#### 第964题	**表示数字的最少运算符	困难	**
***
给定一个正整数 x，我们将会写出一个形如 x (op1) x (op2) x (op3) x ... 的表达式，其中每个运算符 op1，op2，… 可以是加、减、乘、除（+，-，*，或是 /）之一。例如，对于 x = 3，我们可以写出表达式 3 * 3 / 3 + 3 - 3，该式的值为 3 。<br>在写这样的表达式时，我们需要遵守下面的惯例：<br>除运算符（/）返回有理数。<br>任何地方都没有括号。<br>我们使用通常的操作顺序：乘法和除法发生在加法和减法之前。<br>不允许使用一元否定运算符（-）。例如，“x - x” 是一个有效的表达式，因为它只使用减法，但是 “-x + x” 不是，因为它使用了否定运算符。<br>我们希望编写一个能使表达式等于给定的目标值 target 且运算符最少的表达式。返回所用运算符的最少数量。<br>示例 1：<br>输入：x = 3, target = 19<br>输出：5<br>解释：3 * 3 + 3 * 3 + 3 / 3 。表达式包含 5 个运算符。<br>示例 2：<br>输入：x = 5, target = 501<br>输出：8<br>解释：5 * 5 * 5 * 5 - 5 * 5 * 5 + 5 / 5 。表达式包含 8 个运算符。<br>示例 3：<br>输入：x = 100, target = 100000000<br>输出：3<br>解释：100 * 100 * 100 * 100 。表达式包含 3 个运算符。<br>提示：<br>2 <= x <= 100<br>1 <= target <= 2 * 10^8
***

```python
todo
```
#### 第967题	**连续差相同的数字	中等	**
***
返回所有长度为 N 且满足其每两个连续位上的数字之间的差的绝对值为 K 的非负整数。<br>请注意，除了数字 0 本身之外，答案中的每个数字都不能有前导零。例如，01 因为有一个前导零，所以是无效的；但 0 是有效的。<br>你可以按任何顺序返回答案。<br>示例 1：<br>输入：N = 3, K = 7<br>输出：[181,292,707,818,929]<br>解释：注意，070 不是一个有效的数字，因为它有前导零。<br>示例 2：<br>输入：N = 2, K = 1<br>输出：[10,12,21,23,32,34,43,45,54,56,65,67,76,78,87,89,98]<br>提示：<br>1 <= N <= 9<br>0 <= K <= 9
***

```python
todo
```
#### 第968题	**监控二叉树	困难	**
***
给定一个二叉树，我们在树的节点上安装摄像头。<br>节点上的每个摄影头都可以监视其父对象、自身及其直接子对象。<br>计算监控树的所有节点所需的最小摄像头数量。<br>示例 1：<br>输入：[0,0,null,0,0]<br>输出：1<br>解释：如图所示，一台摄像头足以监控所有节点。<br>示例 2：<br>输入：[0,0,null,0,null,0,null,null,0]<br>输出：2<br>解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。<br><br>提示：<br>给定树的节点数的范围是 [1, 1000]。<br>每个节点的值都是 0。
***

```python
todo
```
#### 第975题	**奇偶跳	困难	**
***
给定一个整数数组 A，你可以从某一起始索引出发，跳跃一定次数。在你跳跃的过程中，第 1、3、5... 次跳跃称为奇数跳跃，而第 2、4、6... 次跳跃称为偶数跳跃。<br>你可以按以下方式从索引 i 向后跳转到索引 j（其中 i < j）：<br>在进行奇数跳跃时（如，第 1，3，5... 次跳跃），你将会跳到索引 j，使得 A[i] <= A[j]，A[j] 是可能的最小值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。<br>在进行偶数跳跃时（如，第 2，4，6... 次跳跃），你将会跳到索引 j，使得 A[i] => A[j]，A[j] 是可能的最大值。如果存在多个这样的索引 j，你只能跳到满足要求的最小索引 j 上。<br>（对于某些索引 i，可能无法进行合乎要求的跳跃。）<br>如果从某一索引开始跳跃一定次数（可能是 0 次或多次），就可以到达数组的末尾（索引 A.length - 1），那么该索引就会被认为是好的起始索引。<br>返回好的起始索引的数量。<br>示例 1：<br>输入：[10,13,12,14,15]<br>输出：2<br>解释：<br>从起始索引 i = 0 出发，我们可以跳到 i = 2，（因为 A[2] 是 A[1]，A[2]，A[3]，A[4] 中大于或等于 A[0] 的最小值），然后我们就无法继续跳下去了。<br>从起始索引 i = 1 和 i = 2 出发，我们可以跳到 i = 3，然后我们就无法继续跳下去了。<br>从起始索引 i = 3 出发，我们可以跳到 i = 4，到达数组末尾。<br>从起始索引 i = 4 出发，我们已经到达数组末尾。<br>总之，我们可以从 2 个不同的起始索引（i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。<br>示例 2：<br>输入：[2,3,1,1,4]<br>输出：3<br>解释：<br>从起始索引 i=0 出发，我们依次可以跳到 i = 1，i = 2，i = 3：<br><br>在我们的第一次跳跃（奇数）中，我们先跳到 i = 1，因为 A[1] 是（A[1]，A[2]，A[3]，A[4]）中大于或等于 A[0] 的最小值。<br><br>在我们的第二次跳跃（偶数）中，我们从 i = 1 跳到 i = 2，因为 A[2] 是（A[2]，A[3]，A[4]）中小于或等于 A[1] 的最大值。A[3] 也是最大的值，但 2 是一个较小的索引，所以我们只能跳到 i = 2，而不能跳到 i = 3。<br><br>在我们的第三次跳跃（奇数）中，我们从 i = 2 跳到 i = 3，因为 A[3] 是（A[3]，A[4]）中大于或等于 A[2] 的最小值。<br><br>我们不能从 i = 3 跳到 i = 4，所以起始索引 i = 0 不是好的起始索引。<br><br>类似地，我们可以推断：<br>从起始索引 i = 1 出发， 我们跳到 i = 4，这样我们就到达数组末尾。<br>从起始索引 i = 2 出发， 我们跳到 i = 3，然后我们就不能再跳了。<br>从起始索引 i = 3 出发， 我们跳到 i = 4，这样我们就到达数组末尾。<br>从起始索引 i = 4 出发，我们已经到达数组末尾。<br>总之，我们可以从 3 个不同的起始索引（i = 1, i = 3, i = 4）出发，通过一定数量的跳跃到达数组末尾。<br>示例 3：<br>输入：[5,1,3,4,2]<br>输出：3<br>解释：<br>我们可以从起始索引 1，2，4 出发到达数组末尾。<br>提示：<br>1 <= A.length <= 20000<br>0 <= A[i] < 100000
***

```python
todo
```
#### 第978题	**最长湍流子数组	中等	**
***
当 A 的子数组 A[i], A[i+1], ..., A[j] 满足下列条件时，我们称其为湍流子数组：<br>若 i <= k < j，当 k 为奇数时， A[k] > A[k+1]，且当 k 为偶数时，A[k] < A[k+1]；<br>或 若 i <= k < j，当 k 为偶数时，A[k] > A[k+1] ，且当 k 为奇数时， A[k] < A[k+1]。<br>也就是说，如果比较符号在子数组中的每个相邻元素对之间翻转，则该子数组是湍流子数组。<br>返回 A 的最大湍流子数组的长度。<br>示例 1：<br>输入：[9,4,2,10,7,8,8,1,9]<br>输出：5<br>解释：(A[1] > A[2] < A[3] > A[4] < A[5])<br>示例 2：<br>输入：[4,8,12,16]<br>输出：2<br>示例 3：<br>输入：[100]<br>输出：1<br>提示：<br>1 <= A.length <= 40000<br>0 <= A[i] <= 10^9
***

```python
todo
```
#### 第982题	**按位与为零的三元组	困难	**
***
给定一个整数数组 A，找出索引为 (i, j, k) 的三元组，使得：<br>0 <= i < A.length<br>0 <= j < A.length<br>0 <= k < A.length<br>A[i] & A[j] & A[k] == 0，其中 & 表示按位与（AND）操作符。<br>示例：<br>输入：[2,1,3]<br>输出：12<br>解释：我们可以选出如下 i, j, k 三元组：<br>(i=0, j=0, k=1) : 2 & 2 & 1<br>(i=0, j=1, k=0) : 2 & 1 & 2<br>(i=0, j=1, k=1) : 2 & 1 & 1<br>(i=0, j=1, k=2) : 2 & 1 & 3<br>(i=0, j=2, k=1) : 2 & 3 & 1<br>(i=1, j=0, k=0) : 1 & 2 & 2<br>(i=1, j=0, k=1) : 1 & 2 & 1<br>(i=1, j=0, k=2) : 1 & 2 & 3<br>(i=1, j=1, k=0) : 1 & 1 & 2<br>(i=1, j=2, k=0) : 1 & 3 & 2<br>(i=2, j=0, k=1) : 3 & 2 & 1<br>(i=2, j=1, k=0) : 3 & 1 & 2<br>提示：<br>1 <= A.length <= 1000<br>0 <= A[i] < 2^16
***

```python
todo
```
#### 第983题	**最低票价	中等	**
***
在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行。在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出。每一项是一个从 1 到 365 的整数。<br>火车票有三种不同的销售方式：<br>一张为期一天的通行证售价为 costs[0] 美元；<br>一张为期七天的通行证售价为 costs[1] 美元；<br>一张为期三十天的通行证售价为 costs[2] 美元。<br>通行证允许数天无限制的旅行。 例如，如果我们在第 2 天获得一张为期 7 天的通行证，那么我们可以连着旅行 7 天：第 2 天、第 3 天、第 4 天、第 5 天、第 6 天、第 7 天和第 8 天。<br>返回你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费。<br>示例 1：<br>输入：days = [1,4,6,7,8,20], costs = [2,7,15]<br>输出：11<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 1 天生效。<br>在第 3 天，你花了 costs[1] = $7 买了一张为期 7 天的通行证，它将在第 3, 4, ..., 9 天生效。<br>在第 20 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 20 天生效。<br>你总共花了 $11，并完成了你计划的每一天旅行。<br>示例 2：<br>输入：days = [1,2,3,4,5,6,7,8,9,10,30,31], costs = [2,7,15]<br>输出：17<br>解释：<br>例如，这里有一种购买通行证的方法，可以让你完成你的旅行计划：<br>在第 1 天，你花了 costs[2] = $15 买了一张为期 30 天的通行证，它将在第 1, 2, ..., 30 天生效。<br>在第 31 天，你花了 costs[0] = $2 买了一张为期 1 天的通行证，它将在第 31 天生效。<br>你总共花了 $17，并完成了你计划的每一天旅行。<br>提示：<br>1 <= days.length <= 365<br>1 <= days[i] <= 365<br>days 按顺序严格递增<br>costs.length == 3<br>1 <= costs[i] <= 1000
***

```python
todo
```
#### 第1000题	**合并石头的最低成本	困难	**
***
有 N 堆石头排成一排，第 i 堆中有 stones[i] 块石头。<br>每次移动（move）需要将连续的 K 堆石头合并为一堆，而这个移动的成本为这 K 堆石头的总数。<br>找出把所有石头合并成一堆的最低成本。如果不可能，返回 -1 。<br>示例 1：<br>输入：stones = [3,2,4,1], K = 2<br>输出：20<br>解释：<br>从 [3, 2, 4, 1] 开始。<br>合并 [3, 2]，成本为 5，剩下 [5, 4, 1]。<br>合并 [4, 1]，成本为 5，剩下 [5, 5]。<br>合并 [5, 5]，成本为 10，剩下 [10]。<br>总成本 20，这是可能的最小值。<br>示例 2：<br>输入：stones = [3,2,4,1], K = 3<br>输出：-1<br>解释：任何合并操作后，都会剩下 2 堆，我们无法再进行合并。所以这项任务是不可能完成的。.<br>示例 3：<br>输入：stones = [3,5,1,2,6], K = 3<br>输出：25<br>解释：<br>从 [3, 5, 1, 2, 6] 开始。<br>合并 [5, 1, 2]，成本为 8，剩下 [3, 8, 6]。<br>合并 [3, 8, 6]，成本为 17，剩下 [17]。<br>总成本 25，这是可能的最小值。<br>提示：<br>1 <= stones.length <= 30<br>2 <= K <= 30<br>1 <= stones[i] <= 100
***

```python
todo
```
