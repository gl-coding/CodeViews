# 第4节

#### 第306题	**累加数	中等	**
***
累加数是一个字符串，组成它的数字可以形成累加序列。<br>一个有效的累加序列必须至少包含 3 个数。除了最开始的两个数以外，字符串中的其他数都等于它之前两个数相加的和。<br>给定一个只包含数字 '0'-'9' 的字符串，编写一个算法来判断给定输入是否是累加数。<br>说明: 累加序列里的数不会以 0 开头，所以不会出现 1, 2, 03 或者 1, 02, 3 的情况。<br>示例 1:<br>输入: "112358"<br>输出: true<br>解释: 累加序列为: 1, 1, 2, 3, 5, 8 。1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8<br>示例 2:<br>输入: "199100199"<br>输出: true<br>解释: 累加序列为: 1, 99, 100, 199。1 + 99 = 100, 99 + 100 = 199<br>进阶:<br>你如何处理一个溢出的过大的整数输入?
***

```python
class Solution(object):
    def isAdditiveNumber(self, num):
        """
        :type num: str
        :rtype: bool
        """
        n = len(num)
        for x in range(0, n / 2):
            if x > 0 and num[0] == "0":
                break
            for y in range(x + 1, n):
                if y - x > 1 and num[x+1] == "0":
                    break
                i, j, k = 0, x, y
                while k < n:
                    a = int(num[i:j+1])
                    b = int(num[j+1:k+1])
                    add = str(int(a + b))
                    if not num.startswith(add, k + 1):
                        break
                    if len(add) + 1 + k == len(num):
                        return True
                    i = j + 1
                    j = k
                    k = k + len(add)
        return False```
#### 第357题	**计算各个位数不同的数字个数	中等	**
***
给定一个非负整数 n，计算各位数字都不同的数字 x 的个数，其中 0 ≤ x < 10n 。<br>示例:<br>输入: 2<br>输出: 91<br>解释: 答案应为除去 11,22,33,44,55,66,77,88,99 外，在 [0,100) 区间内的所有数字。
***

```python
class Solution(object):
    def countNumbersWithUniqueDigits(self, n):
        """
        :type n: int
        :rtype: int4
        """
        if n <= 1:
            return 10 ** n
        dp = [0] * (n + 1)
        dp[0] = 0
        dp[1] = 9
        k = 9
        for i in xrange(2, n + 1):
            dp[i] = max(dp[i - 1] * k, 0)
            k -= 1
        return sum(dp) + 1```
#### 第401题	**二进制手表	简单	**
***
二进制手表顶部有 4 个 LED 代表小时（0-11），底部的 6 个 LED 代表分钟（0-59）。<br>每个 LED 代表一个 0 或 1，最低位在右侧。<br>例如，上面的二进制手表读取 “3:25”。<br>给定一个非负整数 n 代表当前 LED 亮着的数量，返回所有可能的时间。<br>案例:<br>输入: n = 1<br>返回: ["1:00", "2:00", "4:00", "8:00", "0:01", "0:02", "0:04", "0:08", "0:16", "0:32"]<br>注意事项:<br>输出的顺序没有要求。<br>小时不会以零开头，比如 “01:00” 是不允许的，应为 “1:00”。<br>分钟必须由两位数组成，可能会以零开头，比如 “10:2” 是无效的，应为 “10:02”。
***

```python
class Solution(object):
    def readBinaryWatch(self, num):
        """
        :type num: int
        :rtype: List[str]
        """
        ans = []
        for i in range(0, 12):
            for j in range(0, 60):
                if (bin(i) + bin(j)).count("1") == num:
                    ans.append("%d:%02d" % (i, j))
        return ans```
#### 第526题	**优美的排列	中等	**
***
假设有从 1 到 N 的 N 个整数，如果从这 N 个数字中成功构造出一个数组，使得数组的第 i 位 (1 <= i <= N) 满足如下两个条件中的一个，我们就称这个数组为一个优美的排列。条件：<br>第 i 位的数字能被 i 整除<br>i 能被第 i 位上的数字整除<br>现在给定一个整数 N，请问可以构造多少个优美的排列？<br>示例1:<br>输入: 2<br>输出: 2<br>解释:<br><br>第 1 个优美的排列是 [1, 2]:<br>第 1 个位置（i=1）上的数字是1，1能被 i（i=1）整除<br>第 2 个位置（i=2）上的数字是2，2能被 i（i=2）整除<br><br>第 2 个优美的排列是 [2, 1]:<br>第 1 个位置（i=1）上的数字是2，2能被 i（i=1）整除<br>第 2 个位置（i=2）上的数字是1，i（i=2）能被 1 整除<br>说明:<br>N 是一个正整数，并且不会超过15。
***

```python
class Solution(object):
    def countArrangement(self, N):
        """
        :type N: int
        :rtype: int
        """
        def dfs(pos, unused):
            if len(unused) == 0:
                return 1
            ret = 0
            for num in list(unused):
                if pos % num == 0 or num % pos == 0:
                    unused -= {num}
                    ret += dfs(pos + 1, unused)
                    unused |= {num}
            return ret
        return dfs(1, set([i for i in range(1, N + 1)]))

```
#### 第691题	**贴纸拼词	困难	**
***
我们给出了 N 种不同类型的贴纸。每个贴纸上都有一个小写的英文单词。<br>你希望从自己的贴纸集合中裁剪单个字母并重新排列它们，从而拼写出给定的目标字符串 target。<br>如果你愿意的话，你可以不止一次地使用每一张贴纸，而且每一张贴纸的数量都是无限的。<br>拼出目标 target 所需的最小贴纸数量是多少？如果任务不可能，则返回 -1。<br>示例 1：<br>输入：<br>["with", "example", "science"], "thehat"<br>输出：<br>3<br>解释：<br>我们可以使用 2 个 "with" 贴纸，和 1 个 "example" 贴纸。<br>把贴纸上的字母剪下来并重新排列后，就可以形成目标 “thehat“ 了。<br>此外，这是形成目标字符串所需的最小贴纸数量。<br>示例 2：<br>输入：<br>["notice", "possible"], "basicbasic"<br>输出：<br>-1<br>解释：<br>我们不能通过剪切给定贴纸的字母来形成目标“basicbasic”。<br>提示：<br>stickers 长度范围是 [1, 50]。<br>stickers 由小写英文单词组成（不带撇号）。<br>target 的长度在 [1, 15] 范围内，由小写字母组成。<br>在所有的测试案例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选取的，目标是两个随机单词的串联。<br>时间限制可能比平时更具挑战性。预计 50 个贴纸的测试案例平均可在35ms内解决。
***

```python
todo
```
#### 第784题	**字母大小写全排列	简单	**
***
给定一个字符串S，通过将字符串S中的每个字母转变大小写，我们可以获得一个新的字符串。返回所有可能得到的字符串集合。<br>示例:<br>输入: S = "a1b2"<br>输出: ["a1b2", "a1B2", "A1b2", "A1B2"]<br><br>输入: S = "3z4"<br>输出: ["3z4", "3Z4"]<br><br>输入: S = "12345"<br>输出: ["12345"]<br>注意：<br>S 的长度不超过12。<br>S 仅由数字和字母组成。
***

```python
todo
```
#### 第842题	**将数组拆分成斐波那契序列	中等	**
***
给定一个数字字符串 S，比如 S = "123456579"，我们可以将它分成斐波那契式的序列 [123, 456, 579]。<br>形式上，斐波那契式序列是一个非负整数列表 F，且满足：<br>0 <= F[i] <= 2^31 - 1，（也就是说，每个整数都符合 32 位有符号整数类型）；<br>F.length >= 3；<br>对于所有的0 <= i < F.length - 2，都有 F[i] + F[i+1] = F[i+2] 成立。<br>另外，请注意，将字符串拆分成小块时，每个块的数字一定不要以零开头，除非这个块是数字 0 本身。<br>返回从 S 拆分出来的所有斐波那契式的序列块，如果不能拆分则返回 []。<br>示例 1：<br>输入："123456579"<br>输出：[123,456,579]<br>示例 2：<br>输入: "11235813"<br>输出: [1,1,2,3,5,8,13]<br>示例 3：<br>输入: "112358130"<br>输出: []<br>解释: 这项任务无法完成。<br>示例 4：<br>输入："0123"<br>输出：[]<br>解释：每个块的数字不能以零开头，因此 "01"，"2"，"3" 不是有效答案。<br>示例 5：<br>输入: "1101111"<br>输出: [110, 1, 111]<br>解释: 输出 [11,0,11,11] 也同样被接受。<br>提示：<br>1 <= S.length <= 200<br>字符串 S 中只含有数字。
***

```python
todo
```
#### 第980题	**不同路径 III	困难	**
***
在二维网格 grid 上，有 4 种类型的方格：<br>1 表示起始方格。且只有一个起始方格。<br>2 表示结束方格，且只有一个结束方格。<br>0 表示我们可以走过的空方格。<br>-1 表示我们无法跨越的障碍。<br>返回在四个方向（上、下、左、右）上行走时，从起始方格到结束方格的不同路径的数目，每一个无障碍方格都要通过一次。<br>示例 1：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,2,-1]]<br>输出：2<br>解释：我们有以下两条路径：<br>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2)<br>2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2)<br>示例 2：<br>输入：[[1,0,0,0],[0,0,0,0],[0,0,0,2]]<br>输出：4<br>解释：我们有以下四条路径：<br>1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3)<br>2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3)<br>3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3)<br>4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3)<br>示例 3：<br>输入：[[0,1],[2,0]]<br>输出：0<br>解释：<br>没有一条路能完全穿过每一个空的方格一次。<br>请注意，起始和结束方格可以位于网格中的任意位置。<br>提示：<br>1 <= grid.length * grid[0].length <= 20
***

```python
todo
```
#### 第996题	**正方形数组的数目	困难	**
***
给定一个非负整数数组 A，如果该数组每对相邻元素之和是一个完全平方数，则称这一数组为正方形数组。<br>返回 A 的正方形排列的数目。两个排列 A1 和 A2 不同的充要条件是存在某个索引 i，使得 A1[i] != A2[i]。<br>示例 1：<br>输入：[1,17,8]<br>输出：2<br>解释：<br>[1,8,17] 和 [17,8,1] 都是有效的排列。<br>示例 2：<br>输入：[2,2,2]<br>输出：1<br>提示：<br>1 <= A.length <= 12<br>0 <= A[i] <= 1e9
***

```python
todo
```
#### 第1079题	**活字印刷	中等	**
***
你有一套活字字模 tiles，其中每个字模上都刻有一个字母 tiles[i]。返回你可以印出的非空字母序列的数目。<br>示例 1：<br>输入："AAB"<br>输出：8<br>解释：可能的序列为 "A", "B", "AA", "AB", "BA", "AAB", "ABA", "BAA"。<br>示例 2：<br>输入："AAABBC"<br>输出：188<br>提示：<br>1 <= tiles.length <= 7<br>tiles 由大写英文字母组成
***

```python
todo
```
#### 第1219题	**黄金矿工	中等	**
***
你要开发一座金矿，地质勘测学家已经探明了这座金矿中的资源分布，并用大小为 m * n 的网格 grid 进行了标注。每个单元格中的整数就表示这一单元格中的黄金数量；如果该单元格是空的，那么就是 0。<br>为了使收益最大化，矿工需要按以下规则来开采黄金：<br>每当矿工进入一个单元，就会收集该单元格中的所有黄金。<br>矿工每次可以从当前位置向上下左右四个方向走。<br>每个单元格只能被开采（进入）一次。<br>不得开采（进入）黄金数目为 0 的单元格。<br>矿工可以从网格中 任意一个 有黄金的单元格出发或者是停止。<br>示例 1：<br>输入：grid = [[0,6,0],[5,8,7],[0,9,0]]<br>输出：24<br>解释：<br>[[0,6,0],<br>[5,8,7],<br>[0,9,0]]<br>一种收集最多黄金的路线是：9 -> 8 -> 7。<br>示例 2：<br>输入：grid = [[1,0,7],[2,0,6],[3,4,5],[0,3,0],[9,0,20]]<br>输出：28<br>解释：<br>[[1,0,7],<br>[2,0,6],<br>[3,4,5],<br>[0,3,0],<br>[9,0,20]]<br>一种收集最多黄金的路线是：1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7。<br>提示：<br>1 <= grid.length, grid[i].length <= 15<br>0 <= grid[i][j] <= 100<br>最多 25 个单元格中有黄金。
***

```python
todo
```
#### 第1239题	**串联字符串的最大长度	中等	**
***
给定一个字符串数组 arr，字符串 s 是将 arr 某一子序列字符串连接所得的字符串，如果 s 中的每一个字符都只出现过一次，那么它就是一个可行解。<br>请返回所有可行解 s 中最长长度。<br>示例 1：<br>输入：arr = ["un","iq","ue"]<br>输出：4<br>解释：所有可能的串联组合是 "","un","iq","ue","uniq" 和 "ique"，最大长度为 4。<br>示例 2：<br>输入：arr = ["cha","r","act","ers"]<br>输出：6<br>解释：可能的解答有 "chaers" 和 "acters"。<br>示例 3：<br>输入：arr = ["abcdefghijklmnopqrstuvwxyz"]<br>输出：26<br>提示：<br>1 <= arr.length <= 16<br>1 <= arr[i].length <= 26<br>arr[i] 中只含有小写英文字母
***

```python
todo
```
