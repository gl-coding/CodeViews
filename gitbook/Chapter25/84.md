# 第8节

#### 第954题	**二倍数对数组	中等	**
***
给定一个长度为偶数的整数数组 A，只有对 A 进行重组后可以满足 “对于每个 0 <= i < len(A) / 2，都有 A[2 * i + 1] = 2 * A[2 * i]” 时，返回 true；否则，返回 false。<br>示例 1：<br>输入：[3,1,3,6]<br>输出：false<br>示例 2：<br>输入：[2,1,2,6]<br>输出：false<br>示例 3：<br>输入：[4,-2,2,-4]<br>输出：true<br>解释：我们可以用 [-2,-4] 和 [2,4] 这两组组成 [-2,-4,2,4] 或是 [2,4,-2,-4]<br>示例 4：<br>输入：[1,2,4,16,8,4]<br>输出：false<br>提示：<br>0 <= A.length <= 30000<br>A.length 为偶数<br>-100000 <= A[i] <= 100000
***

```python
todo
```
#### 第957题	**N 天后的牢房	中等	**
***
8 间牢房排成一排，每间牢房不是有人住就是空着。<br>每天，无论牢房是被占用或空置，都会根据以下规则进行更改：<br>如果一间牢房的两个相邻的房间都被占用或都是空的，那么该牢房就会被占用。<br>否则，它就会被空置。<br>（请注意，由于监狱中的牢房排成一行，所以行中的第一个和最后一个房间无法有两个相邻的房间。）<br>我们用以下方式描述监狱的当前状态：如果第 i 间牢房被占用，则 cell[i]==1，否则 cell[i]==0。<br>根据监狱的初始状态，在 N 天后返回监狱的状况（和上述 N 种变化）。<br>示例 1：<br>输入：cells = [0,1,0,1,1,0,0,1], N = 7<br>输出：[0,0,1,1,0,0,0,0]<br>解释：<br>下表概述了监狱每天的状况：<br>Day 0: [0, 1, 0, 1, 1, 0, 0, 1]<br>Day 1: [0, 1, 1, 0, 0, 0, 0, 0]<br>Day 2: [0, 0, 0, 0, 1, 1, 1, 0]<br>Day 3: [0, 1, 1, 0, 0, 1, 0, 0]<br>Day 4: [0, 0, 0, 0, 0, 1, 0, 0]<br>Day 5: [0, 1, 1, 1, 0, 1, 0, 0]<br>Day 6: [0, 0, 1, 0, 1, 1, 0, 0]<br>Day 7: [0, 0, 1, 1, 0, 0, 0, 0]<br>示例 2：<br>输入：cells = [1,0,0,1,0,0,1,0], N = 1000000000<br>输出：[0,0,1,1,1,1,1,0]<br>提示：<br>cells.length == 8<br>cells[i] 的值为 0 或 1<br>1 <= N <= 10^9
***

```python
todo
```
#### 第961题	**重复 N 次的元素	简单	**
***
在大小为 2N 的数组 A 中有 N+1 个不同的元素，其中有一个元素重复了 N 次。<br>返回重复了 N 次的那个元素。<br>示例 1：<br>输入：[1,2,3,3]<br>输出：3<br>示例 2：<br>输入：[2,1,2,5,3,2]<br>输出：2<br>示例 3：<br>输入：[5,1,5,2,5,3,5,4]<br>输出：5<br>提示：<br>4 <= A.length <= 10000<br>0 <= A[i] < 10000<br>A.length 为偶数
***

```python
todo
```
#### 第966题	**元音拼写检查器	中等	**
***
在给定单词列表 wordlist 的情况下，我们希望实现一个拼写检查器，将查询单词转换为正确的单词。<br>对于给定的查询单词 query，拼写检查器将会处理两类拼写错误：<br>大小写：如果查询匹配单词列表中的某个单词（不区分大小写），则返回的正确单词与单词列表中的大小写相同。<br>例如：wordlist = ["yellow"], query = "YellOw": correct = "yellow"<br>例如：wordlist = ["Yellow"], query = "yellow": correct = "Yellow"<br>例如：wordlist = ["yellow"], query = "yellow": correct = "yellow"<br>元音错误：如果在将查询单词中的元音（‘a’、‘e’、‘i’、‘o’、‘u’）分别替换为任何元音后，能与单词列表中的单词匹配（不区分大小写），则返回的正确单词与单词列表中的匹配项大小写相同。<br>例如：wordlist = ["YellOw"], query = "yollow": correct = "YellOw"<br>例如：wordlist = ["YellOw"], query = "yeellow": correct = "" （无匹配项）<br>例如：wordlist = ["YellOw"], query = "yllw": correct = "" （无匹配项）<br>此外，拼写检查器还按照以下优先级规则操作：<br>当查询完全匹配单词列表中的某个单词（区分大小写）时，应返回相同的单词。<br>当查询匹配到大小写问题的单词时，您应该返回单词列表中的第一个这样的匹配项。<br>当查询匹配到元音错误的单词时，您应该返回单词列表中的第一个这样的匹配项。<br>如果该查询在单词列表中没有匹配项，则应返回空字符串。<br>给出一些查询 queries，返回一个单词列表 answer，其中 answer[i] 是由查询 query = queries[i] 得到的正确单词。<br>示例：<br>输入：wordlist = ["KiTe","kite","hare","Hare"], queries = ["kite","Kite","KiTe","Hare","HARE","Hear","hear","keti","keet","keto"]<br>输出：["kite","KiTe","KiTe","Hare","hare","","","KiTe","","KiTe"]<br>提示：<br>1 <= wordlist.length <= 5000<br>1 <= queries.length <= 5000<br>1 <= wordlist[i].length <= 7<br>1 <= queries[i].length <= 7<br>wordlist 和 queries 中的所有字符串仅由英文字母组成。
***

```python
todo
```
#### 第970题	**强整数	简单	**
***
给定两个正整数 x 和 y，如果某一整数等于 x^i + y^j，其中整数 i >= 0 且 j >= 0，那么我们认为该整数是一个强整数。<br>返回值小于或等于 bound 的所有强整数组成的列表。<br>你可以按任何顺序返回答案。在你的回答中，每个值最多出现一次。<br>示例 1：<br>输入：x = 2, y = 3, bound = 10<br>输出：[2,3,4,5,7,9,10]<br>解释：<br>2 = 2^0 + 3^0<br>3 = 2^1 + 3^0<br>4 = 2^0 + 3^1<br>5 = 2^1 + 3^1<br>7 = 2^2 + 3^1<br>9 = 2^3 + 3^0<br>10 = 2^0 + 3^2<br>示例 2：<br>输入：x = 3, y = 5, bound = 15<br>输出：[2,4,6,8,10,14]<br>提示：<br>1 <= x <= 100<br>1 <= y <= 100<br>0 <= bound <= 10^6
***

```python
todo
```
#### 第974题	**和可被 K 整除的子数组	中等	**
***
给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目。<br>示例：<br>输入：A = [4,5,0,-2,-3,1], K = 5<br>输出：7<br>解释：<br>有 7 个子数组满足其元素之和可被 K = 5 整除：<br>[4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]<br>提示：<br>1 <= A.length <= 30000<br>-10000 <= A[i] <= 10000<br>2 <= K <= 10000
***

```python
todo
```
#### 第981题	**基于时间的键值存储	中等	**
***
创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：<br>1. set(string key, string value, int timestamp)<br>存储键 key、值 value，以及给定的时间戳 timestamp。<br>2. get(string key, int timestamp)<br>返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev <= timestamp。<br>如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。<br>如果没有值，则返回空字符串（""）。<br>示例 1：<br>输入：inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]]<br>输出：[null,null,"bar","bar",null,"bar2","bar2"]<br>解释：<br>TimeMap kv;<br>kv.set("foo", "bar", 1); // 存储键 "foo" 和值 "bar" 以及时间戳 timestamp = 1<br>kv.get("foo", 1);  // 输出 "bar"<br>kv.get("foo", 3); // 输出 "bar" 因为在时间戳 3 和时间戳 2 处没有对应 "foo" 的值，所以唯一的值位于时间戳 1 处（即 "bar"）<br>kv.set("foo", "bar2", 4);<br>kv.get("foo", 4); // 输出 "bar2"<br>kv.get("foo", 5); // 输出 "bar2"<br>示例 2：<br>输入：inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]]<br>输出：[null,null,null,"","high","high","low","low"]<br>提示：<br>所有的键/值字符串都是小写的。<br>所有的键/值字符串长度都在 [1, 100] 范围内。<br>所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。<br>1 <= timestamp <= 10^7<br>TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。
***

```python
todo
```
#### 第987题	**二叉树的垂序遍历	中等	**
***
给定二叉树，按垂序遍历返回其结点值。<br>对位于 (X, Y) 的每个结点而言，其左右子结点分别位于 (X-1, Y-1) 和 (X+1, Y-1)。<br>把一条垂线从 X = -infinity 移动到 X = +infinity ，每当该垂线与结点接触时，我们按从上到下的顺序报告结点的值（ Y 坐标递减）。<br>如果两个结点位置相同，则首先报告的结点值较小。<br>按 X 坐标顺序返回非空报告的列表。每个报告都有一个结点值列表。<br>示例 1：<br>输入：[3,9,20,null,null,15,7]<br>输出：[[9],[3,15],[20],[7]]<br>解释：<br>在不丧失其普遍性的情况下，我们可以假设根结点位于 (0, 0)：<br>然后，值为 9 的结点出现在 (-1, -1)；<br>值为 3 和 15 的两个结点分别出现在 (0, 0) 和 (0, -2)；<br>值为 20 的结点出现在 (1, -1)；<br>值为 7 的结点出现在 (2, -2)。<br>示例 2：<br>输入：[1,2,3,4,5,6,7]<br>输出：[[4],[2],[1,5,6],[3],[7]]<br>解释：<br>根据给定的方案，值为 5 和 6 的两个结点出现在同一位置。<br>然而，在报告 "[1,5,6]" 中，结点值 5 排在前面，因为 5 小于 6。<br>提示：<br>树的结点数介于 1 和 1000 之间。<br>每个结点值介于 0 和 1000 之间。
***

```python
todo
```
#### 第992题	**K 个不同整数的子数组	困难	**
***
给定一个正整数数组 A，如果 A 的某个子数组中不同整数的个数恰好为 K，则称 A 的这个连续、不一定独立的子数组为好子数组。<br>（例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。）<br>返回 A 中好子数组的数目。<br>示例 1：<br>输出：A = [1,2,1,2,3], K = 2<br>输入：7<br>解释：恰好由 2 个不同整数组成的子数组：[1,2], [2,1], [1,2], [2,3], [1,2,1], [2,1,2], [1,2,1,2].<br>示例 2：<br>输入：A = [1,2,1,3,4], K = 3<br>输出：3<br>解释：恰好由 3 个不同整数组成的子数组：[1,2,1,3], [2,1,3], [1,3,4].<br>提示：<br>1 <= A.length <= 20000<br>1 <= A[i] <= A.length<br>1 <= K <= A.length
***

```python
todo
```
#### 第1001题	**网格照明	困难	**
***
在 N x N 的网格上，每个单元格 (x, y) 上都有一盏灯，其中 0 <= x < N 且 0 <= y < N 。<br>最初，一定数量的灯是亮着的。lamps[i] 告诉我们亮着的第 i 盏灯的位置。每盏灯都照亮其所在 x 轴、y 轴和两条对角线上的每个正方形（类似于国际象棋中的皇后）。<br>对于第 i 次查询 queries[i] = (x, y)，如果单元格 (x, y) 是被照亮的，则查询结果为 1，否则为 0 。<br>在每个查询 (x, y) 之后 [按照查询的顺序]，我们关闭位于单元格 (x, y) 上或其相邻 8 个方向上（与单元格 (x, y) 共享一个角或边）的任何灯。<br>返回答案数组 answer。每个值 answer[i] 应等于第 i 次查询 queries[i] 的结果。<br>示例：<br>输入：N = 5, lamps = [[0,0],[4,4]], queries = [[1,1],[1,0]]<br>输出：[1,0]<br>解释：<br>在执行第一次查询之前，我们位于 [0, 0] 和 [4, 4] 灯是亮着的。<br>表示哪些单元格亮起的网格如下所示，其中 [0, 0] 位于左上角：<br>1 1 1 1 1<br>1 1 0 0 1<br>1 0 1 0 1<br>1 0 0 1 1<br>1 1 1 1 1<br>然后，由于单元格 [1, 1] 亮着，第一次查询返回 1。在此查询后，位于 [0，0] 处的灯将关闭，网格现在如下所示：<br>1 0 0 0 1<br>0 1 0 0 1<br>0 0 1 0 1<br>0 0 0 1 1<br>1 1 1 1 1<br>在执行第二次查询之前，我们只有 [4, 4] 处的灯亮着。现在，[1, 0] 处的查询返回 0，因为该单元格不再亮着。<br>提示：<br>1 <= N <= 10^9<br>0 <= lamps.length <= 20000<br>0 <= queries.length <= 20000<br>lamps[i].length == queries[i].length == 2
***

```python
todo
```
#### 第1002题	**查找常用字符	简单	**
***
给定仅有小写字母组成的字符串数组 A，返回列表中的每个字符串中都显示的全部字符（包括重复字符）组成的列表。例如，如果一个字符在每个字符串中出现 3 次，但不是 4 次，则需要在最终答案中包含该字符 3 次。<br>你可以按任意顺序返回答案。<br>示例 1：<br>输入：["bella","label","roller"]<br>输出：["e","l","l"]<br>示例 2：<br>输入：["cool","lock","cook"]<br>输出：["c","o"]<br>提示：<br>1 <= A.length <= 100<br>1 <= A[i].length <= 100<br>A[i][j] 是小写字母
***

```python
todo
```
#### 第1044题	**最长重复子串	困难	**
***
给出一个字符串 S，考虑其所有重复子串（S 的连续子串，出现两次或多次，可能会有重叠）。<br>返回任何具有最长可能长度的重复子串。（如果 S 不含重复子串，那么答案为 ""。）<br>示例 1：<br>输入："banana"<br>输出："ana"<br>示例 2：<br>输入："abcd"<br>输出：""<br>提示：<br>2 <= S.length <= 10^5<br>S 由小写英文字母组成。
***

```python
todo
```
