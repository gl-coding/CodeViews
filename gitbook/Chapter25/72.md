# 第7节

#### 第726题	**原子的数量	困难	**
***
给定一个化学式formula（作为字符串），返回每种原子的数量。<br>原子总是以一个大写字母开始，接着跟随0个或任意个小写字母，表示原子的名字。<br>如果数量大于 1，原子后会跟着数字表示原子的数量。如果数量等于 1 则不会跟数字。例如，H2O 和 H2O2 是可行的，但 H1O2 这个表达是不可行的。<br>两个化学式连在一起是新的化学式。例如 H2O2He3Mg4 也是化学式。<br>一个括号中的化学式和数字（可选择性添加）也是化学式。例如 (H2O2) 和 (H2O2)3 是化学式。<br>给定一个化学式，输出所有原子的数量。格式为：第一个（按字典序）原子的名子，跟着它的数量（如果数量大于 1），然后是第二个原子的名字（按字典序），跟着它的数量（如果数量大于 1），以此类推。<br>示例 1:<br>输入:<br>formula = "H2O"<br>输出: "H2O"<br>解释:<br>原子的数量是 {'H': 2, 'O': 1}。<br>示例 2:<br>输入:<br>formula = "Mg(OH)2"<br>输出: "H2MgO2"<br>解释:<br>原子的数量是 {'H': 2, 'Mg': 1, 'O': 2}。<br>示例 3:<br>输入:<br>formula = "K4(ON(SO3)2)2"<br>输出: "K4N2O14S4"<br>解释:<br>原子的数量是 {'K': 4, 'N': 2, 'O': 14, 'S': 4}。<br>注意:<br>所有原子的第一个字母为大写，剩余字母都是小写。<br>formula的长度在[1, 1000]之间。<br>formula只包含字母、数字和圆括号，并且题目中给定的是合法的化学式。
***

```python
todo
```
#### 第739题	**每日温度	中等	**
***
根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。<br>例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。<br>提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。
***

```python
todo
```
#### 第748题	**最短完整词	简单	**
***
如果单词列表（words）中的一个单词包含牌照（licensePlate）中所有的字母，那么我们称之为完整词。在所有完整词中，最短的单词我们称之为最短完整词。<br>单词在匹配牌照中的字母时不区分大小写，比如牌照中的 "P" 依然可以匹配单词中的 "p" 字母。<br>我们保证一定存在一个最短完整词。当有多个单词都符合最短完整词的匹配条件时取单词列表中最靠前的一个。<br>牌照中可能包含多个相同的字符，比如说：对于牌照 "PP"，单词 "pair" 无法匹配，但是 "supper" 可以匹配。<br>示例 1：<br>输入：licensePlate = "1s3 PSt", words = ["step", "steps", "stripe", "stepple"]<br>输出："steps"<br>说明：最短完整词应该包括 "s"、"p"、"s" 以及 "t"。对于 "step" 它只包含一个 "s" 所以它不符合条件。同时在匹配过程中我们忽略牌照中的大小写。<br>示例 2：<br>输入：licensePlate = "1s3 456", words = ["looks", "pest", "stew", "show"]<br>输出："pest"<br>说明：存在 3 个包含字母 "s" 且有着最短长度的完整词，但我们返回最先出现的完整词。<br>注意:<br>牌照（licensePlate）的长度在区域[1, 7]中。<br>牌照（licensePlate）将会包含数字、空格、或者字母（大写和小写）。<br>单词列表（words）长度在区间 [10, 1000] 中。<br>每一个单词 words[i] 都是小写，并且长度在区间 [1, 15] 中。
***

```python
todo
```
#### 第770题	**基本计算器 IV	困难	**
***
给定一个表达式 expression 如 expression = "e + 8 - a + 5" 和一个求值映射，如 {"e": 1}（给定的形式为 evalvars = ["e"] 和 evalints = [1]），返回表示简化表达式的标记列表，例如 ["-1*a","14"]<br>表达式交替使用块和符号，每个块和符号之间有一个空格。<br>块要么是括号中的表达式，要么是变量，要么是非负整数。<br>块是括号中的表达式，变量或非负整数。<br>变量是一个由小写字母组成的字符串（不包括数字）。请注意，变量可以是多个字母，并注意变量从不具有像 "2x" 或 "-x" 这样的前导系数或一元运算符 。<br>表达式按通常顺序进行求值：先是括号，然后求乘法，再计算加法和减法。例如，expression = "1 + 2 * 3" 的答案是 ["7"]。<br>输出格式如下：<br>对于系数非零的每个自变量项，我们按字典排序的顺序将自变量写在一个项中。例如，我们永远不会写像 “b*a*c” 这样的项，只写 “a*b*c”。<br>项的次数等于被乘的自变量的数目，并计算重复项。(例如，"a*a*b*c" 的次数为 4。)。我们先写出答案的最大次数项，用字典顺序打破关系，此时忽略词的前导系数。<br>项的前导系数直接放在左边，用星号将它与变量分隔开(如果存在的话)。前导系数 1 仍然要打印出来。<br>格式良好的一个示例答案是 ["-2*a*a*a", "3*a*a*b", "3*b*b", "4*a", "5*c", "-6"] 。<br>系数为 0 的项（包括常数项）不包括在内。例如，“0” 的表达式输出为 []。<br>示例：<br>输入：expression = "e + 8 - a + 5", evalvars = ["e"], evalints = [1]<br>输出：["-1*a","14"]<br><br>输入：expression = "e - 8 + temperature - pressure",<br>evalvars = ["e", "temperature"], evalints = [1, 12]<br>输出：["-1*pressure","5"]<br><br>输入：expression = "(e + 8) * (e - 8)", evalvars = [], evalints = []<br>输出：["1*e*e","-64"]<br><br>输入：expression = "7 - 7", evalvars = [], evalints = []<br>输出：[]<br><br>输入：expression = "a * b * c + b * a * c * 4", evalvars = [], evalints = []<br>输出：["5*a*b*c"]<br><br>输入：expression = "((a - b) * (b - c) + (c - a)) * ((a - b) + (b - c) * (c - a))",<br>evalvars = [], evalints = []<br>输出：["-1*a*a*b*b","2*a*a*b*c","-1*a*a*c*c","1*a*b*b*b","-1*a*b*b*c","-1*a*b*c*c","1*a*c*c*c","-1*b*b*b*c","2*b*b*c*c","-1*b*c*c*c","2*a*a*b","-2*a*a*c","-2*a*b*b","2*a*c*c","1*b*b*b","-1*b*b*c","1*b*c*c","-1*c*c*c","-1*a*a","1*a*b","1*a*c","-1*b*c"]<br>提示：<br>expression 的长度在 [1, 250] 范围内。<br>evalvars, evalints 在范围 [0, 100] 内，且长度相同。
***

```python
todo
```
#### 第771题	**宝石与石头	简单	**
***
给定字符串J 代表石头中宝石的类型，和字符串 S代表你拥有的石头。 S 中每个字符代表了一种你拥有的石头的类型，你想知道你拥有的石头中有多少是宝石。<br>J 中的字母不重复，J 和 S中的所有字符都是字母。字母区分大小写，因此"a"和"A"是不同类型的石头。<br>示例 1:<br>输入: J = "aA", S = "aAAbbbb"<br>输出: 3<br>示例 2:<br>输入: J = "z", S = "ZZ"<br>输出: 0<br>注意:<br>S 和 J 最多含有50个字母。<br>J 中的字符不重复。
***

```python
todo
```
#### 第781题	**森林中的兔子	中等	**
***
森林中，每个兔子都有颜色。其中一些兔子（可能是全部）告诉你还有多少其他的兔子和自己有相同的颜色。我们将这些回答放在 answers 数组里。<br>返回森林中兔子的最少数量。<br>示例:<br>输入: answers = [1, 1, 2]<br>输出: 5<br>解释:<br>两只回答了 "1" 的兔子可能有相同的颜色，设为红色。<br>之后回答了 "2" 的兔子不会是红色，否则他们的回答会相互矛盾。<br>设回答了 "2" 的兔子为蓝色。<br>此外，森林中还应有另外 2 只蓝色兔子的回答没有包含在数组中。<br>因此森林中兔子的最少数量是 5: 3 只回答的和 2 只没有回答的。<br><br>输入: answers = [10, 10, 10]<br>输出: 11<br><br>输入: answers = []<br>输出: 0<br>说明:<br>answers 的长度最大为1000。<br>answers[i] 是在 [0, 999] 范围内的整数。
***

```python
todo
```
#### 第811题	**子域名访问计数	简单	**
***
一个网站域名，如"discuss.leetcode.com"，包含了多个子域名。作为顶级域名，常用的有"com"，下一级则有"leetcode.com"，最低的一级为"discuss.leetcode.com"。当我们访问域名"discuss.leetcode.com"时，也同时访问了其父域名"leetcode.com"以及顶级域名 "com"。<br>给定一个带访问次数和域名的组合，要求分别计算每个域名被访问的次数。其格式为访问次数+空格+地址，例如："9001 discuss.leetcode.com"。<br>接下来会给出一组访问次数和域名组合的列表cpdomains 。要求解析出所有域名的访问次数，输出格式和输入格式相同，不限定先后顺序。<br>示例 1:<br>输入:<br>["9001 discuss.leetcode.com"]<br>输出:<br>["9001 discuss.leetcode.com", "9001 leetcode.com", "9001 com"]<br>说明:<br>例子中仅包含一个网站域名："discuss.leetcode.com"。按照前文假设，子域名"leetcode.com"和"com"都会被访问，所以它们都被访问了9001次。<br>示例 2<br>输入:<br>["900 google.mail.com", "50 yahoo.com", "1 intel.mail.com", "5 wiki.org"]<br>输出:<br>["901 mail.com","50 yahoo.com","900 google.mail.com","5 wiki.org","5 org","1 intel.mail.com","951 com"]<br>说明:<br>按照假设，会访问"google.mail.com" 900次，"yahoo.com" 50次，"intel.mail.com" 1次，"wiki.org" 5次。<br>而对于父域名，会访问"mail.com" 900+1 = 901次，"com" 900 + 50 + 1 = 951次，和 "org" 5 次。<br>注意事项：<br>cpdomains 的长度小于 100。<br>每个域名的长度小于100。<br>每个域名地址包含一个或两个"."符号。<br>输入中任意一个域名的访问次数都小于10000。
***

```python
todo
```
#### 第884题	**两句话中的不常见单词	简单	**
***
给定两个句子 A 和 B 。 （句子是一串由空格分隔的单词。每个单词仅由小写字母组成。）<br>如果一个单词在其中一个句子中只出现一次，在另一个句子中却没有出现，那么这个单词就是不常见的。<br>返回所有不常用单词的列表。<br>您可以按任何顺序返回列表。<br>示例 1：<br>输入：A = "this apple is sweet", B = "this apple is sour"<br>输出：["sweet","sour"]<br>示例 2：<br>输入：A = "apple apple", B = "banana"<br>输出：["banana"]<br>提示：<br>0 <= A.length <= 200<br>0 <= B.length <= 200<br>A 和 B 都只包含空格和小写字母。
***

```python
todo
```
#### 第895题	**最大频率栈	困难	**
***
实现 FreqStack，模拟类似栈的数据结构的操作的一个类。<br>FreqStack 有两个函数：<br>push(int x)，将整数 x 推入栈中。<br>pop()，它移除并返回栈中出现最频繁的元素。<br>如果最频繁的元素不只一个，则移除并返回最接近栈顶的元素。<br>示例：<br>输入：<br>["FreqStack","push","push","push","push","push","push","pop","pop","pop","pop"],<br>[[],[5],[7],[5],[7],[4],[5],[],[],[],[]]<br>输出：[null,null,null,null,null,null,null,5,7,5,4]<br>解释：<br>执行六次 .push 操作后，栈自底向上为 [5,7,5,7,4,5]。然后：<br><br>pop() -> 返回 5，因为 5 是出现频率最高的。<br>栈变成 [5,7,5,7,4]。<br><br>pop() -> 返回 7，因为 5 和 7 都是频率最高的，但 7 最接近栈顶。<br>栈变成 [5,7,5,4]。<br><br>pop() -> 返回 5 。<br>栈变成 [5,7,4]。<br><br>pop() -> 返回 4 。<br>栈变成 [5,7]。<br>提示：<br>对 FreqStack.push(int x) 的调用中 0 <= x <= 10^9。<br>如果栈的元素数目为零，则保证不会调用  FreqStack.pop()。<br>单个测试样例中，对 FreqStack.push 的总调用次数不会超过 10000。<br>单个测试样例中，对 FreqStack.pop 的总调用次数不会超过 10000。<br>所有测试样例中，对 FreqStack.push 和 FreqStack.pop 的总调用次数不会超过 150000。
***

```python
todo
```
#### 第930题	**和相同的二元子数组	中等	**
***
在由若干 0 和 1  组成的数组 A 中，有多少个和为 S 的非空子数组。<br>示例：<br>输入：A = [1,0,1,0,1], S = 2<br>输出：4<br>解释：<br>如下面黑体所示，有 4 个满足题目要求的子数组：<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>[1,0,1,0,1]<br>提示：<br>A.length <= 30000<br>0 <= S <= A.length<br>A[i] 为 0 或 1
***

```python
todo
```
#### 第939题	**最小面积矩形	中等	**
***
给定在 xy 平面上的一组点，确定由这些点组成的矩形的最小面积，其中矩形的边平行于 x 轴和 y 轴。<br>如果没有任何矩形，就返回 0。<br>示例 1：<br>输入：[[1,1],[1,3],[3,1],[3,3],[2,2]]<br>输出：4<br>示例 2：<br>输入：[[1,1],[1,3],[3,1],[3,3],[4,1],[4,3]]<br>输出：2<br>提示：<br>1 <= points.length <= 500<br>0 <= points[i][0] <= 40000<br>0 <= points[i][1] <= 40000<br>所有的点都是不同的。
***

```python
todo
```
#### 第953题	**验证外星语词典	简单	**
***
某种外星语也使用英文小写字母，但可能顺序 order 不同。字母表的顺序（order）是一些小写字母的排列。<br>给定一组用外星语书写的单词 words，以及其字母表的顺序 order，只有当给定的单词在这种外星语中按字典序排列时，返回 true；否则，返回 false。<br>示例 1：<br>输入：words = ["hello","leetcode"], order = "hlabcdefgijkmnopqrstuvwxyz"<br>输出：true<br>解释：在该语言的字母表中，'h' 位于 'l' 之前，所以单词序列是按字典序排列的。<br>示例 2：<br>输入：words = ["word","world","row"], order = "worldabcefghijkmnpqstuvxyz"<br>输出：false<br>解释：在该语言的字母表中，'d' 位于 'l' 之后，那么 words[0] > words[1]，因此单词序列不是按字典序排列的。<br>示例 3：<br>输入：words = ["apple","app"], order = "abcdefghijklmnopqrstuvwxyz"<br>输出：false<br>解释：当前三个字符 "app" 匹配时，第二个字符串相对短一些，然后根据词典编纂规则 "apple" > "app"，因为 'l' > '∅'，其中 '∅' 是空白字符，定义为比任何其他字符都小（更多信息）。<br>提示：<br>1 <= words.length <= 100<br>1 <= words[i].length <= 20<br>order.length == 26<br>在 words[i] 和 order 中的所有字符都是英文小写字母。
***

```python
todo
```
