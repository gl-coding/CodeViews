# 第2节

#### 第587题	**安装栅栏	困难	**
***
在一个二维的花园中，有一些用 (x, y) 坐标表示的树。由于安装费用十分昂贵，你的任务是先用最短的绳子围起所有的树。只有当所有的树都被绳子包围时，花园才能围好栅栏。你需要找到正好位于栅栏边界上的树的坐标。<br>示例 1:<br>输入: [[1,1],[2,2],[2,0],[2,4],[3,3],[4,2]]<br>输出: [[1,1],[2,0],[4,2],[3,3],[2,4]]<br>解释:<br>示例 2:<br>输入: [[1,2],[2,2],[4,2]]<br>输出: [[1,2],[2,2],[4,2]]<br>解释:<br><br>即使树都在一条直线上，你也需要先用绳子包围它们。<br>注意:<br>所有的树应当被围在一起。你不能剪断绳子来包围树或者把树分成一组以上。<br>输入的整数在 0 到 100 之间。<br>花园至少有一棵树。<br>所有树的坐标都是不同的。<br>输入的点没有顺序。输出顺序也没有要求。
***

```python
# Definition for a point.
# class Point(object):
#     def __init__(self, a=0, b=0):
#         self.x = a
#         self.y = b

class Solution(object):
    def outerTrees(self, points):
        """
        :type points: List[Point]
        :rtype: List[Point]
        """
        if len(points) == 1:
            return points
        def direction(p, q, r):
            return ((p.x - r.x) * (q.y - r.y) - (p.y - r.y) * (q.x - r.x))

        points.sort(key=lambda x:(x.x, x.y))
        upper = []
        lower = []
        for point in points:
            while len(lower) >= 2 and direction(lower[-2], lower[-1], point) < 0:
                lower.pop()
            lower.append(point)

        for point in reversed(points):
            while len(upper) >= 2 and direction(upper[-2], upper[-1], point) < 0:
                upper.pop()
            upper.append(point)

        return list(set(upper[1:] + lower[1:]))
```
#### 第892题	**三维形体的表面积	简单	**
***
在 N * N 的网格上，我们放置一些 1 * 1 * 1  的立方体。<br>每个值 v = grid[i][j] 表示 v 个正方体叠放在对应单元格 (i, j) 上。<br>请你返回最终形体的表面积。<br>示例 1：<br>输入：[[2]]<br>输出：10<br>示例 2：<br>输入：[[1,2],[3,4]]<br>输出：34<br>示例 3：<br>输入：[[1,0],[0,2]]<br>输出：16<br>示例 4：<br>输入：[[1,1,1],[1,0,1],[1,1,1]]<br>输出：32<br>示例 5：<br>输入：[[2,2,2],[2,1,2],[2,2,2]]<br>输出：46<br>提示：<br>1 <= N <= 50<br>0 <= grid[i][j] <= 50
***

```python
todo
```
#### 第963题	**最小面积矩形 II	中等	**
***
给定在 xy 平面上的一组点，确定由这些点组成的任何矩形的最小面积，其中矩形的边不一定平行于 x 轴和 y 轴。<br>如果没有任何矩形，就返回 0。<br>示例 1：<br>输入：[[1,2],[2,1],[1,0],[0,1]]<br>输出：2.00000<br>解释：最小面积的矩形出现在 [1,2],[2,1],[1,0],[0,1] 处，面积为 2。<br>示例 2：<br>输入：[[0,1],[2,1],[1,1],[1,0],[2,0]]<br>输出：1.00000<br>解释：最小面积的矩形出现在 [1,0],[1,1],[2,1],[2,0] 处，面积为 1。<br>示例 3：<br>输入：[[0,3],[1,2],[3,1],[1,3],[2,1]]<br>输出：0<br>解释：没法从这些点中组成任何矩形。<br>示例 4：<br>输入：[[3,1],[1,1],[0,1],[2,1],[3,3],[3,2],[0,2],[2,3]]<br>输出：2.00000<br>解释：最小面积的矩形出现在 [2,1],[2,3],[3,3],[3,1] 处，面积为 2。<br>提示：<br>1 <= points.length <= 50<br>0 <= points[i][0] <= 40000<br>0 <= points[i][1] <= 40000<br>所有的点都是不同的。<br>与真实值误差不超过 10^-5 的答案将视为正确结果。
***

```python
todo
```
#### 第1232题	**缀点成线	简单	**
***
在一个 XY 坐标系中有一些点，我们用数组 coordinates 来分别记录它们的坐标，其中 coordinates[i] = [x, y] 表示横坐标为 x、纵坐标为 y 的点。<br>请你来判断，这些点是否在该坐标系中属于同一条直线上，是则返回 true，否则请返回 false。<br>示例 1：<br>输入：coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]<br>输出：true<br>示例 2：<br>输入：coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]<br>输出：false<br>提示：<br>2 <= coordinates.length <= 1000<br>coordinates[i].length == 2<br>-10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4<br>coordinates 中不含重复的点
***

```python
todo
```
#### 第1266题	**访问所有点的最小时间	简单	**
***
平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。<br>你可以按照下面的规则在平面上移动：<br>每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。<br>必须按照数组中出现的顺序来访问这些点。<br>示例 1：<br>输入：points = [[1,1],[3,4],[-1,0]]<br>输出：7<br>解释：一条最佳的访问路径是： [1,1] -> [2,2] -> [3,3] -> [3,4] -> [2,3] -> [1,2] -> [0,1] -> [-1,0]<br>从 [1,1] 到 [3,4] 需要 3 秒<br>从 [3,4] 到 [-1,0] 需要 4 秒<br>一共需要 7 秒<br>示例 2：<br>输入：points = [[3,2],[-2,2]]<br>输出：5<br>提示：<br>points.length == n<br>1 <= n <= 100<br>points[i].length == 2<br>-1000 <= points[i][0], points[i][1] <= 1000
***

```python
todo
```
