# 第6节

#### 第744题	**寻找比目标字母大的最小字母	简单	**
***
给定一个只包含小写字母的有序数组letters 和一个目标字母 target，寻找有序数组里面比目标字母大的最小字母。<br>数组里字母的顺序是循环的。举个例子，如果目标字母target = 'z' 并且有序数组为 letters = ['a', 'b']，则答案返回 'a'。<br>示例:<br>输入:<br>letters = ["c", "f", "j"]<br>target = "a"<br>输出: "c"<br><br>输入:<br>letters = ["c", "f", "j"]<br>target = "c"<br>输出: "f"<br><br>输入:<br>letters = ["c", "f", "j"]<br>target = "d"<br>输出: "f"<br><br>输入:<br>letters = ["c", "f", "j"]<br>target = "g"<br>输出: "j"<br><br>输入:<br>letters = ["c", "f", "j"]<br>target = "j"<br>输出: "c"<br><br>输入:<br>letters = ["c", "f", "j"]<br>target = "k"<br>输出: "c"<br>注:<br>letters长度范围在[2, 10000]区间内。<br>letters 仅由小写字母组成，最少包含两个不同的字母。<br>目标字母target 是一个小写字母。
***

```python
todo
```
#### 第778题	**水位上升的泳池中游泳	困难	**
***
在一个 N x N 的坐标方格 grid 中，每一个方格的值 grid[i][j] 表示在位置 (i,j) 的平台高度。<br>现在开始下雨了。当时间为 t 时，此时雨水导致水池中任意位置的水位为 t 。你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台。假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的。当然，在你游泳的时候你必须待在坐标方格里面。<br>你从坐标方格的左上平台 (0，0) 出发。最少耗时多久你才能到达坐标方格的右下平台 (N-1, N-1)？<br>示例 1:<br>输入: [[0,2],[1,3]]<br>输出: 3<br>解释:<br>时间为0时，你位于坐标方格的位置为 (0, 0)。<br>此时你不能游向任意方向，因为四个相邻方向平台的高度都大于当前时间为 0 时的水位。<br><br>等时间到达 3 时，你才可以游向平台 (1, 1). 因为此时的水位是 3，坐标方格中的平台没有比水位 3 更高的，所以你可以游向坐标方格中的任意位置<br>示例2:<br>输入: [[0,1,2,3,4],[24,23,22,21,5],[12,13,14,15,16],[11,17,18,19,20],[10,9,8,7,6]]<br>输入: 16<br>解释:<br>0  1  2  3  4<br>24 23 22 21  5<br>12 13 14 15 16<br>11 17 18 19 20<br>10  9  8  7  6<br><br>最终的路线用加粗进行了标记。<br>我们必须等到时间为 16，此时才能保证平台 (0, 0) 和 (4, 4) 是连通的<br>提示:<br>2 <= N <= 50.<br>grid[i][j] 位于区间 [0, ..., N*N - 1] 内。
***

```python
todo
```
#### 第786题	**第 K 个最小的素数分数	困难	**
***
一个已排序好的表 A，其包含 1 和其他一些素数.  当列表中的每一个 p<q 时，我们可以构造一个分数 p/q 。<br>那么第 k 个最小的分数是多少呢?  以整数数组的形式返回你的答案, 这里 answer[0] = p 且 answer[1] = q.<br>示例:<br>输入: A = [1, 2, 3, 5], K = 3<br>输出: [2, 5]<br>解释:<br>已构造好的分数,排序后如下所示:<br>1/5, 1/3, 2/5, 1/2, 3/5, 2/3.<br>很明显第三个最小的分数是 2/5.<br><br>输入: A = [1, 7], K = 1<br>输出: [1, 7]<br>注意:<br>A 的取值范围在 2 — 2000.<br>每个 A[i] 的值在 1 —30000.<br>K 取值范围为 1 —A.length * (A.length - 1) / 2
***

```python
todo
```
#### 第793题	**阶乘函数后K个零	困难	**
***
f(x) 是 x! 末尾是0的数量。（回想一下 x! = 1 * 2 * 3 * ... * x，且0! = 1）<br>例如， f(3) = 0 ，因为3! = 6的末尾没有0；而 f(11) = 2 ，因为11!= 39916800末端有2个0。给定 K，找出多少个非负整数x ，有 f(x) = K 的性质。<br>示例 1:<br>输入:K = 0<br>输出:5<br>解释: 0!, 1!, 2!, 3!, and 4! 均符合 K = 0 的条件。<br><br>示例 2:<br>输入:K = 5<br>输出:0<br>解释:没有匹配到这样的 x!，符合K = 5 的条件。<br>注意：<br>K是范围在 [0, 10^9] 的整数。
***

```python
todo
```
#### 第852题	**山脉数组的峰顶索引	简单	**
***
我们把符合下列属性的数组 A 称作山脉：<br>A.length >= 3<br>存在 0 < i < A.length - 1 使得A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1]<br>给定一个确定为山脉的数组，返回任何满足 A[0] < A[1] < ... A[i-1] < A[i] > A[i+1] > ... > A[A.length - 1] 的 i 的值。<br>示例 1：<br>输入：[0,1,0]<br>输出：1<br>示例 2：<br>输入：[0,2,1,0]<br>输出：1<br>提示：<br>3 <= A.length <= 10000<br>0 <= A[i] <= 10^6<br>A 是如上定义的山脉
***

```python
todo
```
#### 第862题	**和至少为 K 的最短子数组	困难	**
***
返回 A 的最短的非空连续子数组的长度，该子数组的和至少为 K 。<br>如果没有和至少为 K 的非空子数组，返回 -1 。<br>示例 1：<br>输入：A = [1], K = 1<br>输出：1<br>示例 2：<br>输入：A = [1,2], K = 4<br>输出：-1<br>示例 3：<br>输入：A = [2,-1,2], K = 3<br>输出：3<br>提示：<br>1 <= A.length <= 50000<br>-10 ^ 5 <= A[i] <= 10 ^ 5<br>1 <= K <= 10 ^ 9
***

```python
todo
```
#### 第875题	**爱吃香蕉的珂珂	中等	**
***
珂珂喜欢吃香蕉。这里有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。<br>珂珂可以决定她吃香蕉的速度 K （单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。<br>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<br>返回她可以在 H 小时内吃掉所有香蕉的最小速度 K（K 为整数）。<br>示例 1：<br>输入: piles = [3,6,7,11], H = 8<br>输出: 4<br>示例 2：<br>输入: piles = [30,11,23,4,20], H = 5<br>输出: 30<br>示例 3：<br>输入: piles = [30,11,23,4,20], H = 6<br>输出: 23<br>提示：<br>1 <= piles.length <= 10^4<br>piles.length <= H <= 10^9<br>1 <= piles[i] <= 10^9
***

```python
todo
```
#### 第878题	**第 N 个神奇数字	困难	**
***
如果正整数可以被 A 或 B 整除，那么它是神奇的。<br>返回第 N 个神奇数字。由于答案可能非常大，返回它模 10^9 + 7 的结果。<br>示例 1：<br>输入：N = 1, A = 2, B = 3<br>输出：2<br>示例 2：<br>输入：N = 4, A = 2, B = 3<br>输出：6<br>示例 3：<br>输入：N = 5, A = 2, B = 4<br>输出：10<br>示例 4：<br>输入：N = 3, A = 6, B = 4<br>输出：8<br>提示：<br>1 <= N <= 10^9<br>2 <= A <= 40000<br>2 <= B <= 40000
***

```python
todo
```
#### 第887题	**鸡蛋掉落	困难	**
***
你将获得 K 个鸡蛋，并可以使用一栋从 1 到 N  共有 N 层楼的建筑。<br>每个蛋的功能都是一样的，如果一个蛋碎了，你就不能再把它掉下去。<br>你知道存在楼层 F ，满足 0 <= F <= N 任何从高于 F 的楼层落下的鸡蛋都会碎，从 F 楼层或比它低的楼层落下的鸡蛋都不会破。<br>每次移动，你可以取一个鸡蛋（如果你有完整的鸡蛋）并把它从任一楼层 X 扔下（满足 1 <= X <= N）。<br>你的目标是确切地知道 F 的值是多少。<br>无论 F 的初始值如何，你确定 F 的值的最小移动次数是多少？<br>示例 1：<br>输入：K = 1, N = 2<br>输出：2<br>解释：<br>鸡蛋从 1 楼掉落。如果它碎了，我们肯定知道 F = 0 。<br>否则，鸡蛋从 2 楼掉落。如果它碎了，我们肯定知道 F = 1 。<br>如果它没碎，那么我们肯定知道 F = 2 。<br>因此，在最坏的情况下我们需要移动 2 次以确定 F 是多少。<br>示例 2：<br>输入：K = 2, N = 6<br>输出：3<br>示例 3：<br>输入：K = 3, N = 14<br>输出：4<br>提示：<br>1 <= K <= 100<br>1 <= N <= 10000
***

```python
todo
```
#### 第911题	**在线选举	中等	**
***
在选举中，第 i 张票是在时间为 times[i] 时投给 persons[i] 的。<br>现在，我们想要实现下面的查询函数： TopVotedCandidate.q(int t) 将返回在 t 时刻主导选举的候选人的编号。<br>在 t 时刻投出的选票也将被计入我们的查询之中。在平局的情况下，最近获得投票的候选人将会获胜。<br>示例：<br>输入：["TopVotedCandidate","q","q","q","q","q","q"], [[[0,1,1,0,0,1,0],[0,5,10,15,20,25,30]],[3],[12],[25],[15],[24],[8]]<br>输出：[null,0,1,1,0,0,1]<br>解释：<br>时间为 3，票数分布情况是 [0]，编号为 0 的候选人领先。<br>时间为 12，票数分布情况是 [0,1,1]，编号为 1 的候选人领先。<br>时间为 25，票数分布情况是 [0,1,1,0,0,1]，编号为 1 的候选人领先（因为最近的投票结果是平局）。<br>在时间 15、24 和 8 处继续执行 3 个查询。<br>提示：<br>1 <= persons.length = times.length <= 5000<br>0 <= persons[i] <= persons.length<br>times 是严格递增的数组，所有元素都在 [0, 10^9] 范围中。<br>每个测试用例最多调用 10000 次 TopVotedCandidate.q。<br>TopVotedCandidate.q(int t) 被调用时总是满足 t >= times[0]。
***

```python
todo
```
#### 第927题	**三等分	困难	**
***
给定一个由 0 和 1 组成的数组 A，将数组分成 3 个非空的部分，使得所有这些部分表示相同的二进制值。<br>如果可以做到，请返回任何 [i, j]，其中 i+1 < j，这样一来：<br>A[0], A[1], ..., A[i] 组成第一部分；<br>A[i+1], A[i+2], ..., A[j-1] 作为第二部分；<br>A[j], A[j+1], ..., A[A.length - 1] 是第三部分。<br>这三个部分所表示的二进制值相等。<br>如果无法做到，就返回 [-1, -1]。<br>注意，在考虑每个部分所表示的二进制时，应当将其看作一个整体。例如，[1,1,0] 表示十进制中的 6，而不会是 3。此外，前导零也是被允许的，所以 [0,1,1] 和 [1,1] 表示相同的值。<br>示例 1：<br>输入：[1,0,1,0,1]<br>输出：[0,3]<br>示例 2：<br>输出：[1,1,0,1,1]<br>输出：[-1,-1]<br>提示：<br>3 <= A.length <= 30000<br>A[i] == 0 或 A[i] == 1
***

```python
todo
```
#### 第981题	**基于时间的键值存储	中等	**
***
创建一个基于时间的键值存储类 TimeMap，它支持下面两个操作：<br>1. set(string key, string value, int timestamp)<br>存储键 key、值 value，以及给定的时间戳 timestamp。<br>2. get(string key, int timestamp)<br>返回先前调用 set(key, value, timestamp_prev) 所存储的值，其中 timestamp_prev <= timestamp。<br>如果有多个这样的值，则返回对应最大的  timestamp_prev 的那个值。<br>如果没有值，则返回空字符串（""）。<br>示例 1：<br>输入：inputs = ["TimeMap","set","get","get","set","get","get"], inputs = [[],["foo","bar",1],["foo",1],["foo",3],["foo","bar2",4],["foo",4],["foo",5]]<br>输出：[null,null,"bar","bar",null,"bar2","bar2"]<br>解释：<br>TimeMap kv;<br>kv.set("foo", "bar", 1); // 存储键 "foo" 和值 "bar" 以及时间戳 timestamp = 1<br>kv.get("foo", 1);  // 输出 "bar"<br>kv.get("foo", 3); // 输出 "bar" 因为在时间戳 3 和时间戳 2 处没有对应 "foo" 的值，所以唯一的值位于时间戳 1 处（即 "bar"）<br>kv.set("foo", "bar2", 4);<br>kv.get("foo", 4); // 输出 "bar2"<br>kv.get("foo", 5); // 输出 "bar2"<br>示例 2：<br>输入：inputs = ["TimeMap","set","set","get","get","get","get","get"], inputs = [[],["love","high",10],["love","low",20],["love",5],["love",10],["love",15],["love",20],["love",25]]<br>输出：[null,null,null,"","high","high","low","low"]<br>提示：<br>所有的键/值字符串都是小写的。<br>所有的键/值字符串长度都在 [1, 100] 范围内。<br>所有 TimeMap.set 操作中的时间戳 timestamps 都是严格递增的。<br>1 <= timestamp <= 10^7<br>TimeMap.set 和 TimeMap.get 函数在每个测试用例中将（组合）调用总计 120000 次。
***

```python
todo
```
