
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="Given a binary tree, return the values of its boundary in&amp;#160;anti-clockwise&amp;#160;direction startin" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>[LeetCode] 545. Boundary of Binary Tree 二叉树的边界 - Grandyang - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=PyyhYDRKBG1sYtpoHme_xHO5AMd5iN57I45iBKF8FVY" />
    <link id="MainCss" rel="stylesheet" href="/skins/unlimitedsunlight/bundle-unlimitedsunlight.min.css?v=0PW-IbyD73rSsrHXyZPdWAdlgI9zvcQ6P3MLE4OIhi4" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/unlimitedsunlight/bundle-unlimitedsunlight-mobile.min.css?v=1PFKcj_AbkIURdVbGrJ7RA7MSm_08tLLOsnXtqTHyME" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/grandyang/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/grandyang/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/grandyang/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=F-Iy-_Lj7VcUKRIvNkS6UZ5LItMqjh1_L0VZk9Yxfb8"></script>
    <script>
        var currentBlogId = 198221;
        var currentBlogApp = 'grandyang';
        var cb_enable_mathjax = true;
        var isLogined = false;
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <a href="https://github.com/grandyang"> 
<img style="position: absolute; top: 0; left: 0; border: 0; z-index:9999;" 
src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png" 
alt="Fork me on GitHub"> 
</a>

<script src="https://files.cnblogs.com/files/grandyang/tctip-1.0.4.js" defer></script>
<script>
new tctip({
top: '20%',
button: {
  id:7,
  type: 'zanzhu',
},
list: [
  {
        type: 'wechat',
	qrImg: 'https://files.cnblogs.com/files/grandyang/wepay.gif'
  }, {
	type: 'announcement',
        qrText: '2020，新的征途...'
  }
]
}).init()
</script>
    </div>
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/grandyang/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/grandyang/">Grandyang</a>
</h1>
<h2>
仰天长啸仗剑红尘，冬去春来寒暑几更...
</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/grandyang/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/Grandyang">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/grandyang/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
1424&nbsp; </span>
<span id="stats_article_count">文章 - 
1&nbsp; </span>
<span id="stats-comment_count">评论 - 
4014</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/grandyang/p/6833459.html">[LeetCode] 545. Boundary of Binary Tree 二叉树的边界</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    <p>&nbsp;</p>
<div class="col-md-12">
<div class="question-content">
<p>Given a binary tree, return the values of its boundary in&nbsp;anti-clockwise&nbsp;direction starting from root. Boundary includes left boundary, leaves, and right boundary in order without duplicate nodes.</p>
<p>Left boundary&nbsp;is defined as the path from root to the&nbsp;left-most&nbsp;node.&nbsp;Right boundary&nbsp;is defined as the path from root to the&nbsp;right-most&nbsp;node. If the root doesn't have left subtree or right subtree, then the root itself is left boundary or right boundary. Note this definition only applies to the input binary tree, and not applies to any subtrees.</p>
<p>The&nbsp;left-most&nbsp;node is defined as a&nbsp;leaf&nbsp;node you could reach when you always firstly travel to the left subtree if exists. If not, travel to the right subtree. Repeat until you reach a leaf node.</p>
<p>The&nbsp;right-most&nbsp;node is also defined by the same way with left and right exchanged.</p>
<p>Example 1</p>
<pre>Input:
  1
   \
    2
   / \
  3   4

Ouput:
[1, 3, 4, 2]

Explanation:
The root doesn't have left subtree, so the root itself is left boundary.
The leaves are node 3 and 4.
The right boundary are node 1,2,4. Note the anti-clockwise direction means you should output reversed right boundary.
So order them in anti-clockwise without duplicates and we have [1,3,4,2].
</pre>
<p>&nbsp;</p>
<p>Example 2</p>
<pre>Input:
    ____1_____
   /          \
  2            3
 / \          / 
4   5        6   
   / \      / \
  7   8    9  10  
       
Ouput:
[1,2,4,7,8,9,10,6,3]

Explanation:
The left boundary are node 1,2,4. (4 is the left-most node according to definition)
The leaves are node 4,7,8,9,10.
The right boundary are node 1,3,6,10. (10 is the right-most node).
So order them in anti-clockwise without duplicate nodes we have [1,2,4,7,8,9,10,6,3].
</pre>
<p>&nbsp;</p>
<p>这道题给了一棵二叉树，让我们以逆时针的顺序来输出树的边界，按顺序分别为左边界，叶结点和右边界。题目中给的例子也很清晰的明白哪些算是边界上的结点。那么最直接的方法就是分别按顺序求出左边界结点，叶结点，和右边界结点。那么如何求的，对于树的操作肯定是用递归最简洁啊，所以可以写分别三个递归函数来分别求左边界结点，叶结点，和右边界结点。首先要处理根结点的情况，当根结点没有左右子结点时，其也是一个叶结点，那么一开始就将其加入结果 res 中，那么再计算叶结点的时候又会再加入一次，这样不对。所以判断如果根结点至少有一个子结点，才提前将其加入结果 res 中。然后再来看求左边界结点的函数，如果当前结点不存在，或者没有子结点，直接返回。否则就把当前结点值加入结果 res 中，然后看如果左子结点存在，就对其调用递归函数，反之如果左子结点不存在，那么对右子结点调用递归函数。而对于求右边界结点的函数就反过来了，如果右子结点存在，就对其调用递归函数，反之如果右子结点不存在，就对左子结点调用递归函数，注意在调用递归函数之后才将结点值加入结果 res，因为是需要按逆时针的顺序输出。最后就来看求叶结点的函数，没什么可说的，就是看没有子结点存在了就加入结果 res，然后对左右子结点分别调用递归即可，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; boundaryOfBinaryTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left || root-&gt;right) res.push_back(root-&gt;<span style="color: #000000;">val);
        leftBoundary(root</span>-&gt;<span style="color: #000000;">left, res);
        leaves(root, res);
        rightBoundary(root</span>-&gt;<span style="color: #000000;">right, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> leftBoundary(TreeNode* node, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node || (!node-&gt;left &amp;&amp; !node-&gt;right)) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        res.push_back(node</span>-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left) leftBoundary(node-&gt;<span style="color: #000000;">right, res);
        </span><span style="color: #0000ff;">else</span> leftBoundary(node-&gt;<span style="color: #000000;">left, res);
    }
    </span><span style="color: #0000ff;">void</span> rightBoundary(TreeNode* node, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node || (!node-&gt;left &amp;&amp; !node-&gt;right)) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (!node-&gt;right) rightBoundary(node-&gt;<span style="color: #000000;">left, res);
        </span><span style="color: #0000ff;">else</span> rightBoundary(node-&gt;<span style="color: #000000;">right, res);
        res.push_back(node</span>-&gt;<span style="color: #000000;">val);
    }
    </span><span style="color: #0000ff;">void</span> leaves(TreeNode* node, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left &amp;&amp; !node-&gt;<span style="color: #000000;">right) {
            res.push_back(node</span>-&gt;<span style="color: #000000;">val);
        }
        leaves(node</span>-&gt;<span style="color: #000000;">left, res);
        leaves(node</span>-&gt;<span style="color: #000000;">right, res);
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>下面这种方法把上面三种不同的递归揉合到了一个递归中，并用 bool 型变量来标记当前是求左边界结点还是求右边界结点，同时还有加入叶结点到结果 res 中的功能。如果左边界标记为 true，那么将结点值加入结果 res 中，下面就是调用对左右结点调用递归函数了。根据上面的解题思路可以知道，如果是求左边界结点，优先调用左子结点，当左子结点不存在时再调右子结点，而对于求右边界结点，优先调用右子结点，当右子结点不存在时再调用左子结点。综上考虑，在对左子结点调用递归函数时，左边界标识设为 leftbd &amp;&amp; node-&gt;left，而对右子结点调用递归的左边界标识设为 leftbd &amp;&amp; !node-&gt;left，这样左子结点存在就会被优先调用。而右边界结点的情况就正好相反，调用左子结点的右边界标识为 rightbd &amp;&amp; !node-&gt;right, 调用右子结点的右边界标识为 rightbd &amp;&amp; node-&gt;right，这样就保证了右子结点存在就会被优先调用，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; boundaryOfBinaryTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; res{root-&gt;<span style="color: #000000;">val};
        helper(root</span>-&gt;left, <span style="color: #0000ff;">true</span>, <span style="color: #0000ff;">false</span><span style="color: #000000;">, res);
        helper(root</span>-&gt;right, <span style="color: #0000ff;">false</span>, <span style="color: #0000ff;">true</span><span style="color: #000000;">, res);
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
    </span><span style="color: #0000ff;">void</span> helper(TreeNode* node, <span style="color: #0000ff;">bool</span> leftbd, <span style="color: #0000ff;">bool</span> rightbd, vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> res) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">if</span> (!node-&gt;left &amp;&amp; !node-&gt;<span style="color: #000000;">right) {
            res.push_back(node</span>-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">return</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">if</span> (leftbd) res.push_back(node-&gt;<span style="color: #000000;">val);
        helper(node</span>-&gt;left, leftbd &amp;&amp; node-&gt;left, rightbd &amp;&amp; !node-&gt;<span style="color: #000000;">right, res);
        helper(node</span>-&gt;right, leftbd &amp;&amp; !node-&gt;left, rightbd &amp;&amp; node-&gt;<span style="color: #000000;">right, res);
        </span><span style="color: #0000ff;">if</span> (rightbd) res.push_back(node-&gt;<span style="color: #000000;">val);
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>下面这种解法实际上时解法一的迭代形式，整体思路基本一样，只是没有再用递归的写法，而是均采用 while 的迭代写法，注意在求右边界结点时迭代写法很难直接写出逆时针的顺序，我们可以先反过来保存，最后再调个顺序即可，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; boundaryOfBinaryTree(TreeNode*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> {};
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> res, right;
        TreeNode </span>*l = root-&gt;left, *r = root-&gt;right, *p =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">if</span> (root-&gt;left || root-&gt;right) res.push_back(root-&gt;<span style="color: #000000;">val);
        </span><span style="color: #0000ff;">while</span> (l &amp;&amp; (l-&gt;left || l-&gt;<span style="color: #000000;">right)) {
            res.push_back(l</span>-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">if</span> (l-&gt;left) l = l-&gt;<span style="color: #000000;">left;
            </span><span style="color: #0000ff;">else</span> l = l-&gt;<span style="color: #000000;">right;
        }
        stack</span>&lt;TreeNode*&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">while</span> (p || !<span style="color: #000000;">st.empty()) {
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (p) {
                st.push(p);
                </span><span style="color: #0000ff;">if</span> (!p-&gt;left &amp;&amp; !p-&gt;right) res.push_back(p-&gt;<span style="color: #000000;">val);
                p </span>= p-&gt;<span style="color: #000000;">left;
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                p </span>=<span style="color: #000000;"> st.top(); st.pop();
                p </span>= p-&gt;<span style="color: #000000;">right;
            }
        }
        </span><span style="color: #0000ff;">while</span> (r &amp;&amp; (r-&gt;left || r-&gt;<span style="color: #000000;">right)) {
            right.push_back(r</span>-&gt;<span style="color: #000000;">val);
            </span><span style="color: #0000ff;">if</span> (r-&gt;right) r = r-&gt;<span style="color: #000000;">right;
            </span><span style="color: #0000ff;">else</span> r = r-&gt;<span style="color: #000000;">left;
        }
        res.insert(res.end(), right.rbegin(), right.rend());
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>Github 同步地址：</p>
<p><a href="https://github.com/grandyang/leetcode/issues/545">https://github.com/grandyang/leetcode/issues/545</a></p>
<p>&nbsp;</p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4392254.html" target="_blank">Binary Tree Right Side View</a></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/problems/boundary-of-binary-tree/">https://leetcode.com/problems/boundary-of-binary-tree/</a></p>
<p><a href="https://leetcode.com/problems/boundary-of-binary-tree/discuss/101288/Java-Recursive-Solution-Beats-94">https://leetcode.com/problems/boundary-of-binary-tree/discuss/101288/Java-Recursive-Solution-Beats-94</a></p>
<p><a href="https://leetcode.com/problems/boundary-of-binary-tree/discuss/101280/Java(12ms)-left-boundary-left-leaves-right-leaves-right-boundary">https://leetcode.com/problems/boundary-of-binary-tree/discuss/101280/Java(12ms)-left-boundary-left-leaves-right-leaves-right-boundary</a></p>
<p><a href="https://leetcode.com/problems/boundary-of-binary-tree/discuss/101294/Java-C%2B%2B-Clean-Code-(1-Pass-perorder-postorder-hybrid)">https://leetcode.com/problems/boundary-of-binary-tree/discuss/101294/Java-C%2B%2B-Clean-Code-(1-Pass-perorder-postorder-hybrid)</a></p>
<p>&nbsp;</p>
</div>
</div>
<p><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2017-05-10 00:17</span>&nbsp;
<a href="https://www.cnblogs.com/grandyang/">Grandyang</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=6833459" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(6833459);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 198221, cb_blogApp = 'grandyang', cb_blogUserGuid = '02affae8-0e77-e111-aa3f-842b2b196315';
    var cb_entryId = 6833459, cb_entryCreatedDate = '2017-05-10 00:17', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 Grandyang
<br /><span id="poweredby">Powered by .NET Core 3.1.0 on Linux</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <a href="https://github.com/grandyang"> 
<img style="position: absolute; top: 0; left: 0; border: 0; z-index:9999;" 
src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png" 
alt="Fork me on GitHub"> 
</a>

<script src="https://files.cnblogs.com/files/grandyang/tctip-1.0.4.js" defer></script>
<script>
new tctip({
top: '20%',
button: {
  id:7,
  type: 'zanzhu',
},
list: [
  {
        type: 'wechat',
	qrImg: 'https://files.cnblogs.com/files/grandyang/wepay.gif'
  }, {
	type: 'announcement',
        qrText: '2020，新的征途...'
  }
]
}).init()
</script>
    </div>
</body>
</html>