
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="Given an integer array&amp;#160;nums, find the contiguous subarray within an array (containing at least " />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>[LeetCode] 152. Maximum Product Subarray 求最大子数组乘积 - Grandyang - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=PyyhYDRKBG1sYtpoHme_xHO5AMd5iN57I45iBKF8FVY" />
    <link id="MainCss" rel="stylesheet" href="/skins/unlimitedsunlight/bundle-unlimitedsunlight.min.css?v=0PW-IbyD73rSsrHXyZPdWAdlgI9zvcQ6P3MLE4OIhi4" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/unlimitedsunlight/bundle-unlimitedsunlight-mobile.min.css?v=1PFKcj_AbkIURdVbGrJ7RA7MSm_08tLLOsnXtqTHyME" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/grandyang/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/grandyang/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/grandyang/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=F-Iy-_Lj7VcUKRIvNkS6UZ5LItMqjh1_L0VZk9Yxfb8"></script>
    <script>
        var currentBlogId = 198221;
        var currentBlogApp = 'grandyang';
        var cb_enable_mathjax = true;
        var isLogined = false;
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <a href="https://github.com/grandyang"> 
<img style="position: absolute; top: 0; left: 0; border: 0; z-index:9999;" 
src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png" 
alt="Fork me on GitHub"> 
</a>

<script src="https://files.cnblogs.com/files/grandyang/tctip-1.0.4.js" defer></script>
<script>
new tctip({
top: '20%',
button: {
  id:7,
  type: 'zanzhu',
},
list: [
  {
        type: 'wechat',
	qrImg: 'https://files.cnblogs.com/files/grandyang/wepay.gif'
  }, {
	type: 'announcement',
        qrText: '2020，新的征途...'
  }
]
}).init()
</script>
    </div>
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/grandyang/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/grandyang/">Grandyang</a>
</h1>
<h2>
仰天长啸仗剑红尘，冬去春来寒暑几更...
</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/grandyang/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/Grandyang">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/grandyang/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
1424&nbsp; </span>
<span id="stats_article_count">文章 - 
1&nbsp; </span>
<span id="stats-comment_count">评论 - 
4014</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/grandyang/p/4028713.html">[LeetCode] 152. Maximum Product Subarray 求最大子数组乘积</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    <p>&nbsp;</p>
<p>Given an integer array&nbsp;<code>nums</code>, find the contiguous subarray within an array (containing at least one number) which has the largest product.</p>
<p>Example 1:</p>
<pre>Input: [2,3,-2,4]
Output: <code>6</code>
Explanation:&nbsp;[2,3] has the largest product 6.
</pre>
<p>Example 2:</p>
<pre>Input: [-2,0,-1]
Output: 0
Explanation:&nbsp;The result cannot be 2, because [-2,-1] is not a subarray.</pre>
<p>&nbsp;</p>
<p>这个求最大子数组乘积问题是由最大子数组之和 <a href="http://www.cnblogs.com/grandyang/p/4377150.html" target="_blank">Maximum Subarray</a>&nbsp;演变而来，但是却比求最大子数组之和要复杂，因为在求和的时候，遇到0，不会改变最大值，遇到负数，也只是会减小最大值而已。而在求最大子数组乘积的问题中，遇到0会使整个乘积为0，而遇到负数，则会使最大乘积变成最小乘积，正因为有负数和0的存在，使问题变得复杂了不少。比如，现在有一个数组 [2, 3, -2, 4]，可以很容易的找出所有的连续子数组，[2]，[3]，[-2]，[4]，[2, 3]，[3, -2]，[-2, 4]，[2, 3, -2]，[3, -2, 4]，[2, 3, -2, 4]，然后可以很轻松的算出最大的子数组乘积为6，来自子数组 [2, 3]。但如何写代码来实现自动找出最大子数组乘积呢，博主最先想到的方比较简单粗暴，就是找出所有的子数组，然后算出每一个子数组的乘积，然后比较找出最大的一个，需要两个 for 循环，第一个 for 遍历整个数组，第二个 for 遍历含有当前数字的子数组，就是按以下顺序找出子数组: [2]，[2, 3]，[2, 3, -2]，[2, 3, -2, 4]，[3]，[3, -2]，[3, -2, 4]，[-2]，[-2, 4]，[4]，<span>在本地测试的一些数组全部通过，于是兴高采烈的拿到 OJ 上测试，结果丧心病狂的 OJ 用一个有 15000 个数字的数组来测试，然后说程序的运行时间超过了要求值，一看代码，果然如此，时间复杂度 O(n2), 得想办法只用一次循环搞定。想来想去想不出好方法，于是到网上搜各位大神的解决方法。其实这道题最直接的方法就是用 DP 来做，而且要用两个 dp 数组，其中 f[i] 表示子数组 [0, i] 范围内并且一定包含 nums[i] 数字的最大子数组乘积，g[i] 表示子数组 [0, i] 范围内并且一定包含 nums[i] 数字的最小子数组乘积，初始化时 f[0] 和 g[0] 都初始化为 nums[0]，其余都初始化为0。那么从数组的第二个数字开始遍历，那么此时的最大值和最小值只会在这三个数字之间产生，即 f[i-1]*nums[i]，g[i-1]*nums[i]，和 nums[i]。所以用三者中的最大值来更新 f[i]，用最小值来更新 g[i]，然后用 f[i] 来更新结果 res 即可，由于最终的结果不一定会包括 nums[n-1] 这个数字，所以 f[n-1] 不一定是最终解，不断更新的结果 res 才是，参见代码如下：</span></p>
<p>&nbsp;</p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], n =<span style="color: #000000;"> nums.size();
        vector</span>&lt;<span style="color: #0000ff;">int</span>&gt; f(n, <span style="color: #800080;">0</span>), g(n, <span style="color: #800080;">0</span><span style="color: #000000;">);
        f[</span><span style="color: #800080;">0</span>] = nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        g[</span><span style="color: #800080;">0</span>] = nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; n; ++<span style="color: #000000;">i) {
            f[i] </span>= max(max(f[i - <span style="color: #800080;">1</span>] * nums[i], g[i - <span style="color: #800080;">1</span>] *<span style="color: #000000;"> nums[i]), nums[i]);
            g[i] </span>= min(min(f[i - <span style="color: #800080;">1</span>] * nums[i], g[i - <span style="color: #800080;">1</span>] *<span style="color: #000000;"> nums[i]), nums[i]);
            res </span>=<span style="color: #000000;"> max(res, f[i]);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>我们可以对上面的解法进行空间上的优化，以下摘自 OJ 官方解答，大体思路相同，写法更加简洁：</p>
<p>Besides keeping track of the largest product, we also need to keep track of the smallest product. Why? The smallest product, which is the largest in the negative sense could become the maximum when being multiplied by a negative number.</p>
<p>Let us denote that:</p>
<div class="cnblogs_code">
<pre>f(k) = Largest product subarray, <span style="color: #0000ff;">from</span> index <span style="color: #800080;">0</span> up to k.</pre>
</div>
<p>&nbsp;</p>
<p>Similarly,</p>
<div class="cnblogs_code">
<pre>g(k) = Smallest product subarray, <span style="color: #0000ff;">from</span> index <span style="color: #800080;">0</span> up to k.</pre>
</div>
<p>&nbsp;</p>
<p>Then,</p>
<div class="cnblogs_code">
<pre>f(k) = max( f(k-<span style="color: #800080;">1</span>) * A[k], A[k], g(k-<span style="color: #800080;">1</span>) *<span style="color: #000000;"> A[k] )
g(k) </span>= min( g(k-<span style="color: #800080;">1</span>) * A[k], A[k], f(k-<span style="color: #800080;">1</span>) * A[k] )</pre>
</div>
<p>&nbsp;</p>
<p>There we have a dynamic programming formula. Using two arrays of size&nbsp;<em>n</em>, we could deduce the final answer as f(<em>n</em>-1). Since we only need to access its previous elements at each step, two variables are sufficient.</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">public</span> <span style="color: #0000ff;">int</span> maxProduct(<span style="color: #0000ff;">int</span><span style="color: #000000;">[] A) {
   assert A.length </span>&gt; <span style="color: #800080;">0</span><span style="color: #000000;">;
   </span><span style="color: #0000ff;">int</span> max = A[<span style="color: #800080;">0</span>], min = A[<span style="color: #800080;">0</span>], maxAns = A[<span style="color: #800080;">0</span><span style="color: #000000;">];
   </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; A.length; i++<span style="color: #000000;">) {
      </span><span style="color: #0000ff;">int</span> mx = max, mn =<span style="color: #000000;"> min;
      max </span>= Math.max(Math.max(A[i], mx * A[i]), mn *<span style="color: #000000;"> A[i]);
      min </span>= Math.min(Math.min(A[i], mx * A[i]), mn *<span style="color: #000000;"> A[i]);
      maxAns </span>=<span style="color: #000000;"> Math.max(max, maxAns);
   }
   </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> maxAns;
}</span></pre>
</div>
<p>&nbsp;</p>
<p>根据上述描述可以写出代码如下：</p>
<p>&nbsp;</p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">if</span> (nums.empty()) <span style="color: #0000ff;">return</span> <span style="color: #800080;">0</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], mn = nums[<span style="color: #800080;">0</span>], mx = nums[<span style="color: #800080;">0</span><span style="color: #000000;">];
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">int</span> tmax = mx, tmin =<span style="color: #000000;"> mn;
            mx </span>= max(max(nums[i], tmax * nums[i]), tmin *<span style="color: #000000;"> nums[i]);
            mn </span>= min(min(nums[i], tmax * nums[i]), tmin *<span style="color: #000000;"> nums[i]);
            res </span>=<span style="color: #000000;"> max(res, mx);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>下面这种方法也是用两个变量来表示当前最大值和最小值的，但是没有无脑比较三个数，而是对于当前的 nums[i] 值进行了正负情况的讨论：</p>
<div>1. 当遍历到一个正数时，此时的最大值等于之前的最大值乘以这个正数和当前正数中的较大值，此时的最小值等于之前的最小值乘以这个正数和当前正数中的较小值。</div>
<p>2.&nbsp;当遍历到一个负数时，先用一个变量t保存之前的最大值 mx，然后此时的最大值等于之前最小值乘以这个负数和当前负数中的较大值，此时的最小值等于之前保存的最大值t乘以这个负数和当前负数中的较小值。</p>
<p>3.&nbsp;在每遍历完一个数时，都要更新最终的最大值。</p>
<div>P.S. 如果这里改成求最小值的话，就是求最小子数组乘积，并且时间复杂度是醉人的 O(n)，是不是很强大呢，参见代码如下：</div>
<p>&nbsp;</p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], mx = res, mn =<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &gt; <span style="color: #800080;">0</span><span style="color: #000000;">) {
                mx </span>= max(mx *<span style="color: #000000;"> nums[i], nums[i]);
                mn </span>= min(mn *<span style="color: #000000;"> nums[i], nums[i]);
            } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
                </span><span style="color: #0000ff;">int</span> t =<span style="color: #000000;"> mx;
                mx </span>= max(mn *<span style="color: #000000;"> nums[i], nums[i]);
                mn </span>= min(t *<span style="color: #000000;"> nums[i], nums[i]);
            }
            res </span>=<span style="color: #000000;"> max(res, mx);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>下面这道题使用了一个 trick 来将上面解法的分情况讨论合成了一种，在上面的解法中分析了当 nums[i] 为正数时，最大值和最小值的更新情况，为负数时，稍有不同的就是最小值更新时要用到之前的最大值，而不是更新后的最大值，所以才要用变量t来保存之前的结果。而下面这种方法的巧妙处在于先判断一个当前数字是否是负数，是的话就交换最大值和最小值。那么此时的 mx 就是之前的 mn，所以 mx 的更新还是跟上面的方法是统一的，而在在更新 mn 的时候，之前的 mx 已经保存到 mn 中了，而且并没有改变，所以可以直接拿来用，不得不说，确实叼啊，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法四：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], mx = res, mn =<span style="color: #000000;"> res;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">1</span>; i &lt; nums.size(); ++<span style="color: #000000;">i) {
            </span><span style="color: #0000ff;">if</span> (nums[i] &lt; <span style="color: #800080;">0</span><span style="color: #000000;">) swap(mx, mn);
            mx </span>= max(nums[i], mx *<span style="color: #000000;"> nums[i]);
            mn </span>= min(nums[i], mn *<span style="color: #000000;"> nums[i]);
            res </span>=<span style="color: #000000;"> max(res, mx);
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>再来看一种画风不太一样的解法，这种解法遍历了两次，一次是正向遍历，一次是反向遍历，相当于正向建立一个累加积数组，每次用出现的最大值更新结果 res，然后再反响建立一个累加积数组，再用出现的最大值更新结果 res，注意当遇到0的时候，prod 要重置为1。至于为啥正反两次遍历就可以得到正确的结果了呢？主要还是由于负数个数的关系，因为负数可能会把最大值和最小值翻转，那么当有奇数个负数时，如果只是正向遍历的话，可能会出错，比如 [-1, -2, -3]，累加积会得到 -1，2，-6，看起来最大值只能为2，其实不对，而如果我们再反向来一遍，累加积为 -3，6，-6，就可以得到6了。所以当负数个数为奇数时，首次出现和末尾出现的负数就很重要，有可能会是最大积的组成数字，所以遍历两次就不会漏掉组成最大值的机会，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法五：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    </span><span style="color: #0000ff;">int</span> maxProduct(vector&lt;<span style="color: #0000ff;">int</span>&gt;&amp;<span style="color: #000000;"> nums) {
        </span><span style="color: #0000ff;">int</span> res = nums[<span style="color: #800080;">0</span>], prod = <span style="color: #800080;">1</span>, n =<span style="color: #000000;"> nums.size();
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = <span style="color: #800080;">0</span>; i &lt; n; ++<span style="color: #000000;">i) {
            res </span>= max(res, prod *=<span style="color: #000000;"> nums[i]);
            </span><span style="color: #0000ff;">if</span> (nums[i] == <span style="color: #800080;">0</span>) prod = <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        prod </span>= <span style="color: #800080;">1</span><span style="color: #000000;">;
        </span><span style="color: #0000ff;">for</span> (<span style="color: #0000ff;">int</span> i = n - <span style="color: #800080;">1</span>; i &gt;= <span style="color: #800080;">0</span>; --<span style="color: #000000;">i) {
            res </span>= max(res, prod *=<span style="color: #000000;"> nums[i]);
            </span><span style="color: #0000ff;">if</span> (nums[i] == <span style="color: #800080;">0</span>) prod = <span style="color: #800080;">1</span><span style="color: #000000;">;
        }
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> res;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>Github 同步地址：</p>
<p><a href="https://github.com/grandyang/leetcode/issues/152">https://github.com/grandyang/leetcode/issues/152</a></p>
<p>&nbsp;</p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4377150.html" target="_blank">Maximum Subarray</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4383632.html" target="_blank">House Robber</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/4650187.html">Product of Array Except Self</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7084957.html" target="_blank">Maximum Product of Three Numbers</a></p>
<p><a href="http://www.cnblogs.com/grandyang/p/7753959.html">Subarray Product Less Than K</a></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank">https://leetcode.com/problems/maximum-product-subarray/</a></p>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/discuss/48302/2-passes-scan-beats-99" target="_blank">https://leetcode.com/problems/maximum-product-subarray/discuss/48302/2-passes-scan-beats-99</a></p>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/discuss/48261/share-my-dp-code-that-got-ac" target="_blank">https://leetcode.com/problems/maximum-product-subarray/discuss/48261/share-my-dp-code-that-got-ac</a></p>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/discuss/48252/sharing-my-solution-o1-space-on-running-time" target="_blank">https://leetcode.com/problems/maximum-product-subarray/discuss/48252/sharing-my-solution-o1-space-on-running-time</a></p>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/discuss/48230/possibly-simplest-solution-with-on-time-complexity" target="_blank">https://leetcode.com/problems/maximum-product-subarray/discuss/48230/possibly-simplest-solution-with-on-time-complexity</a></p>
<p><a href="https://leetcode.com/problems/maximum-product-subarray/discuss/48389/my-concise-dp-on-java-solution-with-o1-extra-space" target="_blank">https://leetcode.com/problems/maximum-product-subarray/discuss/48389/my-concise-dp-on-java-solution-with-o1-extra-space</a></p>
<p>&nbsp;</p>
<p><a id="cb_post_title_url" class="postTitle2" href="http://www.cnblogs.com/grandyang/p/4606334.html">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2014-10-16 14:24</span>&nbsp;
<a href="https://www.cnblogs.com/grandyang/">Grandyang</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=4028713" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(4028713);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 198221, cb_blogApp = 'grandyang', cb_blogUserGuid = '02affae8-0e77-e111-aa3f-842b2b196315';
    var cb_entryId = 4028713, cb_entryCreatedDate = '2014-10-16 14:24', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 Grandyang
<br /><span id="poweredby">Powered by .NET Core 3.1.0 on Linux</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <a href="https://github.com/grandyang"> 
<img style="position: absolute; top: 0; left: 0; border: 0; z-index:9999;" 
src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png" 
alt="Fork me on GitHub"> 
</a>

<script src="https://files.cnblogs.com/files/grandyang/tctip-1.0.4.js" defer></script>
<script>
new tctip({
top: '20%',
button: {
  id:7,
  type: 'zanzhu',
},
list: [
  {
        type: 'wechat',
	qrImg: 'https://files.cnblogs.com/files/grandyang/wepay.gif'
  }, {
	type: 'announcement',
        qrText: '2020，新的征途...'
  }
]
}).init()
</script>
    </div>
</body>
</html>