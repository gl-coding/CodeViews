
<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="never" />
    <meta property="og:description" content="Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>[LeetCode] 426. Convert Binary Search Tree to Sorted Doubly Linked List 将二叉搜索树转为有序双向链表 - Grandyang - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=PyyhYDRKBG1sYtpoHme_xHO5AMd5iN57I45iBKF8FVY" />
    <link id="MainCss" rel="stylesheet" href="/skins/unlimitedsunlight/bundle-unlimitedsunlight.min.css?v=0PW-IbyD73rSsrHXyZPdWAdlgI9zvcQ6P3MLE4OIhi4" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/unlimitedsunlight/bundle-unlimitedsunlight-mobile.min.css?v=1PFKcj_AbkIURdVbGrJ7RA7MSm_08tLLOsnXtqTHyME" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/grandyang/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/grandyang/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/grandyang/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=F-Iy-_Lj7VcUKRIvNkS6UZ5LItMqjh1_L0VZk9Yxfb8"></script>
    <script>
        var currentBlogId = 198221;
        var currentBlogApp = 'grandyang';
        var cb_enable_mathjax = true;
        var isLogined = false;
    </script>
    <script type="text/x-mathjax-config">
        MathJax.Hub.Config({
        tex2jax: { inlineMath: [['$','$'], ['\\(','\\)']], processClass: 'math', processEscapes: true },
        TeX: {
        equationNumbers: { autoNumber: ['AMS'], useLabelIds: true },
        extensions: ['extpfeil.js', 'mediawiki-texvc.js'],
        Macros: {bm: "\\boldsymbol"}
        },
        'HTML-CSS': { linebreaks: { automatic: true } },
        SVG: { linebreaks: { automatic: true } }
        });
    </script>
    <script src="https://mathjax.cnblogs.com/2_7_5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
</head>
<body>
    <a name="top"></a>
    <div id="page_begin_html">
        <a href="https://github.com/grandyang"> 
<img style="position: absolute; top: 0; left: 0; border: 0; z-index:9999;" 
src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png" 
alt="Fork me on GitHub"> 
</a>

<script src="https://files.cnblogs.com/files/grandyang/tctip-1.0.4.js" defer></script>
<script>
new tctip({
top: '20%',
button: {
  id:7,
  type: 'zanzhu',
},
list: [
  {
        type: 'wechat',
	qrImg: 'https://files.cnblogs.com/files/grandyang/wepay.gif'
  }, {
	type: 'announcement',
        qrText: '2020，新的征途...'
  }
]
}).init()
</script>
    </div>
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/grandyang/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/grandyang/">Grandyang</a>
</h1>
<h2>
仰天长啸仗剑红尘，冬去春来寒暑几更...
</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/grandyang/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/Grandyang">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/grandyang/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
1424&nbsp; </span>
<span id="stats_article_count">文章 - 
1&nbsp; </span>
<span id="stats-comment_count">评论 - 
4014</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/grandyang/p/9615871.html">[LeetCode] 426. Convert Binary Search Tree to Sorted Doubly Linked List 将二叉搜索树转为有序双向链表</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    <p>&nbsp;</p>
<div class="question-description__3U1T">
<p>Convert a BST to a sorted circular doubly-linked list in-place. Think of the left and right pointers as synonymous to the previous and next pointers in a doubly-linked list.</p>
<p>Let's take the following BST as an example, it may help you understand the problem better:</p>
&nbsp;
<p><img src="https://leetcode.com/static/images/problemset/BSTDLLOriginalBST.png" alt="" width="30%" height="30%" /></p>
&nbsp;
<p>We want to transform this BST into a circular doubly linked list. Each node in a doubly linked list has a predecessor and successor. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.</p>
<p>The figure below shows the circular doubly linked list for the BST above. The "head" symbol means the node it points to is the smallest element of the linked list.</p>
&nbsp;
<p><img src="https://leetcode.com/static/images/problemset/BSTDLLReturnDLL.png" alt="" width="40%" height="40%" /></p>
&nbsp;
<p>Specifically, we want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. We should return the pointer to the first element of the linked list.</p>
<p>The figure below shows the transformed BST. The solid line indicates the successor relationship, while the dashed line means the predecessor relationship.</p>
&nbsp;
<p><img src="https://leetcode.com/static/images/problemset/BSTDLLReturnBST.png" alt="" width="30%" height="30%" /></p>
<p>&nbsp;</p>
</div>
<p>这道题给了一个二叉搜索树，让我们将其转化为双向链表。并且题目中给了一个带图的例子，帮助理解。题目本身并不难理解，仔细观察下给的示例图。首先，转化成双向链表的每个结点都有 left 和 right 指针指向左右两个结点，不管其原来是否是叶结点还是根结点，转换后统统没有区别。其次，这是个循环双向链表，即首尾结点是相连的，原先的二叉搜索树中的最左结点和最右结点，现在也互相连接起来了。最后，返回的结点不再是原二叉搜索树的根结点 root 了，而是最左结点，即最小值结点。</p>
<p>好，发现了上述规律后，来考虑如何破题。根据博主多年经验，跟二叉搜索树有关的题，肯定要利用其性质，即左&lt;根&lt;右，即左子结点值小于根结点值小于右子结点值。而且十有八九都得用中序遍历来解，因为中序遍历的顺序就是左根右啊，跟性质吻合。观察到原二叉搜索树中结点4连接着结点2和结点5，而在双向链表中，连接的是结点3和结点5，这就是为啥要用中序遍历了，因为只有中序遍历，结点3之后才会遍历到结点4，这时候可以将结点3和结点4串起来。决定了用中序遍历之后，就要考虑是迭代还是递归的写法，博主建议写递归的，一般写起来都比较简洁，而且递归是解树类问题的神器啊，十有八九都是用递归，一定要熟练掌握。再写中序遍历之前，其实还有难点，因为需要把相邻的结点连接起来，所以需要知道上一个遍历到的结点是什么，所以用一个变量 pre，来记录上一个遍历到的结点。还需要一个变量 head，来记录最左结点，这样的话，在递归函数中，先判空，之后对左子结点调用递归，这样会先一直递归到最左结点，此时如果 head 为空的话，说明当前就是最左结点，赋值给 head 和 pre，对于之后的遍历到的结点，那么可以和 pre 相互连接上，然后 pre 赋值为当前结点 node，再对右子结点调用递归即可，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法一：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* treeToDoublyList(Node*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        Node </span>*head = NULL, *pre =<span style="color: #000000;"> NULL;
        inorder(root, pre, head);
        pre</span>-&gt;right =<span style="color: #000000;"> head;
        head</span>-&gt;left =<span style="color: #000000;"> pre;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
    </span><span style="color: #0000ff;">void</span> inorder(Node* node, Node*&amp; pre, Node*&amp;<span style="color: #000000;"> head) {
        </span><span style="color: #0000ff;">if</span> (!node) <span style="color: #0000ff;">return</span><span style="color: #000000;">;
        inorder(node</span>-&gt;<span style="color: #000000;">left, pre, head);
        </span><span style="color: #0000ff;">if</span> (!<span style="color: #000000;">head) {
            head </span>=<span style="color: #000000;"> node;
            pre </span>=<span style="color: #000000;"> node;
        } </span><span style="color: #0000ff;">else</span><span style="color: #000000;"> {
            pre</span>-&gt;right =<span style="color: #000000;"> node;
            node</span>-&gt;left =<span style="color: #000000;"> pre;
            pre </span>=<span style="color: #000000;"> node;
        }
        inorder(node</span>-&gt;<span style="color: #000000;">right, pre, head);
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>虽然说树类问题首推递归解法，但是中序遍历是可以用迭代来写的，可以参见博主之前的博客&nbsp;<a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a>。迭代写法借用了栈，其实整体思路和递归解法没有太大的区别，递归的本质也是将断点存入栈中，以便之后可以返回，这里就不多讲解了，可以参见上面的讲解，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法二：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* treeToDoublyList(Node*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        Node </span>*head = NULL, *pre =<span style="color: #000000;"> NULL;
        stack</span>&lt;Node*&gt;<span style="color: #000000;"> st;
        </span><span style="color: #0000ff;">while</span> (root || !<span style="color: #000000;">st.empty()) {
            </span><span style="color: #0000ff;">while</span><span style="color: #000000;"> (root) {
                st.push(root);
                root </span>= root-&gt;<span style="color: #000000;">left;
            }
            root </span>=<span style="color: #000000;"> st.top(); st.pop();
            </span><span style="color: #0000ff;">if</span> (!head) head =<span style="color: #000000;"> root;
            </span><span style="color: #0000ff;">if</span><span style="color: #000000;"> (pre) {
                pre</span>-&gt;right =<span style="color: #000000;"> root;
                root</span>-&gt;left =<span style="color: #000000;"> pre;
            }
            pre </span>=<span style="color: #000000;"> root;
            root </span>= root-&gt;<span style="color: #000000;">right;
        }
        head</span>-&gt;left =<span style="color: #000000;"> pre;
        pre</span>-&gt;right =<span style="color: #000000;"> head;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> head;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>这道题还有一种使用分治法 Divide and Conquer 来做的方法。分治法，顾名思义，就是把一项任务分成两半，用相同的逻辑去分别处理，之后再粘合起来。混合排序 Merge Sort 用的也是这种思路。这里可以对左右子结点调用递归函数，suppose 我们得到了两个各自循环的有序双向链表，然后把根结点跟左右子结点断开，将其左右指针均指向自己，这样就形成了一个单个结点的有序双向链表，虽然只是个光杆司令，但人家仍然是有序双向链表，不是沙雕，就问你叼不叼。那么此时只要再写一个连接两个有序双向链表的子函数，就可以将这三个有序双向链表按顺序链接起来了。</p>
<p>而链接两个有序双向链表的子函数也简单，首先判空，若一个为空，则返回另一个。如果两个都不为空，则把第一个链表的尾结点的右指针链上第二个链表的首结点，同时第二个链表的首结点的左指针链上第一个链表的尾结点。同理，把第二个链表的尾结点的右指针链上第一个链表的首结点，同时第一个链表的首结点的左指针链上第二个链表的尾结点。有木有读晕，可以自己画图，其实很好理解的诶，参见代码如下：</p>
<p>&nbsp;</p>
<p>解法三：</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">class</span><span style="color: #000000;"> Solution {
</span><span style="color: #0000ff;">public</span><span style="color: #000000;">:
    Node</span>* treeToDoublyList(Node*<span style="color: #000000;"> root) {
        </span><span style="color: #0000ff;">if</span> (!root) <span style="color: #0000ff;">return</span><span style="color: #000000;"> NULL;
        Node </span>*leftHead = treeToDoublyList(root-&gt;<span style="color: #000000;">left);
        Node </span>*rightHead = treeToDoublyList(root-&gt;<span style="color: #000000;">right);
        root</span>-&gt;left =<span style="color: #000000;"> root;
        root</span>-&gt;right =<span style="color: #000000;"> root;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> connect(connect(leftHead, root), rightHead);
    }
    Node</span>* connect(Node* node1, Node*<span style="color: #000000;"> node2) {
        </span><span style="color: #0000ff;">if</span> (!node1) <span style="color: #0000ff;">return</span><span style="color: #000000;"> node2;
        </span><span style="color: #0000ff;">if</span> (!node2) <span style="color: #0000ff;">return</span><span style="color: #000000;"> node1;
        Node </span>*tail1 = node1-&gt;left, *tail2 = node2-&gt;<span style="color: #000000;">left;
        tail1</span>-&gt;right =<span style="color: #000000;"> node2;
        node2</span>-&gt;left =<span style="color: #000000;"> tail1;
        tail2</span>-&gt;right =<span style="color: #000000;"> node1;
        node1</span>-&gt;left =<span style="color: #000000;"> tail2;
        </span><span style="color: #0000ff;">return</span><span style="color: #000000;"> node1;
    }
};</span></pre>
</div>
<p>&nbsp;</p>
<p>Github 同步地址：</p>
<p><a href="https://github.com/grandyang/leetcode/issues/426">https://github.com/grandyang/leetcode/issues/426</a></p>
<p>&nbsp;</p>
<p>类似题目：</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4297300.html" target="_blank">Binary Tree Inorder Traversal</a></p>
<p>&nbsp;</p>
<p>参考资料：</p>
<p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/</a></p>
<p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/174111/inorder-vs-divide-and-conquer">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/174111/inorder-vs-divide-and-conquer</a></p>
<p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/151228/Java-Simple-InOrder-no-Global">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/151228/Java-Simple-InOrder-no-Global</a></p>
<p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/138621/C%2B%2B-solution">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/138621/C%2B%2B-solution</a></p>
<p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/149151/Concise-Java-solution-Beats-100">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/149151/Concise-Java-solution-Beats-100</a></p>
<p><a href="https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/154659/Divide-and-Conquer-without-Dummy-Node-Java-Solution">https://leetcode.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list/discuss/154659/Divide-and-Conquer-without-Dummy-Node-Java-Solution</a></p>
<p>&nbsp;</p>
<p><a href="http://www.cnblogs.com/grandyang/p/4606334.html" target="_blank">LeetCode All in One 题目讲解汇总(持续更新中...)</a></p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2018-09-09 23:34</span>&nbsp;
<a href="https://www.cnblogs.com/grandyang/">Grandyang</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=9615871" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(9615871);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 198221, cb_blogApp = 'grandyang', cb_blogUserGuid = '02affae8-0e77-e111-aa3f-842b2b196315';
    var cb_entryId = 9615871, cb_entryCreatedDate = '2018-09-09 23:34', cb_postType = 1; 
    loadViewCount(cb_entryId);
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        setTimeout(function () { incrementViewCount(cb_entryId); }, 50);
        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 Grandyang
<br /><span id="poweredby">Powered by .NET Core 3.1.0 on Linux</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    <div id="page_end_html">
        <a href="https://github.com/grandyang"> 
<img style="position: absolute; top: 0; left: 0; border: 0; z-index:9999;" 
src="https://github.blog/wp-content/uploads/2008/12/forkme_left_gray_6d6d6d.png" 
alt="Fork me on GitHub"> 
</a>

<script src="https://files.cnblogs.com/files/grandyang/tctip-1.0.4.js" defer></script>
<script>
new tctip({
top: '20%',
button: {
  id:7,
  type: 'zanzhu',
},
list: [
  {
        type: 'wechat',
	qrImg: 'https://files.cnblogs.com/files/grandyang/wepay.gif'
  }, {
	type: 'announcement',
        qrText: '2020，新的征途...'
  }
]
}).init()
</script>
    </div>
</body>
</html>